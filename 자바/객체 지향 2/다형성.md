## 다형성

내 노션 - [https://www.notion.so/1891f79f810246b4bd73b18e4889c0e0](https://www.notion.so/1891f79f810246b4bd73b18e4889c0e0) 여기서 참고하기.

<br/> 

### 다형성이란?

‘여러 가지 형태를 가질 수 있는 능력’ 을 의미한다. <br/>자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현한다.

<br/>좀 더 구체적으로 말하자면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.

<br/>원래는 인스턴스의 타입과 일치하는 타입의 참조변수만을 사용했다. <br/>즉,  Tv인스턴스를 다루기 위해서는 Tv타입의 참조변수를 사용하고, <br/>CaptionTv인스턴스를 다루기 위해서는 Caption타입의 참조변수를 사용했다. 

<br/>하지만 Tv와  CaptionTv클래스가 서로 상속관계에 있을 경우, 다음과 같이 조상 클래스 타입의 <br/>참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.

```java
Tv t = new CaptionTv(); // 조상 타입의 참조변수로 자손 인스턴스를 참조
```

<br/>인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상타입의 참조변수로 참조하는 것은 어떤 차이가 있나??

```java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

<br/>실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조 변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없다. 

<br/>Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들만 사용할 수 있다.

<br/>따라서, 생성된 Caption인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 메머, text와 caption( ) 은 <br/>참조변수 t로 사용이 불가능하다. 즉, t.text 또는 t.caption( ) 와 같이 할 수 없다는 것이다. 

<br/>

**둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.**

| t 변수에는  | Tv클래스 있는건 다 사용 할 수 있고, CaptionTv 클래스에 있는 text와, caption( ) 을 사용할 수 없다. |
| --- | --- |
| c 변수에는  | Tv클래스 있는건 다 사용 할 수 있으며, CaptionTv 있는 것도 다 사용 할 수 있다. |

<br/>

### 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 가능할까?

**가능하지 않다. (에러 발생)**

<br/>이유는, 인스턴스의 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문이다.

```java
CaptionTv c = new Tv();
```

<br/>CaptionTv클래스에는 text와 caption( ) 이 정의되어 있으므로 참조변수 c로는 c.text, c.caption( ) 과 <br/>같은 방식으로 c가 참조하고 있는 인스턴스에서  text와 caption( ) 을 사용하려 할 수 있다.

<br/>

### 하지만, c가 참조하고 있는 인스턴스는 Tv타입이고, Tv타입의 인스턴스에는 <br/>text와 caption( ) 이 존재하지 않기 때문에 이들을 사용하려 하면 문제가 발생한다.

<br/>그래서, 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 <br/>사용하고자 할 가능성이 있으므로 허용하지 않는 것이다. 

<br/>

**조상타입의 참조변수로 자손타입의 인스턴스(실제 존재하는 만들어 진것)를 참조할 수 있다.**

**반대로 자손타입의 참조변수로 조상타입의 인스턴스를(실제 존재하는 만들어 진것) 참조할 수는 없다.**


<br/><br/>

## 형변환

작은 자료형에서 큰 자료형의 형변환은 생략이 가능하듯이, 자손타입의 참조변수를 조상타입으로 <br/>형변환하는 경우에는 형변환을 생략할 수 있다.

<br/>

**자손타입 → 조상타입 : 형변환 생략가능**

**자손타입 ← 조상타입 : 형변환 생략불가**

<br/>

조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것을 다운캐스팅이라고 하며, <br/>자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것을 업캐스팅이라고 한다.

<br/>

**괄호 ( ) 안에 변환하고자 하는 타입의 이름( 클래스 ) 을 적어주면 되는 것이다.**

**그리고 형변환은 상속관계 에서만 가능한 것이다. 형제관계는 안된다.**

<br/>Car타입 참조변수와 FireEngine 타입 참조변수 간의 형변환을 예로 들어 보자.

```java
Car car = null;
FireEngine fe = new FireEngine();
FireEngine fe2 = null;

car = fe; // car = (Car) fe; 에서 형변환 생략됨. 업캐스팅
fe2  = (FireEngine) car; // 형변환을 생략불가. 다운 캐스팅
```

<br/>Car타입의 참조변수 c를 자손인 FireEngine 타입으로 변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수를 늘리는 것이므로,<br/> 실제 인스턴스의 멤버 개수보다 참조변수가 사용할 수 있는 멤버의 개수가 더 많아지므로 문제가 발생할 가능성이 있다.

<br/>형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 <br/>인스턴스에 아무런 영향을 미치지 않는다. 단지, 참조변수의 형변환을 통해서 참조하고 있는 인스턴스에서 <br/>사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.


<br/>

### 헷갈리지 말기.

다운캐스팅은 타입만 영향이 있을뿐이다.!! 그 이상 그 이하도 없다 !!

원래 타입이 똑같아야 대입이 된다.

여기서도 똑같다. car 는 car 만 대입 되고, FireEngine 은 FireEngine 만 대입 된다. 

<br/>이걸 깨기 위해 형변환을 하는 것이다.

업캐스팅 - 자손이 부모 타입을 바뀔때는 상관이 없다. 뭐가? 명시 해줄 필요가 없단 끝이다.

문제는 밑에 있다.

<br/>다운캐스팅 - FireEngine 에 car 타입을 넣어야 되는데 되지 않는 것이다.<br/> 이럴땐 다운캐스팅을 하는 것이다. <br/><br/>그렇지만 이것은 문제가 될 수도 있다. 그렇기에 우리 눈에 명시를 해줘야 하는 것이다.<br/> 즉, FireEngine 에 car 타입을 넣을때는 다운캐스팅을 명시 해줘야 하는 것이다.

<br/>예제 1.

```java
package test;

class Car {
	String color;
	int door;

	void drive() {
		System.out.println("drive, Brrr ~");
	}

	void stop() {
		System.out.println("stop!!");
	}

}

class FireEngine extends Car {
	void water() {
		System.out.println("water!!");
	}
}

public class Test1 {

	public static void main(String[] args) {

		Car car = null;
		FireEngine fe = new FireEngine();
		FireEngine fe2 = null;
		
		fe.water();
		car = fe;
		car.water(); // 에러 발생.
		fe2 = (FireEngine) car;
		fe2.water();
		
	}

}

출력값
water!!
water!!

```

<br/><br/>설명과 함께 있는 예제 2.
```java
package test;

class Car {
	String color;
	int door;

	void drive() {
		System.out.println("drive, Brrrr");
	}

	void stop() {
		System.out.println("stop");
	}
}

class FireEngine extends Car {
	void water() {
		System.out.println("water!!");
	}
}

class Test2 {
	public static void main(String[] args) {
		
		//	보는 시점 
		//	1. 다운캐스팅 되는걸 보고, 그냥 타입만 바뀌는 타입으로 변경 되었다 생각하면 되는 것이다.

		//	2. 다운 캐스팅 되는 변수가 인스턴스를 참조 하고 있는지 확인하기. (new Car();)

		//	3. 'FireEngine' 변수 안에 무슨 인스턴스가 참조하고 있는지 확인하기.

		//	4-1. car 가 조상 클래스이면 FireEngine 클래스에서 새로 추가된 내용이 car에서 
        //  없기 때문에 에러가 발생하는 것이다. 

		//  4-2. car 가 new FireEngine(); 참조 하고 있다면, FireEngine 인스턴스가 fe 에 들어가는 것이다. 
	    //       타입은 물론 다운캐스팅에 의해 FireEngine인 것이다. 
        //       즉, FireEngine은 car를 상속 받고 있기 때문에 모든걸 사용 할수 있게 되는 것이다.
		
		
	 // 테스트 1------------------------------
	 /* Car car = new FireEngine(); // 타입을 맞춰준다고 쉽게 생각해보자. 
	    							// 그러면 FireEngine 클래스를 car 클래스로 맞춰 줄것이다.
	    							// (상속 관계는 필수로 생각하자.)
	    							// 그렇다면 car 타입의 객체들만 사용할수 있다는 뜻이다.
	    							// 그럼 상식적으로 FireEngine 에 있는 객체들은 사용하지 못한다.
		Car car2 = null;
		FireEngine fe = null;

		
		// car.water(); 에러
		car.drive();
   	    fe = (FireEngine) car; // car가 참조하고 있는 것은 new FireEngine(); 이기 때문에 fe.drive(); 가능하다. 

   	    					   // 왜? FireEngine 클래스는 car를 상속 받았기 때문에 사용할 수 있게된 것이다.

   	    					   // 즉, car 클래스 이지만 참조값은 FireEngine 인스턴스 이기에 car의 객체들을 
                                  사용할 수 있는것이다. (상속이 중요)

   	    					   // 다시 말하면 car = new FireEngine(); 이기 때문에 결국, 들어가는 것은
                                  
   	    					   // 다운캐스팅 하는 (FireEngine) 이 들어가는 것이다
   	    					   
   	    					   // 'car' 변수의 타입은 원래 car 타입 이니깐 다운캐스팅에 의해 (FireEngine) 명시 
                                  해준걸로 내려 fe가 된것이고,

   	    					   // 'car' 변수 안에 들어 있는 값은 new FireEngine() 인스턴스인 
                                  주소값이 fe에 참조 되는 것이다.   
   	    
   	    fe.water();
		fe.drive();
		car2 = fe;
		car2.drive(); 
  	*/		
			
	 // 테스트 2------------------------------
	 /* Car car = new Car();
		Car car2 = null;
		FireEngine fe = null;

		car.drive();
   	    // fe = (FireEngine) car;    에러 발생. 
							      // 이유는, 헷갈리지 말기 !! 
                                     (FireEngine) 이렇게 다운캐스팅 하는건 타입만 바꾼다는 것이다.
                                     그 이상, 그 이하도 없음. 

		   						  // car 클래스에서 FireEngine 으로 다운캐스팅 했고, 
                                     'car' 변수에는 new Car(); 인스턴스가 들어 있다.

								  // 여기서 Car 인스턴스 참조값 안에는 FireEngine 객체가 없다.
                                   즉, FireEngine 클래스가 가지고 있는 메서드 water() 가 없는 것이다. 

                                   이건 FireEngine 만 가지고 있는 것.

								  // 즉, car는 조상클래스라서 상속을 당한 입장이다. 
                                  그렇기에 water()가 없는 것이다.

								  // 그렇기에 에러 발생.

		// fe.drive(); // 에러 발생.
		car2 = fe;
		// car2.drive();
	 */

		
	//	보는 시점 
	//	1. 다운캐스팅 되는걸 보고, 그냥 타입만 바뀌는 타입으로 변경 되었다 생각하면 되는 것이다.
	//	2. 다운 캐스팅 되는 변수가 인스턴스를 참조 하고 있는지 확인하기. (new Car();)
	//	3. 'car' 변수 안에 무슨 인스턴스가 참조하고 있는지 확인하기.
	//	4. car 가 조상 클래스이면 FireEngine 클래스에서 새로 추가된 내용이 car에서
    // 없기 때문에 에러가 발생하는 것이다. 

		
	   // 테스트 3------------------------------
	   /* 
	    Car car = new Car();
		Car car2 = null;
		FireEngine fe = new FireEngine();

		car.drive();
   	    // fe = (FireEngine) car; 에러 발생
		fe.drive();
		car2 = fe;
		// car2.water; 에러 발생
		car2.drive(); 
		 */
		
	}
}
```

<br/><br/>

>**Reference**
><br/>남궁 성 지음, 『자바의 정석』, 도우출판.
