## 상관 서브쿼리 (EXISTS)

EXISTS를 사용하는 경우에는 서브쿼리가 반드시 스칼라 값을 반환할 필요가 없다.

```
단지, 반환된 행이 있는지를 확인해보고 같이 있으면 
`참`, 없으면 `거짓`을 반환하므로 어떤 패턴이라도 상관없다
```

<br/><br/>

## EXISTS

서브쿼리를 사용해 검색할 때 `데이터가 존재하는지 아닌지` 판별하기 위해 조건을 지정한다.

<br/>

### 테이블 2개 확인

```sql
select * from sample551;
```




| no | a |
| --- | --- |
| 1 | NULL |
| 2 | NULL |
| 3 | NULL |
| 4 | NULL |
| 5 | NULL |


<br/>

```sql
select * from sample552;
```

| no 2 |
| --- |
| 3 |
| 5 |


<br/><br/>

## 설명

sample551에는 1에서 5까지의 데이터가 저장되어 있다.

한편 sample552에는 3과 5가 저장되어 있다.

여기서 sample551의 a열은 문자열형이지만 값은 모두 null이다.

```
이 열을 update로 갱신하려고 하는 것이다
```

<br/>

### 그리하여, 

sample552에 no 열의 값과 같은 행이 있다면 "`있음`"이라는 값으로 갱신하도록 한다.


<br/><br/>

## 문제점

여기서 단순하게 no = 1처럼 지정하는 방식으로는 처리할 수 없다.

서브쿼리를 사용해 sample552에 행이 있는지부터 조사해야 한다.

그리고 "`있음`"인 경우, 행이 존재하는 경우에 대해 참으로 설정한다.


<br/><br/>

## EXISTS를 사용해 "있음"으로 갱신하기

```sql
update sample551 set a = '있음' where
   EXISTS (select * from sample552 where no2 = no);

select * from sample551;
```

| no | a |
| --- | --- |
| 1 | NULL |
| 2 | NULL |
| 3 | 있음 |
| 4 | NULL |
| 5 | 있음 |

이렇게 '있음' 으로 갱신되는걸 알 수 있다.

<br/>

서브쿼리의 `where` 구는 `no2 = no`라는 조건식으로 되어 있다. 

`no2`는 `sample552`의 열이고 `no`는 `sample551`의 열이다.

이때 `no`가 `3`과 `5`일때만 서브쿼리가 행을 반환 한다.


<br/><br/>

## NOT EXISTS

"`없음`"의 경우, 행이 존재하지 않는 상태가 `참`이 되므로 이때는 `NOT EXISTS`를 사용한다.

```sql
update sample551 set a = '없음' where
   NOT EXISTS (select * from sample552 where no2 = no);

select * from sample551;
```

| no | a |
| --- | --- |
| 1 | 없음 |
| 2 | 없음 |
| 3 | 있음 |
| 4 | 없음 |
| 5 | 있음 |


이 처럼, 서브쿼리를 이용해 다른 테이블의 상황을 판단하고 update로 갱신할 수 있다.

<br/><br/>

## 상관 서브쿼리란?

부모 명령에서는 sample551를 갱신한다.

자식인 서브쿼리에서는 sample552 테이블의 no2 열 값이 부모의 no 열 값과 일치하는 행을 검색한다.

이처럼, 부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 `상관 서브쿼리`라 부른다.

<br/><br/>

## 테이블명 붙이기

```
만약, 두열이 모두 같은 이름을 가진다면 어떨까?

'where no = no'라고 조건을 지정하면 제대로 동작할까?
```

결론은, 잘 동작하지 않는다. (에러 발생)


<br/>

### 그리하여 테이블 지정하는 방법

'sample551.no' 이런식으로 지정해주면 끝인 것이다.

```sql
update sample551 set a = '있음' where
  EXISTS (select * from smaple552 where sample552.no2 = sample551.no);
```

<br/><br/>

## IN

스칼라 값끼리 비교할 때는 = 연산자를 사용한다. -> 다만, 집합을 비교할 때는 사용할 수 없다.

서브쿼리를 사용할 때 IN을 통해 비교하는 경우도 많다.

<br/>


```
왼쪽에 지정된 값과 같은 값이 집합 안에 존재하면 '참'을 반환한다.
```


집합은 상수 리스트를 괄호로 묶어 기술한다.

<br/>

IN으로 지정한 값이 3과 5밖에 없어 OR로 기술 했을때와 별 차이가 없을수도 있다. 

하지만 값을 여러개 지정할 경우에는 조건식이 상당히 깔끔해진다.

```sql
select * from sample551 where no IN (3, 5);
```

| no | a |
| --- | --- |
| 3 | 있음 |
| 5 | 있음 |

<br/>


### 집합 부분은 서브쿼리도 지정할 수 있다.

```sql
select * from sample551 where no IN
   (select no2 from sample 522);
```

| no | a |
| --- | --- |
| 3 | 있음 |
| 5 | 있음 |