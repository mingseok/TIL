## 트랜잭션 - 개념 이해

<br/>

## 트랜잭션 사용법

데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 

- 커밋 명령어인 `commit` 을 호출하고, 결과를 반영하고 싶지 않으면
- 롤백 명령어인 `rollback` 을 호출하면 된다.

<br/><br/>

## 커밋을 호출하기 전까지는 `임시로 데이터를 저장`하는 것이다.

따라서 해당 트랜잭션을 시작한 세션(사용자) 에게만 변경 데이터가 보이고 

다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

- 등록, 수정, 삭제 모두 같은 원리로 동작한다.




<br/><br/>

## 아직 커밋은 하지 않은 상태이다.

![이미지](/programming/img/입문221.PNG)

새로운 데이터는 `임시 상태`로 저장된다.

세션1은 `select` 쿼리를 실행해서 본인이 입력한 `신규 회원1`, `신규 회원2`를 조회할 수 있다.

세션2는 select 쿼리를 실행해도 신규 회원들을 조회할 수 없다. 

```
이유는, 세션1이 아직 커밋을 하지 않았기 때문이다.
```



<br/><br/>

## 커밋하지 않은 데이터를 다른 곳에서 조회하면 어떤 문제가 발생할까?

```
세션2는 신규 회원1, 2가 보일 것이다. -> 즉, 어떠한 로직이든 수행할 수 있다.
```

만약, 로직을 수행하였는데, 세션1이 롤백을 수행하면 `신규 회원1`, `신규 회원2`의 

데이터가 사라지게 된다. 따라서 데이터 정합성에 큰 문제가 발생한다.



<br/><br/>

## commit

![이미지](/programming/img/입문222.PNG)

- `commit` 으로 새로운 데이터가 실제 데이터베이스에 반영된다.

이제 다른 세션에서도 회원 테이블을 조회하면 신규 회원들을 확인할 수 있다.

<br/><br/>

## rollback

![이미지](/programming/img/입문223.PNG)

- 세션1이 데이터베이스에 반영한 모든 데이터가 처음 상태로 복구 된다.
- 수정하거나 삭제한 데이터도 rollback 을 호출하면 모두 트랜잭션을 시작하기 직전의 상태로 복구된다.

<br/><br/>

## 트랜잭션 - 자동 커밋, 수동 커밋

자동 커밋 (디폴트가 true이다.)

- 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다.
    
    따라서, 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다.


<br/><br/>

## 자동으로 커밋하면 좋은거 아닌가?

예를 들어보자. 계좌이체를 생각해보면 두 가지 동작이 있다. 

```
1. 나의 돈 5000천원을 뺀다.
2. 상대방에 5000천원 넣는다.
```

“나의 돈 5000천원을 뺀다” 에서 바로 `자동 커밋`이 되어 버린다. 

그리고 “상대방에 5000천원 넣는다” 를 진행해야 되는데, 상대방이 카드를 없애 버린 것이다.

결과적으로 상대방에 5000천원은 들어가지 않고, 내 돈 5000천원만 빠져 나간 것이다.

<br/><br/>

## 정리

`원자성:` 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.

`트랜잭션의 원자성` 덕분에 여러 SQL 명령어를 마치 하나의 작업인 것 처럼 처리할 수 있었다.



성공하면 한번에 반영하고, 중간에 실패해도 마치 하나의 작업을 되돌리는 것 처럼 간단히 되돌릴 수 있다.

<br/>

`트랜잭션 시작:` 계좌이체 같은 종류의 작업은 꼭 수동 커밋 모드를 사용해서 수동으로 

커밋, 롤백 할 수 있도록 해야 한다. 보통 이렇게 자동 커밋 모드에서 → 수동 커밋 모드로 전환 하는 것을 `‘트랜잭션 시작'`이라고 표현한다.




<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

