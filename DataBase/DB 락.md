## DB 락

세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 

세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다..

```
트랜잭션의 원자성이 깨지는 것이다
```

<br/><br/>

## 문제 해결 방법.

세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지

다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.

![이미지](/programming/img/입문224.PNG)

데이터베이스는 이런 문제를 해결하기 위해 락(Lock)이라는 개념을 제공한다.

<br/><br/>

## 락을 먼저 획득하기.

![이미지](/programming/img/입문225.PNG)

1. 세션1은 트랜잭션을 시작한다.

2. 세션1은 memberA 의 money 를 500으로 변경을 시도한다
3. 세션1은 락을 획득했으므로 해당 로우에 `update sql`을 수행한다.

<br/><br/>

## 락이 돌아올 때 까지 대기

![이미지](/programming/img/입문226.PNG)

4. 세션2는 트랜잭션을 시작한다.

5. 세션1 락을 사용하고 있으므로 락이 돌아올 때 까지 대기한다.
6. 세션2가 락을 무한정 대기하는 것은 아니다.
    - 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생한다.

<br/><br/>

## 세션1 커밋 수행

![이미지](/programming/img/입문227.PNG)

7. 커밋으로 트랜잭션이 종료되었으므로 락도 반납한다.

    - 데이터들도 다 반영 된다.

<br/><br/>

## 대기하던 세션2 락 획득

![이미지](/programming/img/입문228.PNG)

8. 락을 획득하기 위해 대기하던 세션2가 락을 획득한다.

<br/><br/>

## 세션2 락 반납.

![이미지](/programming/img/입문229.PNG)

9. 세션2는 커밋을 수행하고 트랜잭션이 종료되었으므로 락을 반납한다

<br/><br/>

## DB 락 - 조회

데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 

```
이럴 때는 select for update 구문을 사용하면 된다.
```

이렇게 하면 세션1이 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 

해당 데이터를 변경할 수 없다. 물론 이 경우도 트랜잭션을 커밋하면 락을 반납한다.

<br/><br/>

## 조회 시점에 락이 필요한 경우는 언제일까?

트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.

예를 들어서, 오늘 하루 정산 마감을 12시에 한다고 생각해보자.

<br/>

이때, 마감을 진행하는데, 걸리는 시간은 30분정도의 시간이 걸린다. (계산 과정)

그런데, 마감중에 어떤 개발자가 업데이트를 하는 것이다.

여기서 문제가 발생하는 것이다.

<br/>

돈과 관련된 매우 중요한 계산이어서 계산을 완료할 때 까지 다른곳에서 변경하면 안된다.

그리하여 조회시에 락이 필요한 이유이다.

<br/>

## 만약, select for update 하려고 하는데, 락이 없다면? → 대기하게 된다.

![이미지](/programming/img/입문230.PNG)

### 목표는 조회시에도 락을 가져와서 동작한다는 것이다.


<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

