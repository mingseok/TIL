## DB 접근 테스트 방법 (Transactional)

<br/>

테스트를 진행 하면서 데이터를 이미 저장했다. 

그런데, 중간에 테스트가 실패해서 롤백을 호출하지 못해도 괜찮다. → `“이유는?”`

트랜잭션을 커밋하지 않았기 때문에 데이터베이스에 해당 데이터가 반영되지 않는다.

```
트랜잭션을 활용하면 테스트가 끝나고 나서 데이터를 깔끔하게 원래 상태로 되돌릴 수 있다.
```

<br/><br/>

## 동작 흐름

이렇게 해야, 다음 테스트에서 데이터로 인한 영향을 주지 않는다.

```
1. 트랜잭션 시작
2. 테스트 A 실행
3. 트랜잭션 롤백

4. 트랜잭션 시작
5. 테스트 B 실행
6. 트랜잭션 롤백
```

<br/><br/>

## @Transactional

스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고,

롤백 하는 방식을 `@Transactional` 애노테이션 하나로 깔끔하게 해결해준다.

<br/><br/>

## 사용 방법

클래스단에 `@Transactional` 애노테이션만 붙여 주면 끝이다.

- 만약, 해당 메서드만 적용하고 싶다면 클래스단 말고 해당 메서드에 붙여주면 된다.

```java
@Transactional
@SpringBootTest
class ItemRepositoryTest {

    @Autowired
    ItemRepository itemRepository;
    // .. 생략
}
```

<br/><br/>

## @Transactional 원리

스프링이 제공하는 `@Transactional` 애노테이션은 원래 성공적으로 로직이 동작하면 커밋 하도록 동작한다.

그런데 `@Transactional` 애노테이션을 테스트 단에서 사용하면 아주 특별하게 동작한다.

```
`@Transactional` 이 테스트 단에 있으면 스프링은 테스트를 
트랜잭션 안에서 실행하고, 테스트가 끝나면 트랜잭션을 자동으로 롤백시켜 버린다.
```

<br/><br/>

## findItems() 메서드 동작 흐름

![이미지](/programming/img/입문249.PNG)

1. 테스트에 `@Transactional` 애노테이션이 테스트 메서드나 클래스 단에 있으면 먼저 트랜잭션을 시작한다.
    
2. 테스트 로직을 실행한다. → 테스트가 끝날 때 까지 모든 로직은 트랜잭션 안에서 수행된다.
3. 테스트 실행 중에 `INSERT SQL`을 사용해서 item1 , item2 , item3 를 데이터베이스에 저장한다.
    
    테스트가 리포지토리를 호출하고, 리포지토리는 `JdbcTemplate`을 사용해서 데이터를 저장한다.
    
4. 검증을 위해서 `SELECT SQL`로 데이터를 조회한다. 
    
    (커밋을 하지 않았는데 `SELECT SQL`가 되는 이유는?, 
    
    `임시 데이터` 라고 해도, 나의 트랜잭션에 넣은 것이기 때문에 조회가 가능한 것이다.)
    
    `SELECT SQL`도 같은 트랜잭션을 사용하기 때문에 저장한 `데이터를 조회`할 수 있는 것이다. 
    
    다른 트랜잭션에서는 `해당 데이터를 확인할 수 없다.`
    
5. `@Transactional` 이 테스트에 있으면 테스트가 끝날때 트랜잭션을 `강제로 롤백`한다.
6. 롤백에 의해 앞서 데이터베이스에 저장한 item1 , item2 , item3 의 데이터가 `제거`된다.

<br/><br/>

## 위 내용을 정리하면

`@BeforeEach` 실행, SQL 실행, `@AfterEach` 실행 과정을 자동으로 해준다고 생각하면 된다.

- `데이터소스`랑, `트랜잭션 매니저`는 `스프링 부트`가 자동으로 등록을 해준다.

```
`@BeforeEach` : 각각의 테스트 케이스를 실행하기 직전에 호출된다.
`@AfterEach` : 각각의 테스트 케이스가 완료된 직후에 호출된다.
```

<br/><br/>

## 처음엔 다 지우기.

![이미지](/programming/img/입문250.PNG)

<br/><br/>

### 롤백이 되면서, 정상 동작이 되는걸 알 수 있다.

![이미지](/programming/img/입문251.PNG)

<br/><br/>

### DB에도 없는 것을 알 수 있다.

![이미지](/programming/img/입문252.PNG)

<br/>

### 이렇게 하여,

이제 DB 테스트도 반복해서 돌릴 수 있게 되는 것이다.

평소 테스트 코드 작성하고 검사하는 것처럼 말이다.

테스트를 실행하기 전에 먼저 테스트에 영향을 주지 않도록 testcase 데이터베이스에 접근해서 기존 데이터를 깔끔하게 삭제하자.

<br/><br/>

## `@Commit` 애노테이션

@Transactional 을 테스트에서 사용하면 테스트가 끝나면 바로 롤백되기 때문에 테스트 과정에서 저장한 모든 데이터가 사라진다.



당연히 이렇게 되어야 하지만, 정말 가끔은 데이터베이스에 데이터가 잘 보관되었는지 최종 결과를 눈으로 확인하고 싶을 때도 있다.

```
이럴 때는 @Commit 을 클래스 또는 메서드에 붙이면 테스트 종료 후 롤백 대신 커밋이 호출된다.
```

<br/>

### 사용 방법

```java
@Commit
@Test
void save() {
   // .. 생략
}
```

<br/>

### 출력

![이미지](/programming/img/입문253.PNG)

<br/><br/>

## 정리

- 테스트가 끝난 후 개발자가 직접 데이터를 삭제하지 않아도 되는 편리함을 제공한다.
- 테스트 실행 중에 데이터를 등록하고 중간에 테스트가 강제로 종료되어도 걱정이 없다.
    
    이 경우 트랜잭션을 커밋하지 않기 때문에, 데이터는 자동으로 롤백된다. 
    
- 트랜잭션 범위 안에서 테스트를 진행하기 때문에 동시에 다른 테스트가 진행되어도 서로 영향을 주지 않는 장점이 있다.
    
- `@Transactional` 덕분에 아주 편리하게 다음 원칙을 지킬 수 있게 되었다.
    - 테스트는 다른 테스트와 격리해야 한다.

    - 테스트는 반복해서 실행할 수 있어야 한다.


<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

