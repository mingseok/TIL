## 트랜잭션의 정의

## 궁금증

데이터를 저장할 때 단순히 `파일`에 저장해도 되는데, 

굳이 `데이터베이스`에 저장하는 이유는 무엇일까?

```
가장 대표적인 이유는 바로 데이터베이스는 트랜잭션이라는 개념을 지원하기 때문이다.
```

<br/><br/>

## 트랜잭션 : 이름 그대로 ‘거래’ 라는 뜻

데이터베이스에서 `트랜잭션`은 하나의 거래를 안전하게 처리하도록 `보장`해주는 것을 뜻한다. 

그런데 거래를 안전하게 고려해야 할 점이 많다. 

<br/>

### 예를 들어서

```
A의 5000원을 B에게 계좌이체 한다고 생각해보자. 
A의 잔고를 5000원 감소하고, B의 잔고를 5000원 증가해야 한다.
```

계좌이체라는 거래는 이렇게 2가지 작업이 합쳐져서 하나의 작업처럼 동작해야 한다. 

<br/>

만약 1번은 성공했는데 2번에서 시스템에 문제가 발생하면 계좌이체는 실패하고, 

A의 잔고만 5000원 감소하는 `심각한 문제`가 발생한다.

<br/>

데이터베이스가 제공하는 트랜잭션 기능을 사용하면 1,2 둘다 함께 성공해야 `저장`하고, 

중간에 하나라도 실패하면 거래 `전의 상태`로 돌아갈 수 있다. 

<br/>

만약 1번은 성공했는데 2번에서 시스템에 문제가 발생하면 계좌이체는 실패하고, 

거래 `전의 상태`로 완전히 돌아갈 수 있다. 결과적으로 A의 잔고가 `감소하지 않는다.` 

<br/>

모든 작업이 성공해서 데이터베이스에 `정상` 반영하는 것을 `커밋( Commit )`이라 하고, 

작업 중 하나라도 `실패`해서 거래 이전으로 되돌리는 것을 `롤백( Rollback )`이라 한다.

<br/><br/>

## 트랜잭션 ACID

- `원자성:` 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼

    - 모두 성공 하거나 모두 실패해야 한다.

- `일관성:` 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
    
    - 예를 들어, 데이터베이스 에서 정한 무결성 제약 조건을 항상 만족해야 한다.
    
- `격리성:` 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.

    - 예를 들어, 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 

    - 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준을 선택할 수 있다.

- `지속성:` 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
    
    - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 
    
    - 성공한 트랜잭션 내용을 복구해야 한다.
    

<br/><br/>

## 격리성의 문제점

트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다. 

이렇게 하면 동시 처리 성능이 매우 나빠진다. 

이런 문제로 인해 `ANSI` 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다

<br/><br/>

## 트랜잭션 격리 수준 - Isolation level

단계가 높아질수록 느려진다고 생각하면 되는 것이다.

- READ UNCOMMITED(커밋되지 않은 읽기)

- READ COMMITTED(커밋된 읽기) → `평균적으로 여기를 많이 사용한다.`
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 가능) → `제일 높은 단계.`

<br/><br/>

## 핵심

트랜잭션은 밑에 두개의 조건을 하나로 묶을 수 있을 것이 핵심이다

```
A의 잔고를 5000원 감소
B의 잔고를 5000원 증가
```

<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

