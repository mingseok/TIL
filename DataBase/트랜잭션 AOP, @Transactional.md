## 트랜잭션 AOP, @Transactional

<br/>

## 고민

서비스 계층에 `순수한 비즈니스 로직`만 남기고 싶을땐 어떻게 해야 될까?

이럴 때 `스프링 AOP`를 통해 `프록시`를 도입하면 문제를 깔끔하게 해결할 수 있다.

```
@Transactional 을 사용하면 스프링이 AOP를 사용해서 트랜잭션을 편리하게 처리해준다 
```

<br/><br/>

## 프록시 도입 전

![이미지](/programming/img/입문237.PNG)

<br/>

## 프록시 도입 후

![이미지](/programming/img/입문238.PNG)

서비스 로직을 그대로 두고, 트랜잭션 프록시 라는 것을 앞에 하나 만든다!

<br/><br/>

## 프록시란?

```
대신 무언가를 처리해주는 사람(?) 을 말한다.
```

위 그림으로 설명하자면, 클라이언트가 서비스를 직접 호출하는 것이 아니다. 

1. 클라이언트는 프록시를 호출하고

2. 프록시에서 `트랜잭션 시작`을 하고
3. 실제 서비스 로직을 호출해준다.

그리하여, 트랜잭션 종료까지 담당하게 되는 것이다.

<br/>

### 프록시는 스프링이 다 만들어 준다.

```
프록시를 사용하면 트랜잭션을 처리하는 객체와 
비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리할 수 있다.
```

<br/><br/>

## 트랜잭션 프록시 코드 예시

주석을 보면 하는 일들을 알 수 있다. → 이런 일들을 한다고 생각하기.

```java
public class TransactionProxy {
    private MemberService target;

    public void logic() {
        
        //트랜잭션 시작
        TransactionStatus status = transactionManager.getTransaction(..);
        
        try {
            //실제 대상 호출
            target.logic();
            transactionManager.commit(status); //성공시 커밋
        } catch (Exception e) {
            transactionManager.rollback(status); //실패시 롤백
            throw new IllegalStateException(e);
        }
    }
}
```


<br/><br/>

## 트랜잭션 프록시 적용 후 서비스 코드 예시

```java
public class Service {
	 public void logic() {
			 // 트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음
			 bizLogic(fromId, toId, money);
	 }
}
```

`프록시 도입 전:` 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다. (위 그림 참고)

`프록시 도입 후:` 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다.

<br/>

그리고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다. 

트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다.


<br/><br/>

## 스프링이 제공하는 트랜잭션 AOP

스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다.

스프링 부트를 사용하면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록한다.

<br/>

개발자는 트랜잭션 처리가 필요한 곳에 `@Transactional` 애노테이션만 붙여주면 된다. 

스프링의 `트랜잭션 AOP`는 이 애노테이션을 인식해서 `트랜잭션 프록시`를 적용해준다.

<br/>

### 자세히 뭔지는 모르겠지만,

```
"@Transactional 애노테이션을 사용하면 스프링이 프록시라는 것을 
(‘트랜잭션 프록시’ 맨 앞에 생기는 것) 만들어서 넣어주고 클라이언트를 
대신해 트랜잭션 처리를 한다" 라고 생각하기.
```


<br/><br/>

## @Transactional

스프링이 `@Transactional` 본다면 AOP 적용의 대상이라고 생각한다.

즉, 프록시 대상이라고 판단한다. (`EnhancerBySpringCGLIB..`) 라고 출력 된다.

(`CGLIB` 라이브러리를 통해서 프록시라는 것을 만들어 낸다.)

<br/>

`@Transactional` 애노테이션은 메서드에 붙여도 되고, 클래스에 붙여도 된다. 

클래스에 붙이면 외부에서 호출 가능한 `public` 메서드가 `AOP` 적용 대상이 된다.




<br/><br/>

## 사용 방법

```java
@Transactional
public void accountTransfer(String fromId, String toId, int money) throws SQLException {
		bizLogic(fromId, toId, money);
}
```

`설명:` @Transactional 애노테이션이 붙은 메서드가 실행 될 때, 트랜잭션 걸고 실행 하겠다는 것이다. 

메서드가 종료 될 시 성공하면 `커밋`을 진행하고, 런타임 에러 같은 예외가 발생한다면 → 즉, 실패하면 `롤백` 하는 것이다.


<br/><br/>

## 트랜잭션 AOP 정리

파란색 부분이 스프링이 처리해 주는 것이다. (`@Transactional` 만으로 가능)

![이미지](/programming/img/입문239.PNG)

<br/>

## 흐름 설명

1. 처음 클라이언트에서 `@Transactional` 라고 되어 있으면, 스프링이 

    “너는 트랜잭션을 적용하는 프록시를 만들어야 겠다”고 판단한다.
    
    즉, 1번 AOP 프록시를 호출하는 것이다.
    
2. AOP 프록시 내부 코드에서는 `‘트랜잭션 시작’`을 한다. 
    
    그런데 혼자는 것이 아니고 ‘트랜잭션 매니저'를 통해서 시작한다. 
    
    (프록시가 내부적으로 스프링 빈에 등록 되어 있는 ‘트랜잭션 매니저’를 찾아서 사용한다.)
    
3. 트랜잭션 매니저를 획득 한 다음에서야 `‘트랜잭션 매니저'` 를 시작한다.
4. 트랜잭션 매니저 에서는 `데이터 소스`로 → `커넥션`을 만든다.
5. 그리고 `setAotoCommit(false)` 로 하여 `수동모드`로 만드는 것이다.
6. 해당 커넥션을 동기화 해야 하는 것이다. → 트랜잭션 동기화 매니저에 `보관` 한다.
7. 그렇게 트랜잭션 시작을 하고 → AOP 프록시에서 `실제 서비스 로직`을 `호출`한다. 
    
    (비즈니스 로직을 말함) 그리고 서비스에서 → 리포지토리를 호출한다.
    
8. 그리고 리포지토리에서는 동기화 되어 있는 `트랜잭션 동기화 매니저`에서 `꺼내` 사용한다.
9. 리포지토리에서 작업이 끝난다면 → 서비스 → AOP 프록시로 돌아간다. 
10. 돌아간 다음 성공이면 `‘커밋’` 실패면 `‘롤백’` 을 진행한 다음 클라이언트로 반환이 되는 것이다.

<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

