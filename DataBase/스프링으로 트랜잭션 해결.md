## 스프링으로 트랜잭션 해결


<br/>


## 문제점.

JDBC 기술을 사용하다가 JPA 기술로 변경하게 되면 서비스 계층의 코드도 JPA 기술을 사용하도록 함께 수정해야 한다.

<br/>

## 해결 방법

스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다.

![이미지](/programming/img/입문232.PNG)

스프링 트랜잭션 추상화의 핵심은 `PlatformTransactionManager` 인터페이스이다.

→ `트랜잭션 매니저` 라고도 부른다.

<br/><br/>

## 트랜잭션 매니저와 트랜잭션 동기화 매니저

![이미지](/programming/img/입문233.PNG)

### 동작 방식을 설명

1. 트랜잭션을 `시작`하려면 커넥션이 필요하다. 

    - 트랜잭션 매니저는 `데이터 소스`를 통해 `커넥션`을 만들고 트랜잭션을 `시작`한다.

2. 트랜잭션 매니저는 트랜잭션이 시작된 `커넥션`을 트랜잭션 동기화 매니저에 `보관`한다.

3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 

4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.





<br/><br/>

## 흐름을 설명하면 이렇다.

![이미지](/programming/img/입문234.PNG)

클라이언트의 요청으로 서비스 로직을 실행한다.

1. 서비스 계층에서 `transactionManager.getTransaction()` 을 호출해서 트랜잭션을 시작한다.

2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 

    - 트랜잭션 매니저는 내부에서 `데이터 소스`를 사용해서 `커넥션`을 생성한다.

3. 커넥션을 `수동 커밋` 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.

4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.

5. 트랜잭션 동기화 매니저는 `쓰레드 로컬`에 커넥션을 보관한다. 

    - 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.


<br/><br/>


![이미지](/programming/img/입문235.PNG)

6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다.

    - 이때 커넥션을 파라미터로 전달하지 않는다.

7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다.

    - 리포지토리는 `DataSourceUtils.getConnection()` 을 사용해서 트랜잭션 동기화 매니저에
        
        보관된 커넥션을 꺼내서 사용한다. (미리 보관되어 있으니 가능한 얘기다)
        
8. 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.

    - 같은 커넥션이라는게 포인트이다.


<br/><br/>




![이미지](/programming/img/입문236.PNG)

9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다.

    - 트랜잭션은 `커밋하거나 롤백하면 종료된다.` → 마무리 작업을 뜻한다.

10. 트랜잭션을 종료하려면 동기화 된 커넥션이 필요하다. (`=락이라고 생각하기`)

    - 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.

11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.

12. 전체 리소스를 정리한다.

    - 트랜잭션 동기화 매니저를 정리한다.
    
    - 쓰레드 로컬은 사용 후 꼭 정리해야 한다.
    - con.setAutoCommit(true) 로 되돌린다. → `커넥션 풀을 고려해야 한다`
    - con.close() 를 호출해셔 커넥션을 종료한다.
    - 커넥션 풀을 사용하는 경우 con.close() 를 호출하면 커넥션 풀에 반환된다.



<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

