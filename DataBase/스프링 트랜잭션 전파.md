## 스프링 트랜잭션 전파

스프링은 `@Transactional` 이 적용되어 있으면 기본으로 `REQUIRED` 라는 전파 옵션을 사용한다.

이 옵션은 기존 트랜잭션이 없으면 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 기존 트랜잭션에 참여한다. 

```
‘참여한다'는 뜻은 해당 트랜잭션을 그대로 따른다는 뜻이고,
동시에 같은 동기화 커넥션을 사용한다는 뜻이다.
```

<br/><br/>

## 궁금증

트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 

여기에 추가로 트랜잭션을 수행하면 어떻게 될까?

1. 기존 트랜잭션과 별도의 트랜잭션을 진행해야 할까? 

2. 기존 트랜잭션을 그대로 이어 받아서 트랜잭션을 수행해야 할까?

```
이런 경우 어떻게 동작할지 결정하는 것을 '트랜잭션 전파'라 한다
```

<br/><br/>

## 외부 트랜잭션이 수행중인데, 내부 트랜잭션이 추가로 수행

![이미지](/programming/img/입문271.PNG)

- 외부 트랜잭션이 수행중이고, 아직 끝나지 않았는데, 내부 트랜잭션이 수행된다.

- 외부 트랜잭션이라고 이름 붙인 것은 둘 중 상대적으로 밖에 있기 때문에 외부 트랜잭션이라 한다.

    - 처음 시작된 트랜잭션으로 이해하면 된다.

- 내부 트랜잭션은 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것 처럼 보여서 내부 트랜잭션이라 한다.

<br/><br/>

![이미지](/programming/img/입문272.PNG)

스프링 이 경우 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어준다. 

내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다. 

```
이것이 스프링의 기본 동작이다. 
옵션을 통해 다른 동작방식도 선택할 수 있다.
```

<br/><br/>

## 물리 트랜잭션, 논리 트랜잭션

![이미지](/programming/img/입문273.PNG)

스프링은 이해를 돕기 위해 `논리 트랜잭션`과 `물리 트랜잭션`이라는 개념을 나눈다.

<br/>

### `논리 트랜잭션`들은 하나의 `물리 트랜잭션`으로 묶인다.

- `물리 트랜잭션`은 우리가 이해하는 실제 `데이터베이스`에 적용되는 트랜잭션을 뜻한다.
    
    실제 커넥션을 통해서 트랜잭션을 시작하고, 실제 커넥션을 통해서 커밋, 롤백하는 단위이다.

<br/>

### 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다.

- 이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을
    
    사용하는 경우에 나타난다. 단순히 트랜잭션이 하나인 경우 둘을 구분하지는 않는다.
    
    (더 정확히는 REQUIRED 전파 옵션을 사용하는 경우)
    

<br/><br/>

## 왜, 논리 트랜잭션과 물리 트랜잭션을 나누어 설명할까?

트랜잭션이 사용중일 때 또 다른 트랜잭션이 내부에 사용되면 여러가지 복잡한 상황이 발생한다. 

이때 `논리 트랜잭션` 개념을 도입하면 다음과 같은 단순한 원칙을 만들 수 있다.

```
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.
```

<br/><br/>

## 트랜잭션 전파가 실제 동작

![이미지](/programming/img/입문274.PNG)

<br/>

## 요청 흐름 - 외부 트랜잭션(순서)

1. `txManager.getTransaction()` 를 호출해서 외부 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 `데이터소스`를 통해 `커넥션`을 생성한다.
3. 생성한 커넥션을 `수동 커밋 모드(setAutoCommit(false))`로 설정한다. → 물리 트랜잭션 시작
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 `TransactionStatus` 에 담아서 반환하는데, 
    
    여기에 신규 트랜잭션의 여부가 담겨 있다. 
    
    `isNewTransaction` 를 통해 신규 트랜잭션 여부를 확인할 수 있다.
    
    트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.`(true)`
    
6. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 
    
    적용된 커넥션을 획득해서 사용한다. 
    

<br/><br/>

## 요청 흐름 - 내부 트랜잭션(순서)

1. `txManager.getTransaction()` 를 호출해서 내부 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다.
3. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다. 
    
    ```
    기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다.
    이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작했다. 
    
    그리고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두었다.
    따라서 이미 물리 트랜잭션이 진행중이므로 그냥 두면 이후 로직이 기존에 시작된
    트랜잭션을 자연스럽게 사용하게 되는 것이다.
    
    이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 된다.
    ```
    
4. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 
    
    여기에서 isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 
    
    여기서는 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아니다. ( false )
    
5. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 
    
    보관한 커넥션을 획득해서 사용한다
    

<br/><br/>

## 핵심 정리

- 여기서 핵심은 트랜잭션 매니저에 커밋을 호출한다고해서 항상 실제 커넥션에
    
    물리 커밋이 발생하지는 않는다는 점이다.
    
- 신규 트랜잭션인 경우에만 실제 커넥션을 사용해서 물리 커밋과 롤백을 수행한다.
    
    신규 트랜잭션이 아니면 실제 물리 커넥션을 사용하지 않는다.
    
- 이렇게 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저에 커밋하는 것이 항상
    
    물리 커밋으로 이어지지 않는다. 그래서 이 경우 논리 트랜잭션과 물리 트랜잭션을 나누게 된다.
    
    또는 외부 트랜잭션과 내부 트랜잭션으로 나누어 설명하기도 한다. 
    
- 트랜잭션이 내부에서 추가로 사용되면, 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고,
    
    모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋된다고 이해하면 된다.
    
<br/><br/>


## 외부 롤백

내부 트랜잭션은 커밋되는데, 외부 트랜잭션이 롤백되는 상황.

논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션은 롤백된다.

<br/>

따라서 이 경우 내부 트랜잭션이 커밋했어도, 

내부 트랜잭션 안에서 저장한 데이터도 모두 함께 롤백된다.

![이미지](/programming/img/입문275.PNG)

<br/><br/>

## 핵심

- 논리 트랜잭션이 하나라도 롤백되면 물리 트랜잭션은 롤백된다.
- 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시한다.
- 외부 트랜잭션을 커밋할 때 롤백 전용 마크를 확인한다.
    
    롤백 전용 마크가 표시되어 있으면 물리 트랜잭션을 롤백하고, UnexpectedRollbackException 예외를 던진다.


<br/><br/>

>**Reference** <br/>[스프링 DB 2편 - 데이터 접근 활용 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2/dashboard)

