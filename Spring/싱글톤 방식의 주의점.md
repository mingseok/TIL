## 싱글톤 방식의 주의점

싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 <br/>생성해서 공유 하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 <br/>싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

<br/>

### 무상태(stateless)로 설계해야 한다

- 특정 클라이언트에 의존적인 필드가 있으면 안된다.
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
- 가급적 읽기만 가능해야 한다
- 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

<br/>

## 실무에서 상당히 자주 발생하는 예시.

### 이렇게 작성하면 안되는것이다!!

(밑에 코드 2개를 같이 보기)

<br/>

### 두개의 고객이 요청이 들어 왔다고 가정하자.

1. 사용자A가 order를 호출을 했다. `“userA”`가 10000원을 주문 한 것이다.  
2. 그리고 사용자A가 주문한 금액을 꺼내고 싶은 것이다.
3. 그런데 !! 그 사이에 사용자B가 끼어 든 것이다. (주문하고, 금액을 꺼내는 그 사이)
4. 그러면 사용자A가 주문 금액을 조회 하면 얼마가 나올까??
5. **답은 20000원**
    
    ```java
    package hello.core.singleton;
    
    public class StatefulService {
    
    	//this를 통해 인스턴스 변수인데도 같은 레퍼런스에 저장되는 것이다.
        private int price; // 상태를 유지하는 필드
    
        public void order(String name, int price) {
            System.out.println("name = " + name + " price = " + price);
            this.price = price; // 여기가 문제!!!!
        }
    
        public int getPrice() {
            return price;
        }
    
    }
    ```
    

<br/>이유는? `statefulService1` 와 `statefulService2` 든 상관이 없다.

들어가면 같은 인스턴스를 사용하고 있기 때문이다. (== 으로 비교하면 true 가 나온다.)

```java
package hello.core.singleton;

public class StatefulServiceTest {

    @Test
    void statefulServiceSingleton() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);
        StatefulService statefulService1 = ac.getBean(StatefulService.class);
        StatefulService statefulService2 = ac.getBean(StatefulService.class);

        //ThreadA: A사용자 10000원 주문
        statefulService1.order("userA", 10000);
        //ThreadB: B사용자 20000원 주문
        statefulService2.order("userB", 20000);

        //ThreadA: 사용자A 주문 금액 조회
        int price = statefulService1.getPrice();
        System.out.println("price = " + price);

	// 결과를 보면, 같은 2만원이 나온다.
	// 이렇게 프로그램이 흘러가면 안되는 것이다.
        Assertions.assertThat(statefulService1.getPrice()).isEqualTo(20000);

    }

    static class TestConfig {

        @Bean
        public StatefulService statefulService() { // 이 코드 바로 위에 있다.
																					    // 참고 해서 보기.
            return new StatefulService();
        }
    }

}
```

<br/><br/>

## 그렇다면 위 예제를 올바르게 코드 구현 한다면?

### 사용자A가 10000원을 출력하고 싶게 코드 수정.

```java
package hello.core.singleton;

public class StatefulService {

    public void order(String name, int price) {
	return price;
    }
}

```

<br/>

`userAPrice`, `userBPrice` 를 int로 선언 하였다.

지역 변수(메서드안에 있는 변수)는 공유 되는게 아니니깐 출력 시키면 10000원이 나올 수 있다.

```java
package hello.core.singleton;

public class StatefulServiceTest {

    @Test
    void statefulServiceSingleton() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);
        StatefulService statefulService1 = ac.getBean(StatefulService.class);
        StatefulService statefulService2 = ac.getBean(StatefulService.class);

        //ThreadA: A사용자 10000원 주문
        int userAPrice = statefulService1.order("userA", 10000);
        //ThreadB: B사용자 20000원 주문
        int userBPrice = statefulService1.order("userB", 20000);

        System.out.println("price = " + userAPrice);
    }

    static class TestConfig {

        @Bean
        public StatefulService statefulService() {
            return new StatefulService();
        }
    }

}
```

<br/>

>**Reference** <br/>스프링 핵심 원리 - 기본편 : https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8
