## 스코프와 프록시

`MyLogger` 클래스에서 코드를 수정하자.

설명: `MyLogger` 클래스의 가짜를 만든다는 것이다.

이렇게 설정 해주기 위해선, value = “request” 가 들어가야 된다.

![이미지](/programming/img/스프링38.PNG)


<br/>
<br/>


sout 를 찍어보면 스프링이 조작한 애를 스프링 빈으로 등록 되어 있는 것이다.

![이미지](/programming/img/스프링39.PNG)

현재 `myLogger` 는 진짜 `myLogger` 가 아니다.

가짜 `myLogger` 인것이다.

<br/>

### 그럼 언제 실제 `myLogger` 객체를 사용 하는가??

`myLogger` 클래스의 실제 메서드 같은걸 사용할 때 실제 객체가 사용되는 것이다.

<br/>

## 설명.

여기가 핵심이다. 

`proxyMode = ScopedProxyMode.TARGET_CLASS` 를 추가해주자.

적용 대상이 인터페이스가 아닌 클래스면 `TARGET_CLASS` 를 선택

적용 대상이 인터페이스면 `INTERFACES` 를 선택

이렇게 하면 `MyLogger`의 가짜 프록시 클래스를 만들어두고 

`HTTP request`와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다

<br/><br/>

즉, 클라이언트A가 스프링 컨테이너로 들어와 밑에 처럼 uuid 가 있는 

```java
uuid = UUID.randomUUID().toString();
```

1. 처음부터 나갈때 까지 스코프가 생기고, 

2. MyLogger 프록시를 이용하여 요청마다 각각 따로 호출 되는 것이다. 
3. 그리고 프록시는 클라이언트 마다 각각 가짜를 준다. 
4. 그리하여 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 
5. 편리하게 request scope를 사용할 수 있다. (그냥 싱글톤 처럼 등록 된다고 생각하면 된다.)

<br/>

## request scope란? 

만약에 서비스를 만들었는데 장사가 너무 잘되는 것이다!
<br/>http 요청이 동시에 여러개가 온다 !! 
로그를 여러개 남길 것이다.
<br/>그런데, 그게 막 섞이는 것이다. <br/>즉, 뭔지 잘 구분하기가 힘든 것이다.그럴때 사용하기 좋은게 request scope 이다.
    
<br/>

- `@Scope` 의 `proxyMode = ScopedProxyMode.TARGET_CLASS)` 를 설정하면 스프링 컨테이너는
    
    `CGLIB`라는 바이트코드를 조작하는 라이브러리를 사용해서, `MyLogger`를 상속받은 
    
    가짜 프록시 객체를 생성한다
    
- 결과를 확인해보면 우리가 등록한 순수한 `MyLogger` 클래스가 아니라 `MyLogger$`
    
    `$EnhancerBySpringCGLIB` 이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다
    
- 그리고 스프링 컨테이너에 "`myLogger`"라는 이름으로 진짜 대신에 이 가짜 프록시
    
    객체를 등록한다.
    
- `ac.getBean("myLogger", MyLogger.class)` 로 조회해도 프록시 객체가 조회되는 
것을 확인할 수 있다.
- 그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다.

<br/>실제 사용하는 시점이 되면, 그때 실제 객체를 가져오는 것이다.


<br/><br/>

![이미지](/programming/img/스프링40.PNG)

## 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.

- 가짜 프록시 객체는 내부에 진짜 myLogger를 찾는 방법을 알고 있다.

- 클라이언트가 myLogger.logic() 을 호출하면 사실은 가짜 프록시 객체의 메서드를 
호출한 것이다.
- 가짜 프록시 객체는 request 스코프의 진짜 myLogger.logic() 를 호출한다.
- 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 
클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다(다형성)

<br/>(어떤 url로 들어 왔는데, 각 메서드마다 몇초씩 걸렸어? 할때 싶을때 스코프 프록시 개념이 필요한것이다.)

<br/>

### 특징 정리

- 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 
request scope를 사용할 수 있다.

- 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를
 꼭 필요한 시점까지 지연처리 한다는 점이다.
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 
이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
- 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다

<br/>


>**Reference** <br/>스프링 핵심 원리 - 기본편 : https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8
