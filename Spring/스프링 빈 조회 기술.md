## 스프링 빈 조회 기본 1/3

```java
package hello.core.beanfind;

public class ApplicationContextBasicFindTest {

    AnnotationConfigApplicationContext ac
            = new AnnotationConfigApplicationContext(AppConfig.class);


    @Test
    @DisplayName("빈 이름으로 조회")
    void findBeanByName() {
        MemberService memberService = ac.getBean("memberService", MemberService.class);
        System.out.println("memberService = " + memberService); // 빈에서 꺼내서 가져 온것이다. 임포이다.
        

        // 빈의 클래스 이름을 가져 온것이다.
        System.out.println("memberService.getClass() = " + memberService.getClass()); 
        

        // memberService가 MemberServiceImpl의 인스턴스면 성공 하는 것이다.
        Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }


    // 이렇게도 가능하다.!!!!!!!!
    @Test
    @DisplayName("이름 없이 타입으로만 조회")
    void findBeanByType() {
        MemberService memberService = ac.getBean(MemberService.class);
        Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }


    // 이건 좋은 방법의 코드가 아니다.
    // 하지만 이런 방법도 된다는걸 알고 있기.
    @Test
    @DisplayName("구현체 타입으로 조회")
    void findBeanByName2() {
        MemberServiceImpl memberService = ac.getBean("memberService", MemberServiceImpl.class);

        Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
    }


    // 안될때 검사하는 코스
    @Test
    @DisplayName("빈 이름으로 조회")
    void findBeanByNameX() {
        //즉, xxxx 라는 이런 빈을 등록한 적이 없는데 사용하였기 때문이다.

        // 밑에 람다식 안으로 넣었다. ac.getBean("xxxx", MemberService.class);
        //MemberService xxxx = ac.getBean("xxxx", MemberService.class);

        //import static org.junit.jupiter.api.Assertions.*; 이걸 해줘야 한다.

        //이 예외가 터져야(된다) 제대로 된 코드를 작성 한것이다. == 테스트 성공이다
        //람다식 58번째 코드를 실행하면 57번째 에러가 터져야 된다는 뜻이다. 그래야 테스트 코드 성공이다.
        assertThrows(NoSuchBeanDefinitionException.class,
                () -> ac.getBean("xxxx", MemberService.class));

    }
}
```

<br/><br/>

## 스프링 빈 조회 - 동일한 타입이 둘 이상 2/3

```java
AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);
```

이렇게 실행 시킬 경우

`SameBeanConfig` 안에 있는 빈들만 등록 시킨다는 뜻이 된다.

어떻게? `@Configuration` 가 달려있는 `SameBeanConfig` 클래스를 **찾아서 스프링이 빈에 있는 걸 등록을 한다.**

<br/>


### 그런데 문제가 발생한다.

이렇게 조회를 하면 스프링 입장에서는 둘 중에 뭘 써야 할지 모른다.

이유는. MemberRepository.class 인 타입으로 조회 했기 때문이다.

```java
@Test
@DisplayName("타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.")
void findByTypeDuplicate() {

    assertThrows(NoUniqueBeanDefinitionException.class,
                     () -> ac.getBean(MemberRepository.class));
}

@Configuration
static class SameBeanConfig {
	
	
    @Bean
    public MemberRepository memberRepository1() {
	return new MemoryMemberRepository();
    }


    @Bean
    public MemberRepository memberRepository2() {
	return new MemoryMemberRepository();
    }
}
```

<br/><br/>각각 단위 테스트로 실행 시켜보면서 어떻게 동작하는지 확인해보자.

```java
package hello.core.beanfind;

public class ApplicationContextSameBeanFindTest {

    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);

    @Test
    @DisplayName("타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.")
    void findByTypeDuplicate() {

        // 이 로직은 예외를 터지게 만드는 것이 성공 로직인 것이다.
        assertThrows(NoUniqueBeanDefinitionException.class,
                () -> ac.getBean(MemberRepository.class));
    }


    @Test
    @DisplayName("타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.")
    void findBeanByName() {
        MemberRepository memberRepository = ac.getBean("memberRepository1", MemberRepository.class);
        assertThat(memberRepository).isInstanceOf(MemberRepository.class);
    }


    @Test
    @DisplayName("특정 타입을 모두 조회하기")
    void findAllBeanByType() {
        Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);

        for (String key : beansOfType.keySet()) {
            System.out.println("key = " + key + " value = " + beansOfType.get(key));
        }

        System.out.println("beansOfType = " + beansOfType);

        //검증
        //두개가 나와야 한다. 이유는? 빈이 두개 이기 때문
        assertThat(beansOfType.size()).isEqualTo(2);
    }


    @Configuration
    static class SameBeanConfig {


        @Bean
        public MemberRepository memberRepository1() {
            return new MemoryMemberRepository();
        }


        @Bean
        public MemberRepository memberRepository2() {
            return new MemoryMemberRepository();
        }
    }
}
```

<br/><br/>

## 스프링 빈 조회 - 상속 관계

### 부모 타입으로 조회를 하면 그 자식 ‘빈’ 들은 다 나오게 되는 것이다.

밑에 사진의 예를 들어, 3번으로 조회 하면 자식들 까지 3, 6, 7 이 조회 되는 것이다.

![이미지](/programming/img/스프링11.PNG)


<br/>

`ApplicationContextExtendsFindTest` 테스트 코드

단위 별로 실행시켜보며, 이해하기.

```java
package hello.core.beanfind;

public class ApplicationContextExtendsFindTest {

    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);

    @Test
    @DisplayName("부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다.")
    void findBeanByParentTypeDuplicate() {

        // 부모타입으로 조회해서 자식 인스턴스 두개가 다 걸리는 것이다.
        assertThrows(NoUniqueBeanDefinitionException.class,
                () -> ac.getBean(DiscountPolicy.class));
    }
    

    @Test
    @DisplayName("부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정하면 된다.")
    void findBeanByParentTypeBeanName() {

        // 이렇게 하면 해당 빈이 나온다.
        DiscountPolicy rateDiscountPolicy = ac.getBean("rateDiscountPolicy", DiscountPolicy.class);

        assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);
    }
    

    @Test
    @DisplayName("특정 하위 타입으로 조회")
    void findBeanBySubType() {
        RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class);
        assertThat(bean).isInstanceOf(RateDiscountPolicy.class);
    }


    @Test
    @DisplayName("부모 타입으로 모두 조회하기")
    void findAllBeanByParentType() {
        Map<String, DiscountPolicy> beansOfType = ac.getBeansOfType(DiscountPolicy.class);

        assertThat(beansOfType.size()).isEqualTo(2);

        for (String key : beansOfType.keySet()) {
            System.out.println("key = " + key + " value = " + beansOfType.get(key));
        }
    }


    @Test
    @DisplayName("부모 타입으로 모두 조회하기 - Object")
    void findAllBeanByObjectType() {
        //이렇게 하면 스프링 내부적으로 사용하는 것까지 모두 나오게 된것이다.
        Map<String, Object> beansOfType = ac.getBeansOfType(Object.class);
        for (String key : beansOfType.keySet()) {
            System.out.println("key = " + key + " value = " + beansOfType.get(key));
        }
    }
    

    @Configuration
    static class TestConfig {


        @Bean
        public DiscountPolicy rateDiscountPolicy() {
            return new RateDiscountPolicy();
        }


        @Bean
        public DiscountPolicy fixDiscountPolicy() {
            return new FixDiscountPolicy();
        }
    }

}
```

<br/>


>**Reference** <br/>스프링 핵심 원리 - 기본편 : https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8
