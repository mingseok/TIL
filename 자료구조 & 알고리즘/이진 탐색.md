## 이진 탐색 == binary search

이분탐색 이진탐색 이원탐색 다 같은 말이다.

<br/>

## 바이너리 서치는 알고리즘이다.

binary : 숫자 2를 말한다. 

search : 는 검색을 말한다.


### Binary Search는 절반씩 숫자를 날려 버리면서 숫자를 찾는 알고리즘 이란 것이다.

<br/>


## 자료 하나하나 다 보려는 시간 복잡도는?

![이미지](/programming/img/이진탐색1.PNG)


<br/>


## binary search를 사용 할때의 조건은?

![이미지](/programming/img/이진탐색2.PNG)

<br/>

## binary search를 시작 !! 한다면 !!

1. 중간값은 선택한다.
2. 중간값이랑 내가 찾고자 하는 값이랑 비교를 한다
3. 그런데 내가 찾고자 하는 값보다 중간값이 작다 !!
4. 즉, 7보다 크다는 말이니, 오른쪽만 찾으면 되는 것이다.
5. 즉, 왼쪽은 다 버려 버리고 오른쪽만 보면 되는 것이다.
    
    ![이미지](/programming/img/이진탐색3.PNG)
    

1. 그 다음 또 오른쪽 부분에서의 중간값을 선택 한다.
2. 일단 다르다는 걸 확인 하고, 또 내가 찾고 싶은 숫자가 중간값 보다
3. 더 크다는 것을 알 수 있다.
4. 그러면 11 보다 작은 왼쪽 숫자들은 또 버리는 것이다.

![이미지](/programming/img/이진탐색4.PNG)

10. 그 다음 또 중간 값을 찾으면 14가 있다는 것을 알 수 있다.
11. 그러면 내가 찾고자 하는 숫자가 14니깐 “아!! 찾았다” 할 수 있는 것이다.

![이미지](/programming/img/이진탐색5.PNG)

<br/><br/>

## 또 다른 예제로 숫자 5로 해보자.

1. 중간값 7보다 내가 찾는 숫자가 작다.
2. 그렇다면 왼쪽에 있는 것이다.

![이미지](/programming/img/이진탐색6.PNG)

3. 오른쪽 값들은 다 날리고 다시 왼쪽 부분 에서의 중간값을 잡는다.
4. 이번엔 중간값이 내가 찾는 숫자보다 작다.

![이미지](/programming/img/이진탐색7.PNG)

5. 그렇다면 중간값부터 왼쪽에 있는 것들을 날릴 수 있는 것이다.

![이미지](/programming/img/이진탐색8.PNG)

6. 그러고 다시 중간 값을 잡아 4 자리를 잡아보고 값이 아닌 걸 알고,
7. 현재 자리인 나를 날리면 되는 것이다.

![이미지](/programming/img/이진탐색9.PNG)

8. 마지막으로 잡아 보니깐 5가 있는 것을 확인 할 수 있다.

![이미지](/programming/img/이진탐색10.PNG)

<br/><br/>

## 만약 없는 숫자를 찾으려고 한다면?

1. 

![이미지](/programming/img/이진탐색11.PNG)

2. 

![이미지](/programming/img/이진탐색12.PNG)

3. 

![이미지](/programming/img/이진탐색13.PNG)

4. 

![이미지](/programming/img/이진탐색14.PNG)

5. 여기서 9를 보면 나를 날려야 되는 것이다. 엇???? 
그런데 전부 날리게 된 것이다. 
6. 따라서 10은 없다고 말할 수 있는 것이다.
7. 이렇게 모든 원소를 날려 버리게 되면 찾고자 하는 숫자가 없다. 라고 말할 수 있는 것이다.

![이미지](/programming/img/이진탐색15.PNG)



<br/><br/>

## Binary Search의 시간복잡도

이렇게 절반씩 지워 나가는 것이다.

총 숫자 200개 중에서 내가 원하는 숫자를 몇번 만에 찾을 수 있는가?

<br/>

### 8번만에 찾을 수 있는 것이다 !!

![이미지](/programming/img/이진탐색17.PNG)

<br/>

## 그러면 시간복잡도는 → O(log n) 이다

(log n) 에 뜻은 → “2를 몇번이나 곱해야 n이 되겠느냐” 하는 것이다.

똑같은 말로 얘기하면 “n을 몇번이나 2로 나눠야 1이 되겠느냐” 하는 거랑 똑같은 것이다.

<br/>

이렇게 숫자를 절반씩 지워가며 찾기 때문에 n개가 있다면, n이란 숫자를 2로 몇번이나 나눠야 1이 되겠느냐 라는 말이며, <br/>그말을 즉, O(log n) 번이라고 말한다.

<br/>

## 따라서 “log n 번만 비교를 하면 숫자를 찾을 수 있다” 라고 말할 수 있는 것이다.

### 바이너리 서치의 장단점

![이미지](/programming/img/이진탐색16.PNG)

<br/>

## 정리 :

바이너리 서치는 이미 정렬이 되어 있거나, 숫자 찾기를 지나치게 많이 해야 될 경우에는 바이너리 서치를 사용하는 것이 이득인 것이다.



<br/><br/>

## binary search의 재귀함수 디자인

## 꼭 따라하기, 시키는건 그냥 좀 따라하자.

- 재귀호출을 이용한 구현
- 재귀호출을 이용하지 않는 구현

![이미지](/programming/img/이진탐색18.PNG)

<br/>

### 바이너리 서치는 찾는 숫자의 위치를 반환 해주는 것이다.

경우에 따라 다르지만 대충 이렇다.

<br/>

## 첫번째 부터 시작해보자!

### 1번 작성하려는 함수의 역할을 말로 명확하게 정의한다.

arr[] 배열에 s번째 값부터 e번째 값까지 중에서 벨류를 찾는 함수이다.

찾았다면, 위치를 반환 하는 것이고, 못 찾았으면 -1 을 반환하는 것이다.

<br/>

(참고 : 바이너리 서치를 할거니깐 정렬이 되어 있다고 가정은 해야 한다.)

![이미지](/programming/img/이진탐색19.PNG)

<br/>

### 풀이 하자면

![이미지](/programming/img/이진탐색20.PNG)

```java
BS(arr, 1, 5, 8); -> 반환 하는 것은 ? 4를 하게 되는 것이다.

(arr)배열 안에 인덱스 (1)부터 (5)까지 인덱스값이 아닌,
데이터값 (8)을 찾아라 하는 것이다.

만약 찾는 값이 9이면 없으니 -> -1 를 반환 하게 되는 것이다.
```

<br/>

### 2번. 함수가 기저조건에서 제대로 동작하게 작성한다.

즉, 가장 단순한 경우를 말한다. 

바이너리 서치 에서 가장 단순한 경우는 

- 내가 찾고자 하는 숫자가 없을 경우이다. → -1 반환 해준다.
- 숫자가 하나 밖에 없다면 이다. → 이땐 어떻게 하나? → 
하나 있는거 비교해 보면 되는 것이다. <br/>
그리하여 맞으면 s변수 반환, 아니면 -1 반환 하는 것이다.
- 코드로 다시 설명한다.

```java
int binarySearch(int arr[], int s, int e, int value) {

if(s > e) {
	return -1;

} else if(s == e) {

        if(value == arr[s]) { // 위에 설명에 숫자가 하나 밖에 없다면 s(스타트) 랑 e(end) 가
			      // 똑같다는 이야기 라서 return s 를 반환 한는 것이다.
				      
	    return s; // 있으면 위치를 반환 하는 것이다.

        } else {
	
	    return -1; // 없으면 -1
	}
}
```

<br/>

### 만약 위에 과정도 아니라면, 숫자가 여러개 있다는 뜻이고, 그땐 어떻게 숫자를 찾을 거냐? 할때 3번이 적용 되는 것이다.



### 3번. 함수가 제대로 동작한다고 가정하고 함수를 완성한다.

<br/>

이제 바이너리 서치의 원리가 들어가는 것이다.

즉, value 를 정하고 중간값을 정해서 왼쪽 날리거나, 오른쪽 날리는 코드를 짜면 되는 것이다.

<br/>

(주석 잘보기)

```java
int mid = (s + e) / 2; // 이렇게 하면 s 와 e 의 중간 지점을 찾게 되는 것이다.

if(arr[mid] == value) { // 만약에 arr[mid]가 즉, 중간값이 value랑 똑같다면 찾은 것이다.
		        // "아, mid 에 있구나" 라고 생각하고 mid 를 반환 하면 된다.
	return mid;

} else if(arr[mid] > value) { // 만약 찾지 못했다면, arr[mid] 보다 value가 더 작다.
							                   
                                               
                                                    
	return binarySearch(arr, s, mid-1, value); // s부터 mid-1 까지를 다시 찾게 하는 것이다.          
						   // 왜 mid-1 인가? 이유는 mid를 포함하여 값이
	                                           // 없었기 때문이다.
		                                   

} else {

	return binarySearch(arr, mid+1, e, value); // 왼쪽도 아니라면, mid+1 한 인덱스 부터 
						   // 오른쪽 끝까지 다시 검사하게 하는 것이다.
```

<br/>

### 4번. 함수를 완성한 후, 기저조건으로 수렴함을 보인다

YES 라고 할 수 있다.

전체가 있었으면 절반 쪼개고, 또 절반 쪼개고 또 절반 쪼개고 … 구간이 계속해서 줄어드니깐

결국은 1개가 되거나, 0개가 되는 것이다 !!

결국엔 끝나게 되고 따라서 내가 만든 함수가 잘 동작 한다는 것을 알 수 있다.
