## 동적계획법의 예제: 숫자 만들기 3 구현

```java
import java.util.Scanner;

// 숫자 만들기
// N      1 2 3 ... M

// 1. Table을 어떻게 정의 했는지
// 2. 점화식을 어떻게 세웠는지

// T(i) = 1 ~ M 까지의 숫자를 이용해서 숫자 i를 만드는 경우의 수
// T(i) = T(i-1) + T(i-2) + ... + T(i-M)

public class aaa {

  static int MAX = 100;
  static int[] Table = new int[MAX];
  static int n, m;
  

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int m = sc.nextInt();

    // -----------------------------------------------------------------

    // 예제 ex1)
    // M = 3
    // Table[1] = ?
    // Table[2] = ?
    // Table[3] = ?
    // Table[4] = Table[1] + Table[2] + Table[3]
    // 즉, 말하고 싶은 것은 Table[1, 2, 3] 은 점화식으로 구하지 못한다는 것이다.

    // -----------------------------------------------------------------

    // 예제 ex2)
    // M = 4
    // Table[1] = ?
    // Table[2] = ?
    // Table[3] = ?
    // Table[4] = ?
    // Table[5] = Table[1] + Table[2] + Table[3] + Table[4]
    // 즉, M = 4라면 4다음인 Table[5]부터 점화식으로 구할 수 있다는 말이다.

    // -----------------------------------------------------------------

    // 제데로 문제 풀이를 해보자면
    // M = 4
    // Table[1] = 1

    // Table[2] = Table[1] + 1 하여 2가 나오게 되는 것이다.

    // Table[3] = 3인 같은 경우는 맨 끝이 1, 2, 3 인 경우로 나눌 수 있는것이다.
    //            즉, 1인 경우는 -> 숫자 2를 만들면 되는 것이다.
    //                2인 경우는 -> 숫자 1를 만들면 되는 것이다.
    //                3인 경우는 -> 만들면 안된다.
    //            그리하여 Table[2] + Table[1] + 1 이 되는 것이다.
    //            (위 마지막 1인 이유는 그냥 '3' 하나만 카운트 하면 되기 때문이다)

    // Table[4] = 4같은 경우에도 맨 끝이 1, 2, 3, 4 가 되는 것이다.  
    //            즉, '1' 로 끝나는 경우는 3을 만들어줘야 한다.
    //                '2' 로 끝나는 경우는 2를 만들어줘야 한다.
    //                '3' 로 끝나는 경우는 1를 만들어줘야 한다.
    //                '4' 로 끝나는 경우는 만들면 안된다.
    //            그리하여 Table[3] + Table[2] + Table[1] + 1 이 되는 것이다.

    // Table[5] 부터는 앞에 4개 더하면 되는 것이니 상관이 없다.
    // Table[5] = Table[1] + Table[2] + Table[3] + Table[4]

    // 정리 해보자면 !!
    // M = 4
    // Table[1] = 1
    // Table[2] = Table[1] + 1
    // Table[3] = Table[2] + Table[1] + 1
    // Table[4] = Table[3] + Table[2] + Table[1] + 1

    // Table[5] = Table[1] + Table[2] + Table[3] + Table[4]

    // -----------------------------------------------------------------

    // 1 ~ M

    Table[1] = 1;
    int sum = 0;

    for(int i = 2; i <= m; i++) {
        // Table[i] = Table[1] + Table[2] + ... + Table[i-1] + 1
        // 이렇게 하면 이중 for문 없이 테이블을 채울 수 있는 것이다.

        sum += Table[i-1];
        Table[i] = sum + 1; // Table[1,2,3 ..] + 1 이렇게 끝나야 하기 때문.

        // 설명하자면, 
        // 1. i가 2일때 -> sum에는 테이블 1이 들어갈 것이고,
        // 2. 그리하여 sum + 1 한다면 테이블 2에는 -> 2가 들어갈 것이다.
        // 3. 다시 루프가 돌아서 sum 에는 테이블 2를 추가적으로 넣는다.
        // 4. 즉, sum에 테이블 1, 테이블 2 가 들어가 있어 3이 들어 있는 상황이다.
        // 5. 그러고 한줄 내려와 3 + 1 하여 4가 되는 것이다.
        // 6. 이런식으로 루프를 돌면서 합을 구하게 되는 것이다.

      // 여기까지가 기저조건이다.
    }

    
    for(int i = m+1; i <= n; i++) {
      for(int j = i-m; j <= i-1; j++) {
        // Table[1] + Table[2] + Table[3] + Table[4] 다 더하면 Table[5] 가 나오는 것이다.
        Table[i] += Table[j];
      }

      //여기까지가 그 이후의 넣는 것이다.
      //예를 들어, Table[5] = Table[1] + Table[2] + Table[3] + Table[4]
    }
    
    System.out.print(Table[n]);
    
  }
}
```

입력 : 4 3

출력 : 7