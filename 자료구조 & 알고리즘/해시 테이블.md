## 해시 테이블 소개

해시 테이블 이라는 자료 구조를 포함하며, 해시 테이블에는 빠른 읽기라는 놀랍고 엄청난 능력이 있다. <br/>해시 테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다. → 해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등의 이름을 갖는다.

<br/>

### [해시 테이블 코드 보러가기]()

<br/>

### 해시 테이블 이란?

검색 하고자 하는 key 값을 입력 받아서 해시 함수를 돌려서 반한 받은 해쉬 코드를 <br/>배열의 인덱스로 환산을 해서 데이터에 접근하는 방식의 자료구조 이다.

<br/>

### 예시를 들어보자.

어떤 사람이 만약에 내 채널에 있는 동영상을 다운 받아서 그 사람 채널에 그대로 올리면 에러 메세지가 발생하면서 <br/>“이 동영상은 중복되는 동영상 입니다!” 라고 뜨는걸 알 수 있다. 이것이 바로 ‘해시 테이블’이다.

<br/>

여기서 사용하는 key 값은 문자열이 될 수도 있고, 숫자나 파일 데이터가 될 수도 있다. 

<br/>

해시 함수는 어떤 특정한 규칙을 이용해서 입력받은 key 값으로 그 key 값이 얼마나 큰지 상관없이 <br/>동일한 해시 코드를 만들어 준다. → 암호 화폐의 핵심기술인 블록 체인에서도 각 사용자들의 공공장부를 비교 할때 해시코드를 이용한다. 

<br/>

### 블록 체인이란?

블록 체인은 10분 간격으로 성사된 거래 기록을 블록 체인 **창고**에 저장하고 지금까지 일어난 모든 거래 기록을 <br/>그 서비스를 이용하는 모든 사용자들이 전자 지갑에 갖고 있게 하는 방식이다

<br/>

해시 코드를 만드는 함수는 입력 데이터에 ‘. 하나’ ‘공백 하나’ 라도 틀리면 전혀 다른 해시 코드를 생성 한다. <br/>그러므로 입력 데이터가 완벽하게 일치 해야만 동일한 해시 코드를 만들어 내기 때문에 거래내역이 조금이라도 <br/>다르면 전혀 다른 해시 코드를 만들어 내는 것이다. → 이렇게 모든 사람들이 거래내역을 비교할 수 있게 지갑안에 <br/>해시 코드를 가지고 있기 때문에 누구 한 사람이 거래 내역을 조작해서 이득을 보려고 했다가는 혼자 다르니깐 바로 걸리는 것이다.

<br/>

해시 테이블의 가장 큰 장점은 검색 속도가 매우 빠르다는 것이다. <br/>왜 빠르냐면 → 해시 함수를 이용해서 만든 해시 코드는 정수이다. 배열 공간을 고정된 크기 만큼 <br/>미리 만들어 놓고 **해시 코드를 배열에 개수로 나머지 연산을 해서 배열에 나눠 담는 것이다.** → <br/>그말은 해시 **코드 자체**가 배열 방의 인덱스 값으로 사용되기 때문에 검색 자체를 할 필요가 없고, <br/>해시 코드로 바로 데이터의 위치에 다이렉트로 접근 할 수 있으니깐 빠른 것이다.

<br/>

해시 테이블은 쌍으로 이뤄진 값들의 리스트다. 

첫 번째 항목을 키라 부르고, 두 번째 항목을 값이라 부른다.

예를 들어, 비밀 코드를 만들고 해독해 본다고 생각해 보자.

이런 식으로 되어 있다. 

```java
A = 1
B = 2
C = 3
D = 4
E = 5
```

**문자를 가져와 숫자로 변환하는 이러한 과정을 해싱이라고 부른다.**

**또한, 글자를 특정 숫자로 변환하는 데 사용한 코드를 해시 함수라 부른다.**

또 다른 해시 함수 예제는 각 문자에 해당하는 숫자를 가져와 모든 수를 합쳐 반환하는 것이다.

이렇게 하면 BAD는 다음과 같은 두 단계의 과정을 거쳐 숫자 7이 된다.

2 + 1 + 4 = 7

<br/>또 다른 해시 함수 예제는 문자에 해당하는 모든 수를 곱해서 반환하는 것이다.

이렇게 하면 단어 BAD는 숫자 8로 변환 된다.

1단계 : 먼저 BAD를 214로 변환한다.

2단계 : 각 숫자를 가져와 곱한다.

2 * 1 * 4 = 8

<br/><br/>

## 해시 테이블도 문제가 있다.

방들 여러개 만들어 놓고 손님을 기다리는데 주인이 손님을 이름별로 빨리 찾고 싶어서 ‘성’ 으로 구분 했다. <br/>0번방 김씨, 1번방 이씨, 2번방 박씨 등등 .. 그런데 문제는 계속 김씨만 들어오는 것이다. 0번방만 계속 차고 있고, <br/>1번, 2번, 등등은 비어 있는 것이다. 즉, 이것은 공간 효율이 떨어지는 것이다. → 그리 하여 <br/>방을 나눌때 규칙을 잘 만드는 것이 매우 중요한데 그것을 ‘해시 함수의 알고리즘’ 이라고 부른다. <br/>알고리즘이 좋지 않을때 한방에 여러개의 데이터가 들어 가야 되니깐 충돌 현상이 발생 하는 것이다. 

<br/>

해시 테이블의 최강 장점은 검색 시간이 O(1) 만큼 걸린다는 것이다. <br/>그런데 충돌 현상이 많을 경우에는 최대 검색 시간이 O(n) 까지 걸릴 수가 있다. → <br/>‘김민석’ 을 찾으려면 그 방안에서 손님을 찾아야 되니깐 일일이 한사람씩 검색을 해야 되는 것이다. 

<br/>

그리하여 해쉬 함수의 알고리즘은 입력받은 키를 가지고 얼마나 골고루 잘 분배를 하느냐에 좋은 알고리즘 인지가 결정이 된다. 

<br/>

해시 함수는 때로는 ‘서로 다른 키 값으로 동일한 해시 코드를 만들어 내기도 한다.’ <br/>key 값은 문자열이고 그 나무가지 수가 무한한데 해시 코드는 정수 개념뿐이라 <br/>알고리즘이 아무리 좋아도 어떤 키들은 중복되는 해시 코드를 가질 수밖에 없는 것이다. <br/>그리고 때로는 해시 알고리즘이 서로 다른 해시 코드를 만들어 냈는데 배열 방이 한정 되어 있으니깐 <br/>같은 방에 배정 받는 경우도 있을 것이다. → 이런 경우들을 모두 충돌이라고 부른다.

<br/>

## 충돌 해결

먼저 컴퓨터는 키를 해싱할 것이다.

```java
["dab"] = "pat"
```

그리고 “pat” 를 해시 테이블의 셀 8에 추가하려고 한다.

그런데, 셀 4에 이미 “evil”이 들어 있다.

이미 채워진 셀에 데이터를 추가하는 것을 충돌이라 부른다.

|  | “taxi” |  | “evil” |  |  |
| --- | --- | --- | --- | --- | --- |
| 1 | 2 | 3 | 4 | 5 | 6 |

<br/>충동을 해결하는 고전적인 방법 하나가 **분리 연결법** 이다.

충돌이 발생했을때 셀에 하나의 값을 넣는 대신 배열로의 참조를 넣는 방법이다.



![이미지](/programming/img/해시테이블.PNG)



1. 컴퓨터는 키를 해싱한다.
2. 셀 4을 룩업(조회)한다. 컴퓨터는 셀 4이 하나의 값이 아닌 배열들의 배열을 포함하고 있음을 알게 된다. 
3. 각 하위 배열의 인덱스 0을 찾아보며 룩업하고 있는 단어인 (”dab”) 을 찾을때까지 배열을 차례대로 검색한다. <br/>일치하는 하위 배열의 인덱스 1에 있는 값을 반환한다.
<br/>DAB이 4로 해싱되므로 컴퓨터는 그 셀을 찾아 본다.

<br/>

셀 4은 배열을 포함하므로 첫 번째 셀부터 시작해서 각 셀을 선형 검색한다.

셀에 들어 있는 또 다른 배열의 인덱스 0을 확인한다.

인덱스 0에 찾고 있는 단어인 (”dab”) 이 없으므로 다음 셀로 넘어간다.

그러면 “dab”를 찾았다. 즉, 이 하위 배열의 인덱스 1에 있는 값인 (”pat”)가 바로 찾고 있던 값이다.

<br/><br/>

## 이제 해쉬 테이블을 간단하게 구현 해보자.

우선 key를 입력 받은 키를 해시 알고리즘을 통해서 해시 코드를 만들어야 하는 것이다.

sung 해당 아스키 코드를 풀어보자.

s 아스키 코드 값 : 155

u 아스키 코드 값 : 117

n 아스키 코드 값 : 110

g 아스키 코드 값 : 103

s + u + n + g = HashCode 값인 → 445 가 되는 것이다.

```java
getHashCode(sung)
```

해시 테이블은 말 그대로 어떤 고정된 판을 미리 만들어 놓고 그 키에 따라서 그 위치의 값을 갖다 놓는 것이다. <br/>그래서 해시 테이블의 필수 조건중 하나가 고정된 크기의 배열을 우선적으로 선언 하는 것이다. <br/>예를 들어, 우리는 배열방 3개를 미리 만들어 놓고 테이블를 넣을 것이다. <br/>해쉬 코드를 가지고 배열방을 환산 하는 방법은 해시 코드를 배열 방에 갯수로 나눈 나머지를 값을 인덱스로 사용 하면 되는 것이다. 

<br/>

### 공식

HashCode % size 

445 % 3 = 1 → 인덱스 1번방

321 % 3 = 0 → 인덱스 0번방

306 % 3 = 0 → 인덱스 0번방

324 % 3 = 0 → 인덱스 0번방

<br/>이렇게 할 경우 충돌이 생기는 경우를 대비 해서 배열방에 데이터를 바로 저장하는 게 아니라 <br/>배열 방안에 링크드 리스트를 선언하고 데이터가 배열 방에 할당 될때마다 링크드 리스트의 데이터를 추가 하는 것이다. <br/>그리고 검색 요청이 들어 왔을때는 검색할 키를 해시 함수를 통해서 해시 코드를 만들고 <br/>그걸 인덱스로 환산해서 해당 방에 리스트를 돌면서 내가 찾는 데이터를 가져오면 되는 것이다.

<br/>

### 훌륭한 충돌 조정

궁극적으로 해시 테이블은 다음 세 요인에 따라 효율성이 정해진다.

1. 해시 테이블에 얼마나 많은 데이터를 저장하는가
2. 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가
3. 어떤 해시 함수를 사용하는가

적은 셀에 많은 데이터를 저장하면 충돌이 많을 테고, 해시 테이블의 효율성은 떨어질 것이다.

**좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피하는 것이다.**

해시 테이블은 효율적인 소프트웨어 개발에 필수다.


<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74