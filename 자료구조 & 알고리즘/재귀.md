## 재귀

재귀는 함수가 자기 자신을 호출할 때를 말하는 공식 명칭이다.

꽤 간단하다. 기저 조건이므로 어떤 재귀도 일어나지 않는다. 

<br/>factorial(1) 을 호출하면 메서드는 단순히 1을 반환 한다. 

```java
factorial(1) {
	return 1;
}
```

<br/>다음 사례인 factorial (2) 로 넘어가 보자. 

<br/>따라서 factorial (2) 를 호출하면 2 * factorial (1) 을 반환한다. 

2 * factorial (1) 을 계산하려면 factorial (1) 이 무엇을 반환하는지 알아야 한다.

냅킨을 확인해 보면 1을 반환하고 있다는 것을 알 수 있다.

따라서 2 * factorial (1) 은 2 * 1, 즉 2를 반환한다.

```java
else {
	return number * factorial(number - 1) 
}
```

<br/>이 사실을 냅킨에 기록하자.

<br/>factorial (2) return 2

factorial (1) return 1

이제 factorial (3) 을 호출하면 어떻게 될까? 마찬가지로 관련 코드 줄은 아랫 부분이다.

```java
else {
	return number * factorial(number - 1) 
}
```

<br/>따라서 return 3 *  factorial (2) 로 바뀐다.

factorial (2) 는 무엇을 반환하는가? 냅킨에 적었으므로 처음부터 다시 알아볼 필요 없다.

factorial (2) 는 2를 반환한다. 따라서 factorial (3) 은 6 (3 * 2 = 6)을 반환 한다.

<br/>이 놀라운 사실을 냅킨에 기록하자.

factorial (3) return 6

factorial (2) return 2

factorial (1) return 1

<br/>잠시 쉬면서 factorial (4) 는 무엇을 반환하는지 스스로 알아보자.

<br/>

### 컴퓨터의 눈으로 바라본 재귀

factorial 메서드를 생각해 보면 factorial (3) 을 호출할 때

<br/>컴퓨터는 factorial (3) 을 호출하고 이 메서드가 끝나기 전에 factorial (2) 를 호출하고, <br/>factorial (2) 가 끝나기 전에 factorial (1) 을 호출한다. 엄밀히 말해 컴퓨터가 factorial (1)을 실행하는 <br/>동안 여전히 factorial (2) 를 실행 중이며, 마찬가지로 factorial (3) 도 실행하는 중이다.

<br/>컴퓨터는 스택을 사용해 어떤 함수를 호출 중인지 기록한다. 이러한 스택을 목적에 딱 맞게 호출 스택이라 부른다.

<br/>factorial 예제를 사용해 호출 스택이 어떻게 동작하는지 살펴보자.

<br/>factorial (3) 을 호출하며 시작한다. 하지만 이 메서드가 종료되기 전에 factorial (2) 를 호출한다. <br/>컴퓨터가 아직 factorial (3) 을 실행 중인지 알려면 컴퓨터는 이러한 정보를 호출 스택에 푸시해야 한다.

 

![이미지](/programming/img/재귀1.PNG)

<br/>이어서 컴퓨터는 factorial (2) 를 실행한다. 

이제 factorial (2)는 연이어 factorial (1) 을 호출한다. 

컴퓨터가 factorial (1) 을 실행하기 전에 컴퓨터는 아직 factorial (2) 를 실행 중임을 기억해야 하므로 마찬가지로 호출 스택에 푸시한다.

![이미지](/programming/img/재귀2.PNG)

<br/>이어서 컴퓨터는 factorial (1) 을 실행한다.

1이 기저 조건이므로 factorial (1) factorial 메서드를 호출하지 않고 끝난다.

<br/>호출 스택에 데이터가 들어 있으므로, 즉 아직 실행 중인 끝내야 할 메서드가 남아 있으므로 컴퓨터는 <br/>factorial (1) 을 끝냈더라도 해야 할 일이 다 끝나지 않았음을 알고 있다. 

<br/>스택에는 가장 위(즉, 마지막) 원소만 확인 할 수 있다는 제약이 있다.

따라서 컴퓨터가 할 다음 작업은 호출 스택 가장 위 원소를 가져오는 것이다.

<br/>다음 작업은 호출 스택 가장 위원소를 가져오는 것이다. 현재는 factorial (2) 이다.

factorial (2)가 가장 최근에 호출된 메서드라는 의미이므로 지금 바로 이 메서드르 완료해야 한다는 뜻이다. 

<br/>이제 컴퓨터는 호출 스택에 factorial (2) 를 팝 한다. 

![이미지](/programming/img/재귀3.PNG)

<br/>컴퓨터가 factorial (2) 의 실행을 끝낸다.

이어서 컴퓨터는 호출 스택을 확인해서 다음으로 어떤 메서드를 완료해야 하는지 알아본다.

호출 스택이 현재 다음과 같으므로,

![이미지](/programming/img/재귀4.PNG)

<br/>컴퓨터는 스택에서 factorial (3) 을 팝한 후 완료한다.

이 시점에서 스택은 비어 있으므로 컴퓨터는 메서드를 모두 실행했음을 알게 되고, 재귀는 끝난다.

<br/>전체적인 과정을 다시 살펴보면 컴퓨터가 3의 계승을 계산한 순서는 다음과 같다.

1. factorial (3) 이 먼저 호출된다.

2. factorial (2) 가 두 번째로 호출된다.
3. factorial (1) 이 세 번째로 호출된다.
4. factorial (1) 이 먼저 완료된다.

5. factorial (2) 가 factorial (1) 의 결과를 토대로 완료된다.
6. 끝으로 factorial (3) 이 factorial (2) 의 결과를 토대로 완료된다.

<br/>흥미롭게도 무한 재귀가 있을 때 프로그램은 컴퓨터 메모리에 더 이상 공간이 없을 때까지 <br/>계속해서 같은 메서드를 호출 스택에 푸시한다. 이로 인해 **스택 오버플로**라는 오류가 발생한다.

![이미지](/programming/img/재귀5.PNG)

<br/>
<br/>

### 마무리

파일시스템 예제에서 봤듯이 알고리즘 자체만으로는 얼마나 많은 단계를 깊이 들어가야 하는지 알 수 없을 때 재귀가 좋은 방법일 수 있다.

매우 효율적이지만 아직 덜 향상된 알고리즘을 곧 다루게 될 텐데 이 중 상당수는 재귀 원리에 기반한다.

<br/><br/>

## 팩토리얼 함수

<aside>
n의 팩토리얼은 n! 이라고 한다.

</aside>

이는 1부터 n까지의 정수를 곱하는 단순한 연산 이다.

예를 들어 5! 는 1 *  2 * 3 * 4 * 5 가 되는 즉 120 이 되는 것이 팩토리얼이다. 

여기서 멈출 수 있는 이유는 if문이라는 것을 생각하자. (알아서 멈추는 것이 아니다.)

<br/>

(밑에 코드 출력값.) <br/>
정수를 입력하세요. : 5  
5의 팩토리얼은 120입니다.


```java
package chap05;
import java.util.Scanner;
// 팩토리얼을 재귀적으로 구현

class Factorial {
	// 양의 정수 n의 팩토리얼을 반환합니다.
	static int factorial(int n) {
		if (n > 0)
			return n * factorial(n - 1);
		else
			return 1;
	}

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);

		System.out.print("정수를 입력하세요.：");
		int x = stdIn.nextInt();

		System.out.println(x + "의 팩토리얼은 " + factorial(x) + "입니다.");
	}
}
```


<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. 