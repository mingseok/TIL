## 삽입 정렬

### 삽입 정렬 해보기.

<br/>
배열 있다고 가정 해보자.  

인덱스 1의 값을 확인하며 첫 번째 패스스루를 시작 한다.

```java
[ 4, 2, 7, 1, 3 ]
```

<br/>준비 : 임시로 2를 삭제하고 temp_value 라는 변수에 저장한다.

배열의 윗부분으로 이 값을 옮기겠다.

<br/>1단계 : 4와 temp_value 에 들어 있는 2를 비교한다.

2단계 : 4가 2보다 크므로 4를 오른쪽을 시프트(옆으로 옮긴다.) 한다. <br/>------->공백이 배열의 왼쪽 끝에 있으므로 더 이상 왼쪽으로 시프트할 수 없다.

3단계 : temp_value를 다시 배열에 삽입해서 첫 번째 패스스루를 끝낸다

<br/>

### 이제 두 번째 패스스루를 시작한다.

준비 : 두 번째 패스스루에서는 인덱스 2의 값을 임시로 삭제한다. 이 값을 temp_value에 저장한다. 이때 temp_value 는 7 이다.

4단계 : 4와 temp_value 를 비교한다. 4가 더 작으므로 시프트 하지 않는다. <br/>------->temp_value 보다 작은 값에 도달 했으므로 시프트 단계를 끝낸다.

5단계 : temp_value 를 다시 공백에 삽입하고 두 번째 패스스루를 끝낸다.

<br/>

### 세 번째 패스스루는 다음과 같다.

준비 : 임시로 1을 삭제하고 temp_value에 저장한다.

6단계 : 7과 temp_value를 비교한다.

7단계 : 7은 1보다 크므로 7을 오른쪽으로 시프트한다.

8단계 : 4와 temp_value 를 비교한다.

9단계 : 4는 1보다 크므로 마친가지로 시프트한다.

10단계 : 2와 temp_value를 비교한다.

11단계 : 2가 더 크므로 시프트한다.

12단계 : 공백이 배열의 왼쪽 끝에 있으므로 temp_value를 공백에 삽입하고 패스스루를 끝낸다.

<br/>

### 네 번째로 이렇게 반복하는 것이다.

<br/><br/>

### 코드로 구현

```java
public class Insertion_Sort {
 
	public static void insertion_sort(int[] a) {
		insertion_sort(a, a.length);
	}
	
	private static void insertion_sort(int[] a, int size) {
		
		
		for(int i = 1; i < size; i++) {
			// 타겟 넘버
			int target = a[i];
			
			int j = i - 1;
			
			// 타겟이 이전 원소보다 크기 전 까지 반복
			while(j >= 0 && target < a[j]) {
				a[j + 1] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j--;
			}
			
			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + 1 에 위치하게 된다.
			 */
			a[j + 1] = target;	
		}
		
	}
}
```


<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>Stranger’s LAB - [https://st-lab.tistory.com/179](https://st-lab.tistory.com/179)