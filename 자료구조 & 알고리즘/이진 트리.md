## 이진 트리

<br/>

### [이진 트리 코드 보러 가기](https://github.com/mingseok/TIL/blob/main/code/Binary_Search_Tree.java)

<br/>

![이미지](/programming/img/이진트리1.PNG)

<br/>

### 트리에는 세 가지 고유한 용어가 있다.

1. 가장 상위 노드(예제에서는 “j”) 를 루트라 부른다. 보다시피 위 그림에서 루트는 트리의 꼭대기다.

2. 예제에서 “j” 를 “m” 과 “b” 의 부모라고 하고, 반대로 “j” 의 자식이라고 한다. “m” 은 “q” 와 “z” 의 부모이며, 반대로 “m” 의 자식이다.
3. 트리에는 레벨이 있다. 위 트리는 세 레벨이다. 

![이미지](/programming/img/이진트리2.PNG)

<br/>

### 이진 트리는 다음 규칙을 따르는 트리다.

1. 각 노드의 자식은 0개나 1개, 2개다.

2. 한 노드에 자식이 둘이면 한 자식은 부모보다 작은 값을, 다른 자식은 부모보다 큰 값을 가져야 한다.

![이미지](/programming/img/이진트리3.PNG)

<br/>각 노드마다 그 노드보다 작은 값을 갖는 자식, 즉 왼쪽 화살표로 표시된 자식과 큰 값을 갖는 <br/>또 다른 자식, 즉 오른쪽 화살표로 표시된 자식이 있다.

<br/><br/>

## 검색

이진 트리를 검색하는 알고리즘은 루트 노드부터 시작한다.

1. 노드의 값을 확인한다.

2. 찾고 있는 값이면 좋다.
3. 찾고 있는 값이 현재 노드보다 작다면 왼쪽 하위 트리를 검색한다.
4. 찾고 있는 값이 현재 노드보다 크면 오른쪽 하위 트리를 검색한다.

![이미지](/programming/img/이진트리3.PNG)

<br/>

**위의 사진에서 61을 검색 해보자.**

<br/>트리 검색은 반드시 **루트** 부터 시작해야 한다.

컴퓨터는 스스로에게 묻는다.

<br/>검색하고 있는 수(61)가 이 노드의 값보다 큰가 작은가? 

현재 노드보다 작으면 왼쪽 자식에게 찾는다. 찾고 있는 수가 현재 노드보다 크면 오른쪽 자식에게 찾는다. 

<br/>61은 50보다 크므로 오른쪽 어딘가에 있음을 알 수 있고, 따라서 오른쪽 자식을 검색한다.

다시 “내가 찾던 수가 맞나요?” 라고 알고리즘이 묻는다.

<br/>75는 찾고 있는 61이 아니므로 다음 레벨로 내려가야 한다. 61은 75보다 작으므로 61이 있을 수 있는 왼쪽 자식을 검색한다. 

61은 56보다 크므로 56의 오른쪽 자식에게 61을 찾는다.

![이미지](/programming/img/이진트리4.PNG)

<br/><br/>

## 삽입

**앞서 사용한 트리에 숫자 45를 삽입해 보자.**

1. 일단 루트 부터 시작 한다.

2. 45는 50보다 작으므로 왼쪽 자식으로 내려간다.
3. 45는 25보다 크므로 오른쪽 자식을 검사해야 한다.
4. 45는 33보다 크므로 33의 오른쪽 자식을 확인 한다. 

<br/>노드이므로 갈 곳이 없다. 즉, 삽입할 준비가 됐다.

<br/>45는 40보다 크므로 40의 오른쪽 자식 노드로서 45를 삽입 한다.

![이미지](/programming/img/이진트리5.PNG)

<br/>

무작위로 정렬된 데이터로 트리를 생성해야 대개 균형 잡힌 트리가 생성된다는 점이다.

하지만 정렬된 데이터를 트리에 삽입하면 불균형이 심하고 덜 효율적일 수 있다.

예를 들어, 데이터를 순서대로 즉 1, 2, 3, 4, 5 로 삽입하면 다음과 같은 트리가 생성 된다.

![이미지](/programming/img/이진트리6.PNG)

<br/>정렬된 배열을 이진 트리로 변환하고 싶을 때는 먼저 데이터 순서를 무작위로 만드는게 좋다.

<br/><br/>

## 삭제

이진 트리에서 4를 제거 해보자.

여기까지는 간단했지만 10도 삭제 하고 싶다고 하자.

![이미지](/programming/img/이진트리7.PNG)

<br/>

10을 삭제하면 11이 트리와 연결이 끊긴다. 11을 영원히 잃게 되므로 이렇게 하면 안 된다.

<br/>

하지만 10이 있던 자리에 11을 넣어 문제를 해결 할 수 있다.

삭제 알고리즘은 다음과 같은 규칙을 따른다.

1. 삭제할 노드에 자식이 없다면 그냥 삭제한다.
2. 삭제할 노드에 자식이 하나면 노드를 삭제하고 그 자식을 삭제된 노드가 있던 위치에 넣는다.

![이미지](/programming/img/이진트리8.PNG)

<br/>

### 가장 복잡한 시나리오는 자식이 둘인 노드를 삭제하는 것이다.

<br/>

**56을 삭제 하고 싶다고 하자.**

<br/>

이런 상황에서는 

자식이 둘인 노드를 삭제할 때는 삭제된 노드를 **후속자** 노드로 대체 한다.

후속자 노드란 삭제된 노드보다 큰 값 중 최솟값을 갖는 자식 노드다.

<br/>다시 말하면 후속자 노드란 삭제된 값 다음으로 큰 값을 말한다.

56 다음으로 큰 수는 61이다. 따라서 56을 **61로 대체**한다.

![이미지](/programming/img/이진트리9.PNG)

<br/>

### 컴퓨터는 후속자 값을 어떻게 찾을까?

삭제된 값의 오른쪽 자식을 방문해서 그 자식의 왼쪽 자식을 따라 계속해서 방문하며 <br/>더 이상 왼쪽 자식이 없을 때 까지 내려간다.

<br/>더 복잡한 예제로 다시 설명 하겠다.

<br/>

**이번엔 루트 노드를 삭제해 보자.**

![이미지](/programming/img/이진트리10.PNG)

<br/>

이제 루트 노드에 후속자 값을 넣어야 한다.

<br/>먼저 오른쪽 자식을 방문한 후, 왼쪽 자식이 없는 노드가 나올때까지 왼쪽 방향으로 계속 내려가야 한다.

52를 찾았으므로 52를 삭제된 노드에 넣는다.

![이미지](/programming/img/이진트리11.PNG)

<br/>이제 끝났다!!

하지만 아직 고려하지 않은 경우가 하나 있는데, 후속자 노드에 오른쪽 자식이 있을 때다.

예제 트리 52에 오른쪽 자식을 추가해서 다시 생성해 보자.

![이미지](/programming/img/이진트리12.PNG)

<br/>이때 후속자 노드인 52를 그냥 루트에 넣으면 자식인 55가 연결이 끊어진다.

<br/>삭제 알고리즘에는 규칙이 하나 더 있다.

- **만약 후속자 노드에 오른쪽 자식이 있으면 후속자를 삭제된 노드가 있던 자리에 넣은 후, <br/>후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.**

![이미지](/programming/img/이진트리13.PNG)

<br/>55를 후속자 노드의 원래 부모의 왼쪽 자식에 넣는다. <br/>이때 61이 후속자 노드의 부모였으므로 55는 61의 왼쪽 자식이 된다.

<br/>이제 정말로 끝이 났다.

![이미지](/programming/img/이진트리14.PNG)

<br/><br/>

## 이진 트리 다뤄보기

이진 트리는 데이터 삽입과 삭제가 훨씬 빠르므로 데이터를 자주 수정할 경우 특히 효율적이다.

<br/>예를 들어, 책 제목 리스트를 관리하는 애플리케이션 생성한다고 하자.

1. 프로그램은 책 제목을 알파벳순으로 출력할 수 있어야 한다.

2. 프로그램은 리스트를 계속해서 바꿀 수 있어야 한다.
3. 프로그램은 사용자가 리스트에서 제목을 검색할 수 있게 해야 한다.

<br/>책 리스트가 자주 바뀔 일이 없다면 데이터를 저장할 자료 구조로서 정렬된 배열이 적절하다.

<br/>많은 변경을 처리할 수 있어야 한다. 제목이 수백만 개라면 이진 트리를 사용하는게 좋다.

<br/>하지만 전체 책 제목 리스트를 알파벳 순으로 출력하고 싶다고 얘기한 바 있다.

<br/>먼저 트리의 노드를 모두 빠짐없이 방문할 수 있어야 한다. 자료 구조에서 모든 노드를 방문하는 과정을 **자료 구조 순회**라 부른다

![이미지](/programming/img/이진트리15.PNG)

<br/>

### 마무리

이진 트리는 정렬 순서를 유지하는 강력한 노드 기반 자료 구조이자 빠른 검색과 삽입, 삭제도 제공한다

<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74