## 그래프

### [그래프 코드 보러 가기]()

<br/>

페이스북 같은 소셜 네트워크를 만든다고 하자. 

많은 사람이 서로 “친구” 가 될 수 있다. 

엘리스가 밥의 친구라면 밥 역시 엘리스의 친구이듯이 이러한 관계는 상호적이다.

<br/>

## 그래프

그래프는 데이터가 어떻게 연결되는지 쉽게 이해시키므로 관계에 특화된 자료 구조다.

<br/>앞서 다룬 페이스북 네트워크를 그림으로 표현 하면 이렇다.

**한 사람은 한 노드로, 사람 간 관계는 각 선으로 표현한다.**

**용어로 각 노드를 정점이라 부르고, 각 선은 간선이라 부른다.**

**간선으로 연결된 정점들을 서로 인접한다고 말한다.**

<br/>

![이미지](/programming/img/그래프.PNG)

<br/>페이스북과 달리 트위터에서는 관계가 상호적이지 않다.

즉, 엘리스는 밥을 팔로우할 수 있지만, 밥이 반드시 엘리스를 팔로우하진 않는다. 

<br/>엘리스는 밥과 신시아를 둘 다 팔로우 하지만 누구도 엘리스를 팔로우하지 않는다

밥과 신시아는 서로 팔로우 한다.

![이미지](/programming/img/그래프2.PNG)

<br/>페이스북과 트위터 예제는 서로 비슷하지만 각각 관계의 본질이 다르다

<br/>트위터의 관계는 방향성이 있으므로 그림으로 표현할 때 화살표를 사용하고, 방향 그래프라 부른다.

페이스북에서는 관계가 상호적이고 단순 선을 사용하므로 그래프를 무방향 그래프라고 부른다.

<br/>

## Adjacency Matrix - 그래프

![이미지](/programming/img/배열그래프.PNG)

<br/>

## Adjacency List - 그래프

![이미지](/programming/img/배열1그래프.PNG)

<br/><br/>

## 깊이 우선 검색(DFS)

깊이 우선 검색은 트리 모양이 있다고 가정하자.
하나의 자식 노드를 방문 했으면, <br/>그 자식 노드의 끝까지 내려간다, 즉 끝까지 파고 드는 것이다. 그리고 나와서 다음 자식 노드를 끝까지 파고 든다.

<br/>
DFS -> Stack 을 이용해 구현 한다.

한번 그래프를 순회 해보자. (한번 스택에 담았던 노드는 담지 않는다.)

<br/>

그림으로 보면 이렇다.

![이미지](/programming/img/배열2그래프.PNG)

<br/>

예제를 보면 이렇다.

![이미지](/programming/img/배열그래프4.PNG)


<br/>

### **재귀 호출로 작성 했을 경우 코드가 더 간결해진다.**

![이미지](/programming/img/배열그래프5.PNG)

<br/><br/>

## 너비 우선 탐색(BFS)

시작점에서 자기 자신의 자식의 노드들을 먼저 다 방문하고, <br/>그 다음 자식의 자식노드를 전부 다 방문한다. 레벨 단위로 검색 하는 것이다.

<br/>
BFS -> Queue 를 이용해 구현 한다.

<br/>

**그림으로 보면 이렇다.**

![이미지](/programming/img/배열3그래프.PNG)


<br/><br/>

<br/>엘리스는 밥과 직접 커넥션이 있고, 밥은 신시아와 직접 커넥션이 있다.

하지만 엘리스는 신시아와 직접 커넥션이 없다. 

신시아는 밥을 통해 엘리스와 연결되므로 신시아를 2차 커넥션이라 부른다.

![이미지](/programming/img/그래프3.PNG)

<br/>

**비직접적인 커넥션을 모두 포함해 엘리스의 전체 네트워크를 찾으려면 어떻게 시작할까?**

전형적인 방법은 두가지가 있다.

<br/>

**너비 우선 탐색과 깊이 우선 탐색이다.**

너비 우선 탐색은 다음으로 처리할 장점을 추적하기 위해 큐를 사용한다.

최초의 큐는 시작점(여기서는 엘리스)만 포함한다.

따라서 알고리즘을 시작할 때 큐는 다음과 같을 것이다.

<br/>

[Alice]

이어서 큐로부터 엘리스를 삭제해서 엘리스 정점을 처리한다.

“방문했음” 이라고 표시하고, 이 정점을 현재의 정점으로 지정한다.

즉,  다음의 세 단계를 따른다.

1. 현재 정점과 인접한 각 정점을 방문 한다. 이전에 방문한 적 없는 정점이면 방문했다고 표시하고 큐에 추가한다 <br/>( 이 정점은 아직 현재 정점이 아니다)

2. 현재 정점에 인접한 정점을 모두 방문 했으므로 큐로 부터 다음 정점을 제거해서 현재 정점으로 만든다.
3. 현재 정점에 인접한 정점을 모두 방문했고 큐에 더 이상 정점이 없으면 알고리즘을 종료한다.

<br/>실제로 어떻게 동작하는지 보자.

먼저 엘리스를 현재 정점으로 만들면서 시작한다.

두 번째 그림에서 볼 수 있듯이 엘리스 주변을 여러 선으로 둘러싸서 엘리스가 현재 정점임을 표시 했다. <br/>또한 방문 했다는 의미로 엘리스에게 체크 부호를 표시 했다.

<br/>방문하지 않은 인접 정점인 밥을 방문함으로써 알고리즘을 계속 수행한다.

![이미지](/programming/img/그래프4.PNG)

<br/>두 번째 그림처럼 밥의 이름에도 체크 부호를 추가한다.

```java
따라서 이제 큐는 [Bob] 이다
```

<br/>다시 말해 아직 밥은 현재 정점이 아니란 의미다.

중요한 것은 엘리스가 **현재 정점 이더라도 여전히 밥을 방문할 수 있다.**

![이미지](/programming/img/그래프5.PNG)

<br/>다음으로 현재 정점인 엘리스의 인접 정점 중 방문하지 않은 정점이 있는지 확인한다. <br/>캔디가 있으므로 캔디에 방문 했다고 표시 한다.

```java
이제 큐에는 [Bob, Candy] 가 들어 있다.
```

![이미지](/programming/img/그래프6.PNG)

<br/>이렇게 Derek, Elaine 도 진행 하겠다.

```java
이제 큐는 [Bor, Candy, Derek] 이다.
```

![이미지](/programming/img/그래프7.PNG)

<br/>

```java
이제 큐는 [Bor, Candy, Derek, Elaine] 이다
```

![이미지](/programming/img/그래프8.PNG)

<br/>현재 정점인 엘리스의 인접 정점을 모두 방문했으므로 큐에서 정점을 삭제해서 그 정점을 <br/>현재 정점으로 만드는 다음 알고리즘 규칙으로 넘어간다.

<br/>큐는 앞에서만 데이터를 제거 할 수 있고 여기서는 밥이다.

![이미지](/programming/img/그래프9.PNG)

<br/>현재 정점의 방문하지 않은 인접 정점을 찾는 첫 번째 규칙으로 돌아간다.

프레드 하나가 있으므로 프레드에 방문 했다고 표시하고 큐에 추가한다.

```java
이제 큐는 [Candy, Derek, Elaine, Fred] 이다.
```

![이미지](/programming/img/그래프10.PNG)

<br/>밥에 더 이상 방문하지 않은 인접 정점이 없으므로 큐에서 다음 정점인 캔디를 삭제해서 현재 정점으로 만든다.

![이미지](/programming/img/그래프11.PNG)

<br/>하지만 캔디에는 방문하지 않은 인접 정점이 않다.

따라서 큐에서 다음 항목인 데릭을 가져온다. 

```java
이제 큐는 [Elaine, Fred] 이다.
```

![이미지](/programming/img/그래프12.PNG)

<br/>데릭에는 방문하지 않은 인접 정점인 지나가 있으므로 지나에 방문했다고 표시 한다.

```java
이제 큐는 [Elaine, Fred, Gina] 이다.
```

![이미지](/programming/img/그래프13.PNG)

<br/>데릭에는 더 이상 방문하지 않은 인접 정점이 없으므로 큐에서 일레인을 가져와 현재 정점으로 만든다.

![이미지](/programming/img/그래프14.PNG)

<br/>일레인에는 방문하지 않은 인접 정점이 없으므로 큐에서 프레드를 가져온다.

```java
이때 큐는 [Gina] 이다
```

![이미지](/programming/img/그래프15.PNG)

<br/>프레드에는 방문할 한 사람, 헬렌이 있으므로 헬렌에 방문했다고 표시하고 큐에 추가하면 큐는 [Gina, Helen] 이 된다.

![이미지](/programming/img/그래프16.PNG)

<br/>프레드에는 방문하지 않은 커넥션이 더 이상 없으므로 큐에서 지나를 가져와 현재 정점으로 만든다.

```java
큐는 이제 헬렌만 포함하므로 [Helen] 이다.
```

<br/>지나에는 이레나라에 방문할 정점이 하나 있다.

![이미지](/programming/img/그래프17.PNG)

<br/>

```java
현재 큐는 [Helen, Irena] 포함한다.
```

<br/>지나에는 방문할 커넥션이 더 없으므로 큐에서 헬렌을 가져와 현재 정점으로 만들면 큐에

```java
[Irena] 만 남는다.
```

<br/>헬렌에는 방문할 사람이 없으므로 큐에서 이레나를 가져와 현재 정점으로 만든다.

<br/>이레나도 방문할 정점이 없고 큐 또한 비었으므로 이제 끝났다.

![이미지](/programming/img/그래프18.PNG)

<br/>예제 그래프의 너비 우선 탐색은 단계를 두 종류로 나눠서 효율성을 계산한다.

1. 큐에서 정점을 삭제해 현재 정점으로 지정한다.

2. 각 현재 정점마다 그 정점의 인접 정점을 각각 방문한다.

<br/><br/>

## 그래프 데이터베이스

데이터베이스와 그래프 데이터베이스가 성능이 어떻게 다른지 비교해 보자.

서로가 모두 연결된 다섯 명의 친구로 이뤄진 소셜 네트워크가 있다고 하자.

<br/>엘리스와 밥, 신디, 데니스, 에델이라는 친구들이다.

이들의 정보를 저장할 그래프 데이터베이스는 아마 다음과 같을 것이다.

<br/>관계형 데이터베이스를 사용해 저장할 수도 있다.

<br/>아마도 두 테이블을 사용할 텐데, 하나는 각 사용자의 개인 정보를 저장하고, 다른 하나는 친구들 간 관계를 저장할 것이다.

![이미지](/programming/img/그래프19.PNG)

<br/>다음은 사용자 테이블이다.

| id | firstname | lastname | email | phone |
| --- | --- | --- | --- | --- |
| 1 | Alice | Adams | Adams.example.net | 555-111-1111 |
| 2 | Bob | Block | Block.example.net | 555-222-2222 |
| 3 | Cindy | Clyde | Clyde.example.net | 555-333-3333 |
| 4 | Dennis | Dimderg | Dimderg.example.net | 555-444-4444 |
| 5 | Ethel | Emory | Emory.example.net | 555-555-5555 |

<br/>누가 누구와 친구인지 기록하기 위해 별도의 관계 테이블을 사용하겠다.

관계 테이블 → 엘리스는 밥과 친구다.

| user_id | friend_id |
| --- | --- |
| 1 | 2 |
| 1 | 3 |
| 1 | 4 |
| 1 | 5 |
| 2 | 1 |
| 2 | 3 |
| 2 | 4 |
| 2 | 5 |
| 3 | 1 |
| 3 | 2 |
| 3 | 4 |
| 3 | 5 |
| 4 | 1 |
| 4 | 2 |
| 4 | 3 |
| 4 | 5 |
| 5 | 1 |
| 5 | 2 |
| 5 | 3 |
| 5 | 4 |

<br/>데이터베이스 이론을 너무 깊이 살펴보지는 않겠지만 

<br/>ID를 사용해 어떻게 서로를 표현하는지 알아두자.

모든 친구의 개인 정보를 볼 수 있다고 가정하자.

<br/>신디가 이러한 정보를 요청한다는 것은 엘리스와 밥, 데니스, 에델에 대한 모든 정보,

즉 이메일 주소와 전화번호를 알고 싶다는 뜻이다.

<br/>관계형 데이터베이스를 기반으로 하는 애플리케이션에서 신디의 요청을 어떻게 실행하는지 보자.

<br/>먼저 사용자 테이블에서 신디의 ID를 찾는다.

사용자 테이블 → ‘3’ 은 신디의 ID

| id | firstname | lastname | email | phone |
| --- | --- | --- | --- | --- |
| 3 | Cindy | Clyde | Clyde.example.net | 555-333-3333 |

<br/>다음으로 관계 테이블에서 user_id가 3인 모든 줄을 찾는다.

<br/>이제 신디의 전체 친구 ID 리스트인 [ 1, 2, 4, 5 ] 가 생겼다

<br/>이 ID 리스트로 다시 사용자 테이블에서 ID에 대응하는 각 줄을 찾아야 한다.

<br/>데이터베이스가 이진 검색을 사용해 각 줄을 찾을 수 있기 때문이다

![이미지](/programming/img/그래프20.PNG)

<br/>신디를 찾기만 하면 한 친구의 정보를 찾는 데 딱 한 단계가 걸린다.

<br/><br/>

## 가중 그래프

미국의 몇몇 주요 도시에 대한 기본적인 지도를 나타내는 가중 그래프다.

간섭이 연결하는 도시 간 거리를 마일 단위로 표현한 숫자가 붙어 있다.

예를 들어, 시카고와 뉴욕 간 거리는 714마일 이다.

![이미지](/programming/img/그래프21.PNG)

<br/><br/>

### 그래프는 다섯 개 도시 간 가능한 항공료를 보여준다.

<br/>애틀랜타에 있고 엘패소로 가고 싶다고 하자. 

<br/>불행히도 직항은 없다. 하지만 다른 도시를 경유해도 괜찮다면 갈 수 있다.

<br/>예를 들어, 애틀랜타에서 덴버로 가서 덴버에서 엘패소로 비행할 수 있다.

<br/>이 경로에는 300달러가 든다. 

<br/>하지만 더 유심히 보면 더 저렴한 경로가 있음을 알 수 있다.

<br/>애틀랜타에서 덴버와 시카고를 거쳐 엘패소를 가는 것이다.

<br/>비행을 더 해야 하지만 280달러면 된다.

<br/>이러한 상황에서 최단 경로 문제란 이런 것이다.

<br/>어떻게 하면 가장 적은 돈으로 애틀랜타에서 엘패소로 갈 수 있을까? 

![이미지](/programming/img/그래프22.PNG)

<br/>

## 데이크스트라의 알고리즘

1. 시작 정점을 현재 정점으로 한다.
2. 현재 정점에 인접한 모든 정점을 확인해서 시작 정점으로부터 알려진 모든 위치까지의 가중치를 계산하고 기록한다.

3. 다음 현재 정점을 결정하려면 시작 정점으로부터 도달할 수 있는 방문하지 않은 가장 저렴한 알려진 정점을 찾는다
4. 그래프 내 모든 정점을 방문할 때 까지 1-3단계를 반복한다.

<br/>


| 애틀랜타부터 | 보스턴 | 시카고 | 덴버 | 엘패소 |
| --- | --- | --- | --- | --- |
|  | 100달러 | 200달러 | 160달러 | 280달러 |

<br/>

### GPS 기술에도 동일한 방식을 사용할 수 있다.

가중치를 가격이 아닌 각 도시에서 다른 도시로 운전할 때 얼마나 빨리 갈 수 있느냐로 표현한다면 <br/>쉽게 데이크스타리의 알고리즘을 사용해 한 장소에서 다른 장소로 운전할 때 어떤 경로로 가야할 지 결정할 수 있다.

<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74