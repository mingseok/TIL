## 버블 정렬

### 간단하게 설명 해보면

버블 정렬은 앞에서 2개씩 바로 자기 옆에 있는 애랑 비교해서 작은 값을 앞으로 큰 값을 뒤로 <br/>바꾸면서 배열을 끝까지 반복해서 정렬을 하는 방법이다. O(n^2) 시간이 든다.

<br/>

( O(N^2) 을 “이차 시간” 이라고도 부른다. → O(N^2) 를 보면 “중첩 루프” 구나 생각이 들어야 한다.)

<br/>

### 정렬 알고리즘인 버블 정렬

1. 첫 번째 항목과 두 번째 항목을 비교한다.

2. 두 항목의 순서가 뒤바뀌어 있으면 (즉, 왼쪽 같이 오른쪽 값보다 크면) 두 항목을 교환한다.
<br/>(순서가 올바르다면 2. 에서는 아무것도 하지 않는다.)

1. “포인터” 를 오른쪽으로 한 셀씩 옮긴다.<br/>(배열의 끝까지 또는 이미 정렬된 어떤 항목까지 1단계와 2단계를 반복한다.)

1. 더 이상 교환하지 않을 때까지 1단계부터 3단계를 반복한다. 더는 교환을 하지 않는다는 것은 배열이 정렬된 상태라는 뜻이다.

<br/>

1단계부터 3단계까지 반복하는 것을 **‘패스스루’ 라고 부른다**

알고리즘의 주요 단계들을 ‘통과’ 했다는 의미이며, 배열이 완전히 정렬된 때까지 같은 절차를 반복한다. 

<br/><br/>

## 버블 정렬 실제로 해보기

예제를 살펴보자. 

이라는 배열을 정렬하고 싶다고 가정하자. 올바르게 오름차순으로 정렬하고 싶다.

설명은 밑에서 하겠다.

```java
[4, 2, 7, 1, 3]
```

<br/>

### 첫 번째 패스스루를 시작해 보자.

1단계. 먼저 4와 2를 비교한다. 순서가 맞지 않다.

2단계. 따라서 둘을 교환 한다.

3단계. 다음으로 4와 7을 비교한다.         
------>  순서가 올바르다. 교환할 필요가 없다.

4단계.  이제 7과 1을 비교한다.

5단계. 순서가 맞지 않으므로 교환한다.

6단계. 7과 3을 비교한다.

7단계. 순서가 맞지 않으므로 교환한다.
<br/>------>이제 7은 확실히 배열 내에서 올바른 위치에 있다.

<br/>이 알고리즘을 버블 정렬이라 부르는 까닭이 바로 여기에 있다.

각 패스스루마다 정렬되지 않은 값 중 가장 큰 값, “버블” 이 올바른 위치로 가게 된다.

<br/>

**첫 번째 패스스루에서 교환을 적어도 한 번 수행 했으니 다음 패스스루도 수행해야 한다.**

<br/>

### 두 번째 패스스루를 시작하자.

7은 이미 올바른 위치에 있다.

8단계. 2와 4를 비교하며 시작한다.
<br/>------>올바른 순서이므로 다음 단계로 넘어간다.

9단계. 4와 1을 비교한다

10단계. 순서가 맞지 않으므로 교환한다.

11단계. 4와 3을 비교한다.

12단계. 순서가 맞지 않으므로 교환한다.

<br/>첫 번째 패스스루를 통해 7이 이미 올바른 위치라는 것을 알고 있으니 4와 7은 비교할 필요가 없다. <br/>또한, 이제 4역시 올바른 위치로 올라갔다. 이로써 두 번째 패스스루도 끝났다.

<br/>

**세 번째 패스스루 부터는 첫 번째, 두 번째 했던 방식으로 이어 가면 되는 것이다.**

<br/><br/>

### 버블 정렬 코드이다.

```java
package test;

public class Test {

	private static void bubbleSort(int[] arr) {
		bubbleSort(arr, arr.length - 1);
	}

	private static void bubbleSort(int[] arr, int last) {
		if (last > 0) {
			for (int i = 1; i <= last; i++) {
				if (arr[i - 1] > arr[i]) {
					swap(arr, i - 1, i);
				}
			}
			bubbleSort(arr, last - 1);
		}
	}

	private static void swap(int[] arr, int source, int target) {
		int tmp = arr[source];
		arr[source] = arr[target];
		arr[target] = tmp;
	}

	private static void printArray(int[] arr) {
		for (int data : arr) {
			System.out.print(data + ", ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int[] arr = { 3, 5, 4, 2, 1 };
		printArray(arr);
		bubbleSort(arr);
		printArray(arr);

	}

}
```


<br/>

## 버블 정렬의 효율성

버블 정렬 알고리즘에 포함된 단계는 두 종류가 있다.

비교 : 어느 쪽이 더 큰지 두 수를 비교한다.

교환 : 정렬하기 위해 두 수를 교환 한다.

<br/>이러한 시나리오에서는 비교 10번, 교환 10번이 일어나 총 20단계가 필요하다.

예를 들어, 원소 10개가 역순으로 된 배열에서는 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45번의 비교와 45번의 교환이 일어난다. 

총 90 단계이다.

또 한 가지를 더 생각해보자면 원소가 20개인 경우 총 380단계가 되는 것이다.


<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74