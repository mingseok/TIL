## Linked List 표현



### ✔️[Linked List 코드](https://github.com/mingseok/TIL/blob/main/code/Linked_List2.java) 

--- 
<br/>


### ✔️[취약한 단방향 Linked List 코드](https://github.com/mingseok/TIL/blob/main/code/LinkedList.java) 

이 코드로는 첫 번째 데이터가 대표이기 때문에 값을 지울 수가 없다.


<br/>

동구) : “ 민석아, 너 철수 알아? “

민석) : “ 응 ! 철수는 내 동생의 친구의 삼촌의 선배의 아들이야 ! ”

| 시작 |  | data | link | data | link | data | link | data | link | data | link |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 민석이의 | → | 동생의 | → | 친구의 | → | 삼촌의 | → | 선배의 | → | 아들 | null |


<br/>

Linked List 를 사용하는 이유는 링크드 리스트 처럼 삽입하고, <br/>삭제하고 이런 기능들을  배열로 구현해야 한다면, 노드가 한개 추가 될때 마다 <br/>배열 방을 통째로 다시 선언해서 이걸 다 복사하고 해야 되는 힘든 상황이 발생 하는 것이다. <br/>그러므로 길이가 정해지지 않은 데이터를 핸들링 할때는 링크드 리스트를 사용 하는 것이다.

<br/>

|  | Array (배열) | Linked list (연결 리스트) |
| --- | --- | --- |
| 차이점 | (정적할당)<br/>정해진 메모리크기를 미리 할당 하기때문에 <br/>오버플로우나 공간 낭비가 발생가능하다. | (동적할당)<br/>필요한 만큼 메모리를 동적으로 할당 받아서 만든다.
 |

## Linked List

Linked List 를 '단순 연결 리스트', '연결 리스트', '선형 연결 리스트', '단순 연결 선형 리스트'  라고도 부른다.

<br/>

## 점 연산자를 사용한 표현

민석.link.link.link.link.data

<br/>


연결 리스트는 나란히 이어진 메모리 셀 묶음이 아니다.
서로 인접 하지 않은 메모리 셀 묶음으로 이뤄진다. <br/>컴퓨터 메모리 전체에 걸쳐 여러 셀에 퍼져 있을 수 있다. 서로 인접하지 않은 이러한 셀을 노드라 부른다.

<br/>


**각 노드는 노드에 저장된 데이터뿐만 아니라 연결 리스트 내에 다음 노드의 메모리 주소도 저장해야 한다.**

<br/>
첫 번째 셀에는 실제 데이터가 들어 있고, 두 번째 셀에는 다음 노드의 시작 메모리 주소를 뜻하는 링크가 들어 있다. <br/>마지막 노드의 링크는 연결 리스트가 끝나므로 null 이다. 


<br/>

### 단순 연결 리스트에서의 노드 삽입 연산

<br/>

### 단순 연결 리스트 week2=(월, 금, 일)에서 원소 "월"과 "금" 사이에 새 원소 "수"를 삽입한다면 다음의 단계를 수행한다.

![이미지](/programming/img/연습1.PNG)

<br/>


### 1.삽입할 새 노드를 만들기 위해 공백 노드를 메모리에서 가져와서 참조 변수 new가 가리키게 한다 

![이미지](/programming/img/연습2.PNG)

<br/>

### 2. new 의 데이터 필드에 “수” 를 저장한다.

![이미지](/programming/img/연습3.PNG)

<br/>

### 3. 새 노드가 삽입될 자리의 앞 노드, 즉 “월” 노드의 링크 필드값을 new 의 링크 필드에 저장 한다.

![이미지](/programming/img/연습4.PNG)

<br/>

### 4. “월” 노드의 링크 필드에 new 의 값을 저장 한다.

![이미지](/programming/img/연습5.PNG)

<br/>링크 필드의 참조값에 대한 연산만으로 쉽게 삽입 연산을 수행할 수 있다는 것이 연결 자료구조의 장점이다.

<br/><br/>

## 단순 연결 리스트에서의 노드 삭제 연산

1. 삭제할 원소의 앞 노드(선행자)를 찾는다.
2. 앞 노드의 링크 필드에 삭제할 노드의 링크 필드값을 저장한다. <br/>(설명 → 삭제된 “수” 노드의 링크 필드값은 아직 그대로 “금” 노드를 가리키고 있지만, <br/>“수” 노드로 연결되는 앞 노드가 없기 때문에 의미적으로 “수” 노드는 week2 에서 제외된 노드가 된다. <br/>따라서 굳이 “수” 노드의 링크 필드에 null을 넣지 않아도 링크 필드의 값은 리스트에서 이미 의미 없는 값이 된 것이다.)

<br/><br/>

## 자유 공간 리스트

연결 리스트에서 삽입 연산을 하려면 먼저 메모리에서 공백 노드를 가져와야 한다

<br/>그리고 삭제 연산에서는 삭제되어 사용하지 않는 노드에 대한 메모리 공간을 처리해야 한다.

<br/>이것은 삽입 연산을 할 때마다 필요한 노드의 크기와 구조에 맞추어 메모리 공간을 할당해주는 <br/>작업과 삭제 연산을 할 때마다 삭제되어 사용하지 않는 노드에 대한 메모리 공간을 해제해 주는 작업이 필요한 것이다.

<br/>예를 들면, 기차놀이를 하려고 하는데 같이 할 친구가 어디 있는지 모르면 이리저리 찾아다녀야 할 것이다. <br/>하지만 놀 때는 놀이터에 있고 놀지 않을 때는 항상 집에 있기로 약속해두면 찾아다닐 필요 없이 <br/>집에 가서 친구를 불러오면 된다. <br/><br/>마찬가지로 기차놀이에서 빠진 친구도 어디에 있을까 고민할 것 없이 <br/>그냥 집으로 가면 된다. 집에 있는 친구들은 놀자고 부르면 언제든지 놀이터로 나올 수 있고 <br/>놀이가 끝나면 다시 집으로 들어간다. 이렇게 놀지 않는 친구들이 모여 있는 집이 자유 공간 리스트 이다.

<br/>메모리를 사용하기 전에 미리 노드로 나누어서 연결해 놓은 리스트를 자유 공간 리스트 라고 한다.

<br/>자유 공간 리스트 를 사용하기 위해서는 자유 공간 리스트로부터 새로운 공백 노드를 할당받아 <br/>그 메모리 주소에 대한 참조값을 반환하는 getNode( ) 함수가 필요하다.

<br/>

### 설명은 코드 밑에 있음.

```java
getNode()
  if (Free = null) then // then if문의 중괄호 시작부분. 
									underflow();
      new <- Free; // <- 대입 한다는 것.
      Free <- Free.link;
      return new;
      
end getNode() // end 메서드 종료 한다는것.
```

<br/>

### new ← Free( );

리스트 Free의 첫 번째 노드에 대한 참조값 (100) 을 참조변수 new 에 저장하여 new 가 할당할 노드(Free 리스트의 첫 번째 노드)를 가리키게 한다. (첫번째 노드라고 하면 100번지와 링크는 200을 가리키고 있는 곳을 말한다.)

![이미지](/programming/img/리스트1.PNG)

<br/>

### Free ← Free.link;

리스트 Free 의 두번째 노드에 대한 참조값(Free.link, 200)을 Free에 저장한다.( 200으로 수정 된거 잘보기)

![이미지](/programming/img/리스트2.PNG)

<br/><br/>이제 자유 공간 리스트 Free 의 첫 번째 노드는 리스트에서 의미적으로 분리된 상태므로 <br/>new 를 반환(return new;) 해줌으로써 새 노드를 할당해주게 된다.

<br/>

returnNode(old) 함수는 사용이 끝난 노드를 참조변수 old를 사용하여 자유 공간 리스트에 반환하는 함수다.


```java
returnNode(old) 
    old.link <- Free;
    Free <- old;
end returnNode()
```

<br/><br/>참조변수 old는 사용이 끝나서 자유 공간 리스트에 반환할 노드를 가리킨다. <br/>반환되는 노드는 자유 공간 리스트 Free 의 첫번째 노드로 다시 삽입하기로 한다.

![이미지](/programming/img/리스트3.PNG)

<br/>

### 1. [old.link](http://old.link) ← Free;

자유 공간 리스트 Free의 첫번째 노드에 대한 참조값 (200) 을 참조변수 old가 가리키는 노드의 링크 필드(old.link) 에 저장한다.

그러면 old가 가리키는 노드가 리스트 Free의 첫번째 노드와 연결된다. 

![이미지](/programming/img/리스트4.PNG)

<br/>

### 2. Free ← old;

참조변수 old의 값, 즉 반환할 노드의 참조값 (100)을 참조변수 Free에 저장하여 리스트 Free의 첫번째 노드로 지정한다.

![이미지](/programming/img/리스트5.PNG)

<br/>

### 연결 리스트 다뤄보기

연결 리스트가 빛을 발하는 경우는 한 리스트를 검사해서 많은 원소를 삭제할때다. <br/>예를 들어, 이메일 주소 리스트를 샅샅이 검토해서 유효하지 않은 형식의 이메일을 모두 삭제하는 애플리케이션을 만든다고 하자. <br/>이 알고리즘은 한 번에 하나씩 모든 이메일 주소를 검사하고, 정규식(어떤 유형의 데이터를 식별하는 특수한 패턴)을 사용해 <br/>이메일 주소가 유효하지 않은지 확인한다. 유효하지 않으면 리스트에 제거한다.

<br/>

이메일 주소 열 개 중 하나가 유효하지 않다고 가정하자.
<br/>이메일 주소 천 개로 이뤄진 리스트가 있을때 약 100개의 유효하지 않은 이메일이 있을 것이고, <br/>따라서 알고리즘은 읽기 1,000단계 + 삭제 약 100,000단계(유효하지 않은 이메일 100개 * N)가 걸릴 것이다.

<br/>

하지만 연결 리스트에서는 리스트 전체를 살펴보면서 삭제가 필요하면 <br/>그저 그 노드의 링크가 적절한 노드를 가리키도록 바꾸면 되므로 각 삭제마다 딱 한 단계가 걸린다. <br/>이메일이 천 개 있을때, 알고리즘은 1,000개의 읽기 단계와 100개의 삭제 단계, 딱 1,100단계만 걸린다.


<br/><br/>

>**Reference**
<br/>이지영,**『**자바로 배우는 쉬운 자료구조**』**, 한빛아카데미.
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74
