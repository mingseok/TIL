## 재귀함수

<br/>

### 재귀문제의 팁

재귀문제는 노트랑 펜을 들고 코드를 시뮬레이션으로 그려보면서 풀면 좋다.

<br/>

## 재귀함수를 어디다 사용하나?

재귀함수 : 자기 자신을 부르는 함수

함수란? 값을 입력받아 특정 연산을 수행하여 결과를 반환 하는 것.

<br/>

## ! : 팩토리얼이라고 부른다.

## 재귀함수가 의미있게 사용하는 예제는 팩토리얼이다. ( n! )

n! = 1 * 2 * 3 * … * n 까지 곱하는 것을 팩토리얼이라고 부른다.

3! = 1 * 2 * 3 = 6

4! = 1 * 2 * 3 * 4 = 24

<br/>

## getFactorial(4) 인지는 어딜 보면 알까?

이 부분의 코드를 기준으로 getFactorial(4) 이라고 대답 할 수 있는 것이다.

```java
 public static int getFactorial(int n) { 
		
		```
```

<br/>

## 과정이 숨어 있다.

gF(3) 이 3! 을 잘 반환 한다는 가정이 숨어 있는 것이다. 

그런데 반환 하는지는 모른다. 그러면 내려가 보는 것이다. 

그러면 gF(3) 도 gF(2) 한테 얘기를 하는 것이다. → “너 gF(2) 잘 구해야 돼” 라는 가정을 하는 것이다.

그리고 gF(2) 도 gF(1) 한테 똑같이 말하며, gF(0) 까지 내려가는 것이다. 

<br/>

gF(0) 잘 반환 할 것이다 왜? 우리가 `if(n == 0) { return 1; }` 으로 못을 박아 놨기 때문이다.

그렇다면 gF(1) 입장에서는 “나도 gF(1) 을 잘 반환 하는 것이 되는 것이다!” 왜??

gF(0) 이 잘 반환 했기 때문이다. 즉 gF(1) → gF(2) → gF(3) 모두 잘 반환 하게 된다는 것이다 !!

<br/>

말 할때는 “4 * gF(3) 을 반환 해라” 라고 말하는 것이다.

```java
return n * getFactorial(n - 1);
```

<br/>

## getFactorial(4) 랑 getFactorial(3) 은 다른 스코프에 있다!!

- 스코프란? 함수의 `{ }` 영역을 말한다.

    - 제목처럼 다른 스코프에 있다는 말은, `getFactorial(4)` 가 가지고 있는 것은 `n == 4`인데
        
        `getFactorial(3)` 가 가지고 있는 것은 `n == 3`이다. 즉, 아예 다른 변수이다.
        
- `getFactorial(4)` 가 `getFactorial(3)` 기다리고 있단 개념도 확실하게 알자.
    - 왜냐면 `return n * getFactorial(n - 1);` 부분에서 n * □ 계산을 해야되는데 □ 부분이 함수되어 있기 때문에 <br/>아직 값을 모르는 것이다. `getFactorial(n - 1)` 그리하여 기다리고 있다고 표현 하는 것이다.

- 중요한 사실 한 가지!! 마지막 `n == 0` 까지 내려 갔다면 돌아 올 땐 누구한테 가는가?? 나를 불렀던 애한테 가야 되는 것이다.
    - 스토리를 생각해 보자면

    - 마지막 getFactorial(0)까지 내려가 있으면 `getFactorial(1)` 이 쭉 기다리고 있다가
    - `getFactorial(0)`이 `return` 할때 “엇!! `getFactorial(0)` 이 1이라고 알려주는구나” 하고 알게 되는 것이다.
    - “아, 그러면 나는 1 * 1 하여 나도 return 하면 되겠다” 라고 생각하게 하는 것이다.
    - 누구한테 반환 하는가?? “나를 기다리고 있는 친구한테” `(=getFactorial(2))` 이다

<br/>

```java
import java.util.*;

class bbb {

  public static int getFactorial(int n) {
    if (n == 0) {
      return 1;

    } else {
      return n * getFactorial(n - 1);
    }
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int x = sc.nextInt();

    System.out.println(getFactorial(x));
  }
}
```

<br/>


## 재귀는 수학적 귀납법으로 증명 가능하다.

![이미지](/programming/img/재귀함수1.PNG)

P(n) 은 이것이다.

즉, 이 명제가 다 true냐 ? 물어보는 것이다.

<br/>

![이미지](/programming/img/재귀함수2.PNG)



이런식으로 계산하며 내려가는 것이다.

3 차례라고 3만 나오는 것이 아니고, 3 + 2 + 1 까지 3의 전 숫자들 까지 다 나와야 되는 것이다.

즉, 1일때가 성립한다면 2일때도 된다는 것이며, 3일때가 성립한다면 4일때도 성립한다는 그런 말이다.

<br/>

![이미지](/programming/img/재귀함수3.PNG)

그림으로 보면 이렇다.

P(1) 일때 된다면 P(2) 도 되고 → P(3) 도 되고 → P(4) 되고 전부 된다는 말이다.

<br/>

![이미지](/programming/img/재귀함수4.PNG)



## 이렇게 수학적 귀납법을 배워 봤는데 왜 배웠는가?

### “gF(n) 이 정말로 n! 을 반환 하냐?” 를 증명하기 위해 배운 것이다.

그렇다면 첫번째로 뭘 해야 되나?

n이 1일때 되냐? 를 봐야 하는데 getFactorial() 에서는 1이 처음이 아니라 0이 처음이다. 

<br/>

그럼 0일 때 되는지를 보자면 “gF(0) 은 0! 을 잘 반환 합니까?” 하며 물어본다. <br/>하지만 
이것은 명제이다. 다시 설명하면 명제란? gF(0) = 0! 을 잘 반환한다는 것이다. 

<br/>

다시 돌아와 잘 반환 하는 게 맞다는 걸 알 수 있다 !! 왜?? `return 1;` 이라고 맞게 작성 했기 때문이다.<br/> “아, 그래서 0일때는 성립을 하는구나” 라고 알수 있는 것이다.

<br/>

### 궁극적인 궁금증은 밑에 사진을 제대로 나오냐? 가 궁금한 것이다.

![이미지](/programming/img/재귀함수5.PNG)

<br/>

### 코드 설명 처럼 따지자면 위에 설명이랑 똑같다고 할 수 있다.

### getFactorial(k - 1) 이 (k-1)! 잘 내놓는다면, getFactorial(k) 도 k! 를 잘 내놓는다는 말이 성립 하는 것이다.

![이미지](/programming/img/재귀함수6.PNG)

<br/>

더 나아가서 gF(n-1) 이 된다면 n! 이 제대로 된다고 확신 할 수 있는 것이다.

다시 말해, gF(n-1) 이 제대로 나온다는 다는 것이다.

따라서 수학적 귀납법에 의해서 어떻게 된다? 0 제대로 되고 1 제대로 되고, 2 제대로 되고, … 전부 제대로 된다는 걸 <br/>수학적 귀납법에 의해 증명을 할 수 있게 된 것이다.

![이미지](/programming/img/재귀함수7.PNG)

이 코드 자체가 증명이라고 말 할 수 있다.

<br/>

`getFactorial(n - 1)` → n -1 일때 된다고 가정하면, `getFactorial(int n)` → n 일때 된다는 것이다

이때까지한 증명 부분이다 !!

재귀함수가 하는 일 : 귀납적으로 계산하는 방법이다.

<br/>

### 중요한 부분은 `getFactorial(n)` 이 n! 을 반환 하는지를 알고 싶은 건데, <br/>여기서 충분히 `getFactorial(n-1)` 은 n-1! 을 반환한다고 가정해도 상관없다는 얘기를 하고 싶은 것이다.

<br/>

내가 “getFactorial(n) 은 n! 를 반환 했으면 한다” 라고 정의를 했는데, 나는 실제로 제대로 나오는지도 되는지도 모른다. <br/>하지만 이렇게 정의를 한다면, 그 정의 된 걸 그대로 쓸 수 있다는 것이다. 

<br/>

![이미지](/programming/img/재귀함수8.PNG)

무슨 말이냐?? 충분히 가정하고 사용할 수 있다는 뜻이다. 설명을 하자면 “`getFactorial(n-1)` 은 정말로 n-1! 를 반환한다 ~~” 라고 답이 뭔지도 모르는 상황 속에서도 충분히 확신을 가질 수 있다는 얘기 이다. 왜?? 수학적 귀납법에 의해서 가정 할 수 있다

<br/><br/>

## 중요!!

내가 할 일은 이런 증명들이 있으니, 이게 될 거니깐 나는 나머지 조건들을 완성만 하면 되는 것이다. <br/>어떻게?? n-1!(=설명 n-1! 이 뭐다? 4! 보다 하나 작은 3! 을 말한다 1 * 2 * 3 = 6을 말함) 제대로 줄거니깐 <br/>“나는 n만 곱해서 리턴 하면 되겠다” 하는 것이다. n은 4이니 4 * 6 하여 24를 리턴 하는 것이다. 

<br/>

여기서 n만 곱한다는 말은 즉, `return n * getFactorial(n - 1);` 부분에서 

`getFactorial(n - 1)` 가 n-1! 이니깐, 그 n-1! 이 뭐다? → 3! 을 가지고 곱하면 된다는 말이다. 


<br/>


n을 4! 인 예제를 설명하자면 4! 의 `getFactorial(n - 1)` 마지막 부분이 3! 일 것이다. 왜? 

n은 4이기 때문에 -1를 한다면 3! 이다.  그리고 3! 은 1 * 2 * 3 = 6이다. 그리하여 

n만 곱한다는 말은 즉, 마지막 부분 gF(4)인 return 4 * 6; 만 하면 답이 24가 나온다는 뜻이다.

<br/>

### 정리 “getFactorial(n) 이 n! 을 반환 했으면 좋겠다” 라고 이야기 해놓고, <br/>여기서 “getFactorial(n-1) 은 n-1! 를 반환 한다” 라고 가정해도 상관이 없다는 말이다.

그래서 내가 해야 되는건 뭐냐면 n-1! 된다고 치고 n! 반환 하기 위해서 완성만 하면 되는 것이다. 

<br/>

완성에 대한 작업은 어떻게 하냐?? n-1! 이 구해 질테니깐 여기서 n 을 곱해서 반환 하기만 하면 된다는 것이다.

<br/>

## 생각 정리 (중요)

getFactorial(n) 은 n! 를 반환 해준다 했다. 그렇다면 getFactorial(n - 1) 도 n-1! 를 반환 해줄 것이라고 가정을 할 수 있다. <br/>그러면 식을 만들 수 있다. 재귀함수를 타고 들어가 gF(0), gF(1-1), gF(2-1) … 등등 작업들은 내가 알고 싶지 않고 그냥,<br/> getFactorial(n - 1) 까지 오는 n-1! 를 그대로 믿는 것이다. 

<br/>

어떻게?? getFactorial(n) 은 n! 를 반환 해준다는 수학적 귀납법으로 증명이 되어 있기 때문이다.

그렇다면 getFactorial(n - 1) 은 n-1! 를 반환 해준다는 것도 똑같은 원리라고 말할 수 있다. 

<br/>

그리하여 (1 * 2 * 3) 복잡한 과정들은 다 버리고 한번에 대처 할 수 있는 n-1! 를 사용하여 
n * n-1! 식을 만들어 편리하게 <br/> 4! 를 구할 수 있게 되는 것이다. 

<br/>

포인트는 1 * 2 * 3 * 4 이런 귀찮은 작업들을 해야 하는데, 재귀함수인 getFactorial(n - 1) 사용하여 

수학적 귀납법을 통해 1 * 2 * 3 의 3! 까지는 컴퓨터 보고 알아서 구하게 하고, 

나는 마지막 `return 4 * 6;` 만 계산하여 나온 4! 를 리턴만 하면 되는 것이다.

```java

import java.util.*;

class bbb {

  public static int getFactorial(int n) {
    if (n == 0) {
      return 1;

    } else {
      return n * getFactorial(n - 1);
    }
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int x = sc.nextInt();

    System.out.println(getFactorial(x));
  }
}
```

<br/>

## 이렇게 재귀 함수 의미를 확실하게 알 수 있게 되었다.

## 재귀함수 디자인

![이미지](/programming/img/재귀함수9.PNG)

<br/>

## 꼭 따라하기, 시키는건 그냥 좀 따라하자.

## 재귀함수 디자인을 위한 3가지 절차

1) 함수의 역할을 말로 정확하게 정의한다.

- ex) getResult가 하는일 : 모든 가능한 경우들을 출력 시킬것이다.

- 계산해야 될게 뭔지 알아야 계산을 할 수 있기 때문.
- 즉, 함수에다가 뭘 넣으면 뭐가 나오는지? 같은 느낌이다.
- 함수의 역할을 말로 명확하게 정의 하는 것이다.
- 말로 명확하게 정의하지 않고, 재귀함수를 짜려고 한다면 백날 천날 해도 못짠다.<br/>
동작한다 해도 이게 왜 되는지 모른다. 그건 코딩을 하는 이유가 없다.
- `getFactorial(n)` 는 n! 을 반환 하는 함수이다. 라고 명확하게 정의하기.
- 그러고 다음 해야 되는 것은 2) 로 가기.

<br/>

2) 기저조건에서 함수가 제대로 동작함을 보인다.

- 기저조건이란? 제일 단순한 경우를 말한다.
- 즉, 팩토리얼 같은 경우는 0! 이 1 이라고 정의를 한 것이다.

- 왜 그랬나?? 더 이상 내려가지 마라고 한 것이다. 이런 조건을 기저조건이라고 한다.
- 다시 말해, n이 가~장 바닥 일 때 정의 해줘야 되는 것이다.

3) 함수가 (작은 input에 대하여) 제대로 동작한다고 가정하고 함수를 완성한다.

- 이건 마치 수학적 귀납법에서 k 일때 된다고 가정하고,
- k + 1 일때 된다는 것을 증명 하는 것이랑 같은 것이다.

<br/>

## 이렇게 3가지 절차를 무조건 따라야 하는 것이다

그리고 헷갈리지 말기.

현재 재귀(index) 에서 배열에 값을 넣었다면 그건 그 현재 인덱스 인것이다. 

그 다음꺼가 아니라는 말이다.