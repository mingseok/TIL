## 퀵

### ✔️[퀵 코드](https://github.com/mingseok/TIL/blob/main/code/quick.java)

<br/>

퀵 정렬은 **분할**이라는 개념에 기반하므로 **분할**을 먼저 알아보자. 

<br/>

## 분할

배열을 분할한다는 것은 배열로부터 임의의 수를 가져와 (이후 이 수를 피벗이라 부름)

피벗보다 작은 모든 수는 피벗의 왼쪽에, 피벗보다 큰 모든 수는 피벗의 오른쪽에 두는 것이다.

<br/>같은 배열이 있다고 생각하자.

| 0 | 5 | 2 | 1 | 6 | 3 |
| --- | --- | --- | --- | --- | --- |

가장 오른쪽에 있는 값을 항상 피벗으로 고르겠다. 

<br/>예제에서는 숫자 3이 피벗이다. 

<br/>이어서 두 “포인터”를 사용해 하나는 배열 가장 왼쪽에 있는 값에, 다른 하나는 피벗을 제외한 <br/>배열 가장 오른쪽에 있는 값에 할당한다. 피벗은 동그라미로 표시 하겠다.

![이미지](/programming/img/퀵1.PNG)

<br/>

1. 왼쪽 포인터를 한 셀씩 계속 오른쪼긍로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춘다.

2. 이어서 오른쪽 포인터를 한 셀씩 계속 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춘다.
3. 왼쪽 포인터와 오른쪽 포인터가 가리키고 있는 값을 교환한다.
4. 두 포인터가 가리키는 값이 같거나 왼쪽 포인터가 오른쪽 포인터 바로 오른쪽으로 이동할 때까지 위 과정을 반복한다.
5. 끝으로 왼쪽 포인터가 현재 가리키고 있는 값과 피벗을 교환 한다.

<br/>분할이 끝나면 피벗 왼쪽에 있는 값은 모두 피벗보다 작고, 피벗 오른쪽에 있는 값은 모두 피벗보다 크다고 확신할 수 있다.

<br/>1단계 : 왼쪽 포인터( 현재 0을 가리키고 있음 ) 와 피벗( 값 3 )을 비교한다. 0은 피벗보다 작으므로 다음 단계에서 왼쪽 포인터를 옮긴다.

![이미지](/programming/img/퀵1.PNG)

<br/>2단계 : 왼쪽 포인터를 옮긴다.

왼쪽 포인터(5)와 피벗을 비교한다.

5가 피벗보다 작은가? 그렇지 않으므로 왼쪽 포인터를 멈추고 

다음 단계에서 오른쪽 포인터를 이동시키기 시작한다.

![이미지](/programming/img/퀵3.PNG)

<br/>3단계 : 오른쪽 포인터(6)와 피벗을 비교한다. 피벗보다 큰가? 크므로 다음 단계에서 포인터를 옮긴다.

<br/>4단계 : 오른쪽 포인터를 옮긴다.

오른쪽 포인터(1)와 피벗을 비교한다. 피벗보다 큰가? 그렇지 않으므로 오른쪽 포인터를 멈춘다.

![이미지](/programming/img/퀵3.PNG)

<br/>5단계 : 두 포인터가 모두 멈췄으므로 두 포인터의 값을 교환한다.

![이미지](/programming/img/퀵4.PNG)

![이미지](/programming/img/퀵5.PNG)

<br/>다음 단계에서 다시 왼쪽 포인터를 이동 시킨다.

<br/>6단계 : 왼쪽 포인터를 옮긴다.

왼쪽 포인터(2)와 피벗을 비교한다.

피벗보다 작은가? 작으므로 왼쪽 포인터를 옮긴다.

![이미지](/programming/img/퀵6.PNG)

<br/>7단계 : 왼쪽 포인터를 다음 셀로 옮긴다. 이때 왼쪽과 오른쪽 포인터 모두 같은 값을 가리키고 있다.

<br/>왼쪽 포인터와 피벗을 비교한다.

왼쪽 포인터가 피벗보다 큰 값을 가리키고 있으므로 멈춘다.

이때 왼쪽 포인터가 오른쪽 포인터에 도달 했으므로 포인터 이동을 중지한다.

![이미지](/programming/img/퀵7.PNG)

<br/>8단계 : 분할의 마지막 단계로서 왼쪽 포인터가 가리키고 있는 값과 피벗을 교환 한다.

<br/>배열은 완전히 정렬되지 않았지만 분할은 성공적으로 끝냈다.

즉, 피벗이 숫자 3이었으므로 3보다 작은 모든 수는 3의 왼쪽에, 3보다 큰 모든 수는 3의 오른쪽에 있다. <br/>또한 3이 이제 **배열 내에서 올바른 위치에 있게 됐다.**

![이미지](/programming/img/퀵8.PNG)

<br/><br/>

## 퀵 정렬

분할이 매우 중요하다.

예제로 돌아가 보면 [ 0, 5, 2, 1, 6, 3 ] 으로 시작해서 전체 배열에 대해 한 번의 분할을 수행 했었다

퀵 정렬은 분할로 시작하므로 이미 퀵 정렬 과정을 일부 수행해 본 것이다.

<br/>값 3이 피벗이었다. 

피벗은 올바른 위치에 있으므로 피벗의 왼쪽과 오른쪽을 정렬해야 한다. <br/>어쩌다 보니 피벗 왼쪽은 이미 정렬돼 있지만, 컴퓨터는 아직 모른다. 

<br/>분할이 끝나면 다음으로 피벗 왼쪽에 있는 모든 값을 하나의 배열로 보고 분할 한다.

<br/>현재로서 필요한 부분은 [ 0, 1, 2 ] 부분만 이다. **나머지(3, 6, 5)는 일단 필요 없으니 작성하지 않았다.**

<br/>하위 배열 [ 0, 1, 2 ] 중에서 가장 오른쪽 원소를 피벗으로 하겠다. 즉, 숫자 2다.

<br/>왼쪽과 오른쪽 포인터를 설정한다.

이 하위 배열을 분할할 준비가 됐다.

![이미지](/programming/img/퀵9.PNG)

<br/>9단계 : 왼쪽 포인터(0) 와 피벗(2)을 비교한다.  0은 피벗보다 작으므로 왼쪽 포인터를 옮긴다.

<br/>10단계 : 왼쪽 포인터를 한 셀 오른쪽으로 옮기면 이제 오른쪽 포인터와 같은 값을 가리키게 된다.

왼쪽 포인터와 피벗을 비교한다. 값 1은 피벗보다 작으므로 포인터를 옮긴다.

![이미지](/programming/img/퀵10.PNG)

<br/>11단계 : 왼쪽 포인터를 한 셀 오른쪽으로 옮기면 이제 피벗을 가리키게 된다.

왼쪽 포인터가 가리키는 값이 피벗과 동일하므로 ( 그 값이 바로 피벗이니까!) 왼쪽 포인터를 멈춘다.

![이미지](/programming/img/퀵11.PNG)

<br/>12단계 : 이제 오른쪽 포인터를 동작시킨다. 하지만 오른쪽 포인터의 값(1)이 피벗보다 작으므로 그대로 둔다.

왼쪽 포인터가 오른쪽 포인터를 지나쳤으므로 이번 분할에서는 더 이상 포인터를 이동시키지 않는다.

<br/>13단계 : 마지막 단계로 피벗과 왼쪽 포인터의 값을 교환 한다. 우연히 왼쪽 포인터가 <br/>피벗을 가리키게 됐으므로 피벗 스스로 교환한다. 

<br/>이제 분할이 끝났고 피벗(2)은 올바른 위치에 놓여졌다.

<br/>파란색이 알고리즘을 통해 올바른 위치에 놓여진 것들이다.

<br/>피벗(2) 왼쪽에는 하위 배열인[ 0, 1 ] 이 있고, 오른쪽에는 어떤 하위 배열도 없다. 

<br/>피벗 왼쪽에 있는 하위 배열, 즉 [0, 1]을 재귀적으로 분할 하는 것이다. 

<br/>피벗 오른쪽에는 하위 배열이 없으므로 처리할 필요가 없다. 

![이미지](/programming/img/퀵12.PNG)

<br/>다음 단계에서는 하위 배열인 [ 0, 1 ] 에만 초점을 맞춘다.

<br/>하위 배열인 [ 0, 1 ] 을 분할하기 위해 가장 오른쪽 원소(1)를 피벗으로 한다.

<br/>오른쪽 포인터는 피벗의 한 셀 왼쪽에서 시작하므로 오른쪽 포인터도 0을 가리킬 것이다. 

![이미지](/programming/img/퀵13.PNG)

14단계 : 왼쪽 포인터(0)와 피벗(1)을 비교한다.

피벗보다 작으므로 옮긴다.

![이미지](/programming/img/퀵13.PNG)

<br/>15단계 : 왼쪽 포인터를 한 셀 오른쪽을 옮긴다. 이제 피벗을 가르킨다.

왼쪽 포인터의 값(1)이 피벗보다 작지 않으므로(그 값이 바로 피벗이므로) 왼쪽 포인터를 더 이상 이동하지 않는다.

![이미지](/programming/img/퀵14.PNG)

<br/>16단계 : 오른쪽 포인터와 피벗을 비교한다. 피벗보다 작은 값을 가리키고 있으므로 더 이상 이동하지 않는다. <br/>왼쪽 포인터가 오른쪽 포인터를 지나쳤으므로 이번 분할에서는 더 이상 포인터를 이동시키지 않는다.

<br/>17단계 : 왼쪽 포인터와 피벗을 교환한다. 왼쪽 포인터가 실제 피벗을 가리키고 있으므로 교환해도 변경이 없다. <br/>피벗은 이제 올바른 위치에 있고, 분할도 끝났다.

<br/>다음으로 가장 최근 피벗의 왼쪽에 있는 하위 배열을 분할해야 한다. 현재 이 하위 배열은 단 하나의 원소로 이뤄진 [0] 이다. <br/>원소가 0 또는 1개인 배열은 기저 조건이므로 아무것도 하지 않는다.

<br/>이 원소는 자동으로 올바른 위치에 있다고 간주 한다. 따라서 다음과 같다.

![이미지](/programming/img/퀵15.PNG)

<br/>이제 하위 배열은 정렬 됐으므로 [ 6, 5 ] 에만 초점을 맞추겠다.

<br/>이번 분할에는 가장 오른쪽 원소(5)를 피벗으로 한다. 

분할을 준비하면서 왼쪽과 오른쪽 포인터 모두 6을 가리키도록 할당한다.

![이미지](/programming/img/퀵16.PNG)

<br/>18단계 : 왼쪽 포인터(6) 와 피벗(5) 을 비교한다. 6은 피벗보다 크므로 왼쪽 포인터는 더 이상 움직이지 않는다.

<br/>19단계 : 오른쪽 포인터도 6을 가리키고 있으므로 이론상 왼쪽으로 한 셀 이동해야 한다. <br/>하지만 6의 왼쪽에 더 이상 셀이 없으므로 오른쪽 포인터는 이동을 멈춘다. 

<br/>왼쪽 포인터와 오른쪽 포인터가 만났으므로 이번 분할에서는 더 이상 어떤 포인터도 이동하지 않는다. <br/>즉, 마지막 단계를 수행할 차례다.

<br/>20단계 : 피벗과 왼쪽 포인터의 값을 교환 한다.

<br/>피벗(5)은 이제 다음과 같이 올바른 위치에 놓여 졌다.

![이미지](/programming/img/퀵17.PNG)

<br/>배열 [ 5, 6 ] 의 왼쪽과 오른쪽 하위 배열을 재귀적으로 분할하는 것이다. 

<br/>하위 배열이 없으므로 오른쪽 하위 배열만 분할하면 된다. <br/>5의 오른쪽에 있는 하위 배열은 원소가 하나인 [ 6 ] 이므로 기저 조건을 충족하고, 따라서 아무것도 하지 않는다. <br/>당연히 6은 올바른 위치에 있다. 

![이미지](/programming/img/퀵18.PNG)

<br/><br/>

## 퀵 정렬의 효율성

분할의 효율성을 밝혀야 한다.

두 종류가 잇다.

비교 : 각 값과 피벗을 비교 한다.

교환 : 적절한 때에 왼쪽과 오른쪽 포인터가 가리키고 있는 값을 교환 한다.

<br/>분할마다 원소를 피벗과 비교하므로 최소 N번 비교한다.

![이미지](/programming/img/퀵19.PNG)

<br/><br/>

## 퀵 셀렉트

수많은 시험 점수가 있을  때 25번째 백분위수나 중간 점수를 알고 싶을때 도움이 될것이다.

퀵 셀렉트도 퀵정렬처럼 분할에 기반하며, 퀵 정렬과 이진 검색의 하이브리드 정도로 생각 할수 있다.

<br/>값이 8개인 배열이 있을 때, 이 배열 내에서 두 번째로 작은 값을 찾고 싶다고 하자.

<br/>1. 먼저 전체 배열을 분할 한다.

![이미지](/programming/img/퀵20.PNG)

<br/> 피벗은 올바른 위치에 있고, 두 번째로 작은 값을 찾고 있다.

<br/>왼쪽 어딘가에 있음을 안다. 

<br/>왼쪽 하위 배열에만 집중 할 수 있다. 이점에서 퀵 셀렉트와 이진 검색이 유사하다. <br/>즉, 배열을 계속 반으로 나누되 찾고 잇는 값이 있을 반쪽에만 집중한다.

<br/>다음으로 피벗 왼쪽에 있는 하위 배열을 분할 한다.

<br/>이 하위 배열의 새 피벗을 세 번째 셀로 하자.

<br/>이제 세 번째 셀의 값이 올바른 위치에 있게 됐고, 이 값이 배열에서 세 번째로 작은 값임을 안다.

<br/>두 번째로 작은 값은 이 피벗의 왼쪽 어딘가에 있다.

<br/>이제 세 번째 셀의 왼쪾에 있는 하위 배열을 분할 한다.

<br/>분할이 끝나면 가장 작은 값과 두 번째로 작은 값이 배열 내에서 올바른 위치에 있게 된다.

<br/>자신 있게 이 값이 전체 배열에서 두 번째로 작은 값이라고 말할 수 있다. <br/>퀵 셀렉트의 훌륭한 점 중 하나는 **전체 배열을 정렬하지 않고도** 올바른 값을 찾을 수 있다는 것이다.

<br/>

### 마무리

퀵 정렬과 퀵 셀렉트 알고리즘은 골치 아픈 문제를 푸는 멋지고 효율적인 해결법을 제시하는 재귀 알고리즘이다.


<br/><br/>

>**Reference**
<br/>제이 웬그로우 지음, 심지현 옮김 **『**누구나 자료구조와 알고리즘**』**, 길벗. <br/>
엔지니어대한민국 - https://www.youtube.com/watch?v=YbsQiiubO74