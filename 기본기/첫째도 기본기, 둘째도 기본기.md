## :scroll: 첫째도 기본기, 둘째도 기본기
>'손흥민이 변함없이 강조한 것은 첫째도 기본기, 둘째도 기본기, 세째도 기본기였다'<br/>
>### '객체지향이 무엇인지를 확실히 알자' 는 <br/>
>"객체지향이란 ~~ 이다" 가 아닌, 객체지향적으로 코딩할 수 있도록 하는 것이다.
---




<br/>

## 목차

21. 개발할때 순서
22. 프로퍼티
23. instanceof
24. keySet()
25. 메서드 레퍼런스
26. JDBC
27. 프로퍼티 접근방식
28. API
29. 스프링 컨테이너와 빈
30. 영속하다
31. 스프링 다형성
32. 인젝션
33. 커스터마이징
34. 레퍼런스란?
35. 배열에 저장 공간이 부족할때
36. 렌더링이란?
37. Integer.parseInt(request.getParameter("age"))
38. getRequestDispatcher()
39. 절대 경로, 상대 경로
40. json
41. getParameterNames() 제발
42. @RequestParam
43. 요청 파라미터란? (중요)
44. input 태그 name=”name”
45. parameter
46. Optional<>
47. findAny(), findAll()
48. ifPresent()
49. Optional.ofNullable, of
50. 생성자 주입
51. 스프링 컨테이너 하는 일은??
52. 스프링 빈의 이벤트 라이프사이클
53. getBeanDefinitionNames()
54. @RequestMapping() 
55. AnnotationConfigApplicationContext
56. getBean()
57. getRole()
58. ROLE_APPLICATION
59. ROLE_INFRASTRUCTURE
60. @NonNull
61. @Data
62. @RequiredArgsConstructor
63. 테스트 코드에서 Optional 꺼낼때는 get()해야 꺼낼수 있다.
64. @Service -> 이걸 해놔야 맴버컨트롤러에서 여길 찾아서 @Autowired 할수 있는 것이다.
65. isEmpty()
66. invalidate()란?
67. @EqualsAndHashCode
68. @NoArgsConstructor, @AllArgsConstructor
69. DB - Connection
70. 배열에 있는 요소를 보려면 Arrays.toString() 메서드를 사용해야 한다.
71. ArrayList 배열을 구현하는 방법
72. Collection과 Collections 차이점
73. for()문 으로 무한 루프 돌리기.

<br/>

---



## 상세 설명.

---

<br/><br/>

21번.


# 개발할때 순서

### 실제로 개발하면

1. 요청 파라미터를 받는다.
2. 객체를 만든다. 
3. 객체에 값을 넣어준다.

```java
// 요청 파라미터를 받는다.
@RequestParam String username;
@RequestParam int age;

// 객체를 만든다. 
HelloData data = new HelloData();

// 객체에 값을 넣어준다.
data.setUsername(username);
data.setAge(age);
```

---

<br/><br/>

22번.


# 프로퍼티

### 프로퍼티

getXxx 첫 글자가 대문자 에서 → get을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

setXxx 첫 글자가 대문자 에서 → set을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

객체에 getUsername() , setUsername() 메서드가 있으면, 이 객체는 username 이라는 프로퍼티를 가지고 있다.

username 프로퍼티의 값을 변경하면 setUsername() 이 호출되고, 조회하면 getUsername() 이 호출된다.

```java
class HelloData {
	getUsername();
	setUsername();
}
```



---

<br/><br/>

23번.


# **instanceof**

예제 1

```java
class Simple1{  
	 public static void main(String args[]) {  

			 Simple1 s=new Simple1();  
			 System.out.println(s instanceof Simple1); // true  
	 }  
}

출력값.
true
```

예제 2.

```java
class Animal{ }  

 
class Dog1 extends Animal{  
	 public static void main(String args[]) {  

			 Dog1 d=new Dog1();  
			 System.out.println(d instanceof Animal)
	 }  
}

출력값.
true  
```

예제 3.

```java
class Dog2{  
	 public static void main(String args[]) {  
			
		  Dog2 d=null;  
		  System.out.println(d instanceof Dog2);//false  
	 }  
}

출력값.
false  
```


---

<br/><br/>

24번.


• keySet() 메서드는 key의 값만 출력



---

<br/><br/>

25번.


# 메서드 레퍼런스

메소드 레퍼런스란??

첫번째 추천 사이트.

*Hanumoka, IT Blog - https://www.hanumoka.net/2019/01/30/java-20190130-java8-system-out-println/*

두번째 추천 사이트.

*https://myhappyman.tistory.com/65*

![이미지](/programming/img/스5.PNG)

getBan() 메서드를 보면 작성 되어 있다.
```java
int getBan() {
		return ban;
}
```


---

<br/><br/>

26번.


JDBC



---

<br/><br/>

27번.



겟터 셋터, 자비빈 표준 방식 셋다 부를수 있다. (제목까지 포함)

 private 이니깐 외부에서 바로 못꺼내 오니, 메서드를 통해서 꺼내 오는 방식을 말한다.


---

<br/><br/>

28번.


# API

API 방식은?

객체를 반환 하는 것이다.

예를 들어, @ResponseBody 를 풀어 적으면 이렇다.

```java
@Controller
public class HelloController {
	
		@GetMapping("hello-api")
    @ResponseBody
    public String helloApi(@RequestParam("name") String name) {
				Hello hello = new Hello();
				hello.setName = new Hello();	        
				return "hello";
    }

		static class Hello {
			private String name;

			public String getName() {
					return name;
			}

			public void setName(String name) {
					this.name = name;
			}
		}
}
```


---

<br/><br/>

29번.


# **스프링 컨테이너와 빈**

### 스프링 컨테이너

스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 

생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다. 

### 여기서 말하는 자바 객체를 스프링에서는 빈(Bean)이라고 부른다.

개발자는 new 연산자, 인터페이스 호출 방식으로 객체를 생성하고 소멸 시킬 수 있는데, 

스프링 컨테이너가 이 역할을 대신 한다. 

즉, 제어 흐름을 외부에서 관리하는 것이다.

스프링 컨테이너 안에 스프링 빈 저장소가 있고, 그 안에 빈이 들어있다고 생각하시면 됩니다.

![이미지](/programming/img/스6.PNG)


---

<br/><br/>

30번.


영구 저장 하다란 뜻이다.



---

<br/><br/>

31번.



# 스프링 다형성

![이미지](/programming/img/스8.PNG)

이렇게도 가능하다. 

![이미지](/programming/img/스9.PNG)

`interface MemberRepository` 이기 때문에 다형성을 이용해 이렇게 받는 것도 가능하다.

이렇게도 다형성에 의해 가능한 것이다. (빨간줄은 무시하기.)


---

<br/><br/>

32번.


주입이라는 뜻



---

<br/><br/>

33번.


# 커스터마이징

쉽게 말하면 특정 url 주소에 접속 할 때 접근 제한을 설정 하는 방법이다.



---

<br/><br/>

34번.


# 레퍼런스란??

참조를 뜻한다.

## **레퍼런스 변수란?**

변수 객체의 위치를 가리킨다.



---

<br/><br/>

35번.


# 배열에 저장 공간이 부족할때

배열에 저장 공간이 부족해서 새로운 배열을 만들때 

어떻게 해야되나요? 물어보면 

첫번째. 더 큰 배열을 만들고

두번째. 기존 내용을 복사하고

세번째. 참조를 변경해야 됩니다.



---

<br/><br/>

36번.


# 렌더링이란?

만약 클라이언트가 별 사진을 보고 싶다고 가정하자.

그러면 웹 브라우저에서 서버로 요청을 한 다음에 서버가 응답을 보낼 때

HTML로 변환해서 웹 브라우저로 보내 주는 것이다.

그러면 웹 브라우저가 렌더링을 해서 별 사진을 볼 수 있게 되는 것이다.



---


<br/><br/>


37번.


# `Integer.*parseInt*(request.getParameter("age"))`

```java
int age = Integer.parseInt(request.getParameter("age"));
```

문제는 `request.getParameter()` 응답 결과는 항상 ‘문자’ 인 것이다.

그리하여 `Integer.parseInt()` 으로 변환하여 숫자로 변환 해야 되는 것이다.



---

<br/><br/>

38번.


# `getRequestDispatcher`()

```java
request.getRequestDispatcher()
```

`getRequestDispatcher()` 는 ‘컨트롤러’에서 ‘뷰’ 로 이동할 때 사용 하는 것이다.

`forward()` 이걸 사용하면 진짜로 서블릿에서 jsp로 호출할 수 있게 되는 것이다.

이렇게 하면 jsp를 찾아서 넘어가게 되는 것이다.
```java
// 여기로 제어권을 보내는 것이다.
String viewPath = "/WEB-INF/views/new-form.jsp";

RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
```


---

<br/><br/>

39번.


# 절대 경로, 상대 경로

### ‘절대 경로’ : "C:\Users\UserID\Desktop\test.txt" → **최상위 /를 포함하고 있다.**

시작 지점부터 목표 지점 까지의 어느 누가 봐도 절대적으로 이곳을 가리킬 수 있는 곳입니다.

만약, <form action="save" method="post"> 부분이 

‘/save’ 로 한다면 localhost:8080/save 이렇게 들어가는 것이다.

### ‘상대 경로’ : “test.txt” → **최상위 /를 거치지 않고도 이동이 가능하다.**

‘/’이 없이 그냥 ‘save’ 되어 있다면 ‘상대 경로’ 인 것이다.

그러면 localhost:8080/servlet-mvc/members/new-form 로 시작하여

<form action="save" method="post"> 했다면 

localhost:8080/servlet-mvc/members/new-form save 이렇게 끝에만 변하는 것이다.



---

<br/><br/>

40번.



# json

키에 허용되는 타입이 문자열 뿐이라는 것이었다


---

<br/><br/>

41번.



# getParameterNames() 제발

제발 제대로 알자.

getParameterNames( ) 는 username 이랑 age를 뜻하는 것이다.

‘kim’, ‘바보’, ‘석’ 이런거 아니다 !!!!!!!!!!!!!!!!!!!!

![이미지](/programming/img/스10.PNG)


---

<br/><br/>

42번.


# @RequestParam

### @RequestParam 이 있으면 명확하게 요청 파리미터에서 데이터를 
읽는 다는 것을 알 수 있다.



---

<br/><br/>

43번.

# 요청 파라미터란? (중요)

GET에 쿼리 스트링 오는 것이다. 또는 HTML POST 방식 오는 것이다.

이 두개인 경우에만 

`@RequestParam`, `@ModelAttribute` 사용하는 것이다.

이 밖은 전부 데이터를 직접 꺼내야 하는 것이다.

# 요청 파라미터 vs HTTP 메시지 바디

### 요청 파라미터를 조회 할때는 이걸 사용: `@RequestParam` , `@ModelAttribute`

### HTTP 메시지 바디를 직접 조회 할때는 이걸 사용: `@RequestBody`




---

<br/><br/>

44번.


# input 태그 name=”name”

태그 안에 있는 name="name” 인 “name”이! ‘키’ 가 되는 것이다.

그리고 자연스럽게 Value인 ‘spring’은 내부적으로 어딘가에 저장된다.

그리하여 서버에 넘어가게 되는 것이다.

### 밑에 사진이 ‘키’ 이다.

![이미지](/programming/img/스11.PNG)

프로퍼티 바인딩



---

<br/><br/>

45번.


# `parameter`

입력값을 저장하는 변수.

예를들어 전화를 거는 메소드를 만든다고 할 때, 
우리는 전화를 걸 대상에 대한 입력값이 필요합니다. 
이러한 입력값을 기억해두는 변수가 바로 **파라미터** 입니다. 
이러한 **파라미터**는 메소드의 구조상에서 소괄호 사이에 위치합니다.



---

<br/><br/>

46번.


# `Optional<>`

### Optional 이란?

findById, findByName 에서 찾아온 값이 null 일 수도 있다.

그러므로 null 을 처리하는 방법으로 Optional 을 감싸서 사용하는 것이다. 

```java
public interface MemberRepository {
    Member save(Member member); // 회원이 저장소에 저장이 되는 것이다.

    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);

    // 지금까지 저장된 모든 리스트를 반환 해주는 것이다.
    List<Member> findAll();
}
```

### 테스트 코드 예시.

```java
    @Test
    public void save() { // 저장이 잘 되는지 테스트 해보기.
        Member member = new Member();
        member.setName("spring"); // 이름을 세팅 해준다.

        repository.save(member); // 저장한다.

        // 내가 넣은게 제대로 들어갔나? 확인
        // 마지막 .get()을 하는 이유는 반환 타입이 Optional이라서 꺼낼때는 
				// .get()해야 꺼낼수 있다.
        Member result = repository.findById(member.getId()).get();
```

### Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다

스프링 빈이 없으면, `Optional.empty` 라는걸로 넣어 준다. 

반대로 값이 있으면 `Optional`안에 값이 감싸져 있을 것이다.



---

<br/><br/>

47번.


# `findAny(), findAll`()

## findAny()

하나라도 찾으면 반환.

## findAll()

지금까지 저장된 모든 리스트를 반환 해주는 것이다.
```java
public interface MemberRepository {
    Member save(Member member); // 회원이 저장소에 저장이 되는 것이다.

    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);

    // 지금까지 저장된 모든 리스트를 반환 해주는 것이다.
    List<Member> findAll();
}
```


---

<br/><br/>

48번.


# `ifPresent`()

**Optional 객체가 감싸고 있는 데이터가 존재할 경우에만** 

**실행될 로직을 함수형 인자로 넘길 수 있습니다.**

이런 코드를 줄일 수 있다

```java
Optional isPresent != null;
```

### `ifPresent()` 메서드는 Optional 객체가 값을 담고 있을 때, 처리 한다.

### 예시로 본다면 result 값에 데이터가 있으면, 동작을 하게 하는 메서드 이다.

조건 : result 가 Optional 이기 때문에 가능한 것이다.

밑에 코드를 본다면 현재 새로운 member 객체가 들어와 

findByName으로 안에 똑같은 객체가 있는지 찾는 것이다. 

있으면 result로 반환. 없으면 null.


```java
// 전체적으로 설명하면, 
// findByName 해서 그 결과는 Optional<Member> 니깐 바로 
// Optional<Member> (.) ifPresent()로 연결 할 수 있는 것이다

memberRepository.findByName(member.getName())
                        .ifPresent(m -> {
                            throw new IllegalStateException("이미 존재하는 회원입니다.");
                        });
```

---

<br/><br/>

49번.


# Optional.ofNullable, **of**

### Optional 에서 제공하는

**of**와 **ofNullable** 매서드를 사용합니다. 

### 둘의 차이점은

of는 인자로서 null값을 받지 않는다는 것이고 

ofNullable은 null값을 허용한다는 것입니다.



---

<br/><br/>

50번.


# 생성자 주입

### 생성자 주입

생성자에 @Autowired 라고 되어 있다. 뭐나면??

스프링이 @Component 가 있네 하면서 `OrderServiceImpl` 클래스를 등록을 할때

<br/>등록이 되면 생성자를 호출해야 되는 것이다.

그러면 생성자를 호출할때 “@Autowired 가 있네” 하고 스프링 컨테이너에서 

<br/>스프링 빈을 꺼낸다. `MemberRepository` 랑 `DiscountPolicy` 를 딱 `OrderServiceImpl` 에 주입 

해주는 것이다.

![이미지](/programming/img/스12.PNG)

### 중요! 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다

만약 어떤 값을 세팅하고 “이것은 더 이상 값을 변경하면 안돼” 한다면 생성자에 값을 넣고, 
set메서드 같은걸 만들지 않으면 된다. <br/>(불변 == 절대 변하지 않는것)

<br/>

### 참고: 어쩌면 당연한 이야기이지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다. <br/>스프링 빈이 아닌 Member 같은 클래스에서 @Autowired 코드를 적용해도 아무 기능도 동작하지 않는다.




---

<br/><br/>

51번.


# 스프링 컨테이너

하는 일은??

크게 두가지 하는 일이 있다.

1. 스프링 빈을 등록하는 것.
2. 연관 관계를 자동으로 주입한다.



---

<br/><br/>

52번.


# 스프링 빈의 이벤트 라이프사이클

스프링 빈의 이벤트 라이프사이클은 이렇게 된다.

1. 스프링 컨테이너 생성 
2. 스프링 빈 생성 
3. 의존관계 주입 
4. 초기화 콜백 
5. 사용 
6. 소멸전 콜백 
7. 스프링 종료

초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출

소멸전 콜백: 빈이 소멸되기 직전에 호출

### 객체의 생성과 초기화를 분리하자.

생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 

반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 

무거운 동작을 수행한다.

따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 

객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 

물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 

생성자에서 한번에 다 처리하는게 더 나을 수 있다.



---

<br/><br/>

53번.


# getBeanDefinitionNames()

- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.



---

<br/><br/>

54번.



# `@RequestMapping()`

@RequestMapping("/basic/items") 설명.

클라이언트에서 "/basic/items" 로 url을 요청하는 모든건 여기 클래스에서 받게 되는 것이다.

그리고, 여기 클래스에 있는 모든 메서드들은 url이 "/basic/items" 포함 되어 있는 것이다.

그리하여 items() 메서드 같은 경우는 생략 된것이라고 생각하면 된다.

item() 메서드 같은 경우는 /basic/items/{itemId} 경로가 되는 것이다.


---

<br/><br/>

55번.


# AnnotationConfigApplicationContext

이 클래스는 ApplicationContext 인터페이스의 구현체이다

추가로 위에 코드처럼 이렇게 AppConfig.class 를 넘기면 AppConfig클래스도 빈에 등록이 된다.

```java
ApplicationContext applicationContext
                = new AnnotationConfigApplicationContext(AppConfig.class);
```

---

<br/><br/>

56번.


# getBean()

- ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회한다.



---

<br/><br/>

57번.


# getRole()

- 스프링이 내부에서 사용하는 빈은 getRole() 로 구분할 수 있다.
    - ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈
    - ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈



---

<br/><br/>

58번.


# ROLE_APPLICATION

- ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈

  ROLE_APPLICATION 란??

  스프링이 내부에서 뭔가를 하기 위해서 등록한게 아니라,

  내가 애플리케이션을 개발하기 위해서 등록한 빈이라고 생각하면 되는 것이다.


---

<br/><br/>

59번.


# ROLE_INFRASTRUCTURE

- ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈



---

<br/><br/>

60번.


# @NonNull

Null 체크

@NonNull 어노테이션을 변수에 붙이면 자동으로 null 체크를 해줍니다.

즉, 해당 변수가 null로 넘어온 경우, NullPointerException 예외를 일으켜 줍니다.



---

<br/><br/>

61번.


# @Data

@Getter 와 @Setter는 각각 접근자와 설정자 메소드를 작성해주는 
Lombok 어노테이션으로 유명하다.



---

<br/><br/>

62번.


# @RequiredArgsConstructor

@NotNull 어노테이션이나 final 키워드를 사용하고 있는 

속성들만으로 이루어진 생성자를 자동으로 만들어 준다.


<br/>

```java

@RequiredArgsConstructor // 사용시 final 이 붙은 클래스를 생성자 주입 과정을 자동 생성 해주는 것이다.
public class BasicItemController {

    private final ItemRepository itemRepository;

/*
위에 있는 @RequiredArgsConstructor 가 대신 이 과정을 해준다.

    @Autowired
    public BasicItemController(ItemRepository itemRepository) {
        this.itemRepository = itemRepository;
    }
*/

```



---

<br/><br/>

63번.

테스트 코드에서 Optional 꺼낼때는 get()해야 꺼낼수 있다.

---

<br/><br/>

64번.


@Service -> 이걸 해놔야 맴버컨트롤러에서 여길 찾아서 @Autowired 할수 있는 것이다.



---

<br/><br/>

65번.

String이 null인지 empty인지 확인할 수 있습니다. 

isEmpty()는 문자열이 ""처럼 비어있을 때 true를 리턴합니다.

```java

public class checkIfStringEmptyOrNull {

    public static void main(String[] args) {

        String str1 = null;
        String str2 = "";
        String str3 = "a1";

        System.out.println("str1, empty or null ? " + isEmptyOrNull(str1));
        System.out.println("str2, empty or null ? " + isEmptyOrNull(str2));
        System.out.println("str3, empty or null ? " + isEmptyOrNull(str3));
    }

    private static boolean isEmptyOrNull(String str) {
        if (str != null && !str.isEmpty()) {
            return false;
        } else {
            return true;
        }
    }
}

```


---

<br/><br/>

66번.


invalidate()란? 세션이랑 그안에 데이터까지 싹다 지운다.



---

<br/><br/>

67번.


### @EqualsAndHashCode 란

equals, hashCode 자동 생성
자바 빈을 만들 때 equals와 hashCode 메소드를 자주 오버라이딩 한다

@EqualsAndHashCode 어노테이션을 사용하면 자동으로 이 메소드를 생성할 수 있다.

callSuper 속성을 통해 eqauls와 hashCode 메소드 자동 생성 시 부모 클래스의 필드까지 감안할지의 여부를 설정할 수 있다.

<br/>

IpPort 클래스

```java

@Getter
@EqualsAndHashCode
public class IpPort {

    // 여기는 "127.0.0.1.8080" 포트가 문자로 들어온다.
    // 이걸 숫자로 바꾸고 싶은 것이다.
    // 그리고 반대로 숫자로 들어오면 문자로 바꾸고 싶은 것이다.

    private String ip;
    private int port;

    public IpPort(String ip, int port) {
        this.ip = ip;
        this.port = port;
    }
}

```

<br/>

StringToIpPortConverter 클래스

```java

@Slf4j
public class StringToIpPortConverter implements Converter<String, IpPort> {

    @Override
    public IpPort convert(String source) {

        // "127.0.0.1:8080" 이라는 문자가 들어올 것이다.
        log.info("convert source={}", source);
        String[] split = source.split(":");// ":" 이걸 통해서 잘라 주는 것이다.

        // 즉, "127.0.0.1:8080" 이걸
        // ":" 기준으로 앞쪽 127.0.0.1 은 문자로 사용 할것이고,
        // ":" 기준으로 뒤쪽 8080 은 숫자로 사용 할 것이라고 말하는 것이다.
        String ip = split[0];
        int port = Integer.parseInt(split[1]);

        return new IpPort(ip, port); // IpPort 객체 생성
    }
}
```

<br/>

테스트 코드

이렇게 되는 이유는 주석으로 적어 놨다.

```java
// result 객체랑 new IpPort(```) 객체랑 참조값이 달라도 상관없다.
// 안에 있는 ip랑 port 라는 데이터가 다 같으면 true가 나오는 것이다.
Assertions.assertThat(result).isEqualTo(new IpPort("127.0.0.1", 8080));
```


<br/>

### hashCode() 메서드 란?

Java의 Hash Code란, 객체를 식별할 수 있는 유니크한 값을 말한다. 

메모리에 생성된 객체의 주소를 정수로 변환한 형태를 얘기하는데, 이 정수는 중복되지 않는 고유의 값입니다.

Object Class에서 hashCode()를 가지고 있어서 객체를 생성하여 확인해보면 Hash Code 값을 확인 할 수 있다.

<br/>

처음에 hashCode() 메소드의 결과 값이 동일한지를 확인한다. 

그런다음 Hash Code 값이 다르면 서로 다른 객체로 판단하고, Hash Code 값이 같으면 equals()메소드로 다시 비교한다. 

두 조건이 모두 맞아야 동일한 객체로 판단한다.
	
	
<br/>	
	
### 자바의 데이터 타입은 크게 2가지로 나눌수 있다.

- primitive(기본형 타입)
- object

primitive 타입은 byte, short, int, long 과 같이 size 가 정해져 있는 값이다.

object 타입은 Byte, Short, Integer, Long, Class 과 같이 주소값을 참조하는 형태다.
	

<br/>

int number = Integer.parseInt("123");

Integer number = Integer.valueOf("123");

두개의 차이점은 primitive 으로 리턴할 것인지,

object 타입으로 리턴할 것인지 차이가 있다.

<br/>
	
```java

int i = Integer.parseInt("String value");

```

valueOf 는 결국 parseInt 를 호출하는 형태이다.

문자열을 변환할 때 객체로 받아서 사용하느냐, 기본 자료형으로 받아서 사용하느냐의 차이다.
	
	
---

<br/><br/>

68번.


@NoArgsConstructor - 기본 생성자를 생성해준다, 파라미터가 없는 기본 생성자를 생성.

@AllArgsConstructor - 전체 변수를 생성하는 생성자를 만들어준다, 모든 필드 값을 파라미터로 받는 생성자를 만든다.

@RequiredArgsConstructor - final 변수, Notnull 표시가 된 변수처럼 필수적인 정보를 세팅하는 생성자를 만들어준다.

	
```java
User user1 = new User(); // @NoArgsConstructor
User user2 = new User("user2", "1234"); // @RequiredArgsConstructor
User user3 = new User(1L, "user3", "1234", null); // @AllArgsConstructor
```



---

<br/><br/>

69번.


Connection


DB를 사용하기 위해 DB와 애플리케이션 간 통신을 할 수 있는 수단.


DB Connection은 Database Driver와 Database 연결 정보를 담은 URL이 필요.


Java의 DB Connection은 JDBC를 주로 이용하는데, URL 타입을 사용함



---

<br/><br/>

70번.

배열에 있는 요소를 보려면 Arrays.toString() 메서드를 사용해야 한다. 사용자 정의 클래스 객체의 배열이 있는 경우 사용자 정의 클래스에도 재정의된 toString() 메서드가 있어야 한다. 이렇게 하면 클래스 속성이 올바르게 출력 된다.

```java
System.out.println("Student Array: " + Arrays.toString(studentArr));
System.out.println("Intger Array: " + Arrays.toString(intArr));
System.out.println("Double Array: " + Arrays.toString(doubleArr));
System.out.println("String Array: " + Arrays.toString(stringArr));
```



---

<br/><br/>

71번.


ArrayList 배열을 구현하는 방법


```java
public class ddd {
    public static void main(String[] args) {

        //ArrayList<Integer> myGraph = new ArrayList<Integer>();

        ArrayList<Integer>[] arr = new ArrayList[100];

        for(int i = 0; i < 100; i++) {
            arr[i] = new ArrayList<Integer>();
        }

    }
}
```



---

<br/><br/>

72번.

Collection과 Collections 차이점.

## Collection은 인터페이스 이다.

Collection Framework라고 하는 계층(hierarchy)의 최상위 인터페이스 = 컨테이너 객체라고도 불린다.

Collection 인터페이스를 Set, List, Queue 인터페이스가 구현

ArrayList 클래스도 Collection 인터페이스 -> List 인터페이스 -> ArrayList 클래스 순서로 구현되어 잇다.

Map은 단순히 값을 배열로 저장하는 List, Set과 다르게 키, 값으로 저장을 하기 때문에 Collection 인터페이스를 구현하고 있지 않고, 프레임워크에 같이 정의되어 있다.


<br/>

## Collections는 클래스 이다.

배열을 정렬할 때 Collections.sort()를 사용하는데, 

이것을 할 수 있는 이유도 sort()가 List 인터페이스를 사용한 객체를 매개변수로 받고 있다. 

이것만 보더라도 Collections 클래스를 Collection 인터페이스와 완전 떼어놓고 생각할 수 없다. 

List 인터페이스는 Collection 인터페이스를 구현했으니깐. 

<br/>

바보 같이 생각했던 부분

```java
 int[] data = new int[50];
 Arrays.sort(data, 0, 10); // 가능

 ArrayList<Integer> myGraph = new ArrayList<Integer>();
 Collections.sort(myGraph); // 가능

 Collections.sort(data); // 불가능
 Arrays.sort(myGraph, 0, 10); // 불가능

 // 이유는? data는 배열 선언이고, myGraph는 컬랙션이기 이기 때문


```

---

<br/><br/>

73번.


for()문 으로 무한 루프 돌리기.

### <무한LOOP (무한루프)>

for(;;){ }, while(true){ }


---

<br/><br/>

74번.






---

<br/><br/>

75번.






---

<br/><br/>

76번.






---

<br/><br/>

77번.






---

<br/><br/>

78번.






---

<br/><br/>

79번.






---

<br/><br/>

80번.






---

<br/><br/>

81번.






---

<br/><br/>

82번.






---

<br/><br/>

83번.






---

<br/><br/>

84번.






---

<br/><br/>

85번.






---

<br/><br/>

86번.






---

<br/><br/>

87번.






---

<br/><br/>

88번.






---

<br/><br/>

89번.






---

<br/><br/>

90번.






---

<br/><br/>

91번.






---

<br/><br/>

92번.






---

<br/><br/>

93번.






---

<br/><br/>

94번.












