## :scroll: 첫째도 기본기, 둘째도 기본기
>'손흥민이 변함없이 강조한 것은 첫째도 기본기, 둘째도 기본기, 세째도 기본기였다'<br/>
>### '객체지향이 무엇인지를 확실히 알자' 는 <br/>
>"객체지향이란 ~~ 이다" 가 아닌, 객체지향적으로 코딩할 수 있도록 하는 것이다.
---

<br/>

### 빠르게 알아보고 공부해야 될 목록
- 컴파일 에러, 런타임 에러 차이.
- 예외 상속 관계 다시 확인 IllegalArgumentException, UserException, Exception
- 파일 업로드, 다운로드 다시 반복하기.



<br/>

## 목차

1. Map
2. HashMap
3. static 페이지
4. 인터페이스
5. 싱글톤 패턴
6. Arrays.asList
7. enum이란?
8. public Order(int a, int b, int c,)
9. final
10. Collection은 인터페이스, Collections는 클래스 
11. static, static() 메서드
12. equals와 == 의 차이점
13. ... 이란?
14. List의 특징
15. paralleXXX()
16. getClass()
17. hasNext(), next()
18. length 와 length() 그리고 size()
19. 아규먼트
20. null ≠ “”;
21. 개발할때 순서
22. 프로퍼티
23. instanceof
24. keySet()
25. 메서드 레퍼런스
26. JDBC
27. 프로퍼티 접근방식
28. API
29. 스프링 컨테이너와 빈
30. 영속하다
31. 스프링 다형성
32. 인젝션
33. 커스터마이징
34. 레퍼런스란?
35. 배열에 저장 공간이 부족할때
36. 렌더링이란?
37. Integer.parseInt(request.getParameter("age"))
38. getRequestDispatcher()
39. 절대 경로, 상대 경로
40. json
41. getParameterNames() 제발
42. @RequestParam
43. 요청 파라미터란? (중요)
44. input 태그 name=”name”
45. parameter
46. Optional<>
47. findAny(), findAll()
48. ifPresent()
49. Optional.ofNullable, of
50. 생성자 주입
51. 스프링 컨테이너 하는 일은??
52. 스프링 빈의 이벤트 라이프사이클
53. getBeanDefinitionNames()
54. @RequestMapping() 
55. AnnotationConfigApplicationContext
56. getBean()
57. getRole()
58. ROLE_APPLICATION
59. ROLE_INFRASTRUCTURE
60. @NonNull
61. @Data
62. @RequiredArgsConstructor
63. 테스트 코드에서 Optional 꺼낼때는 get()해야 꺼낼수 있다.
64. @Service -> 이걸 해놔야 맴버컨트롤러에서 여길 찾아서 @Autowired 할수 있는 것이다.
65. isEmpty()
66. invalidate()란?
67. @EqualsAndHashCode



<br/>

---



## 상세 설명.


1번.

![이미지](/programming/img/기.PNG)

**맵이라는 것은 키(Key)와 값(Value) 두 쌍으로 데이터를 보관하는 자료구조 이**다.

**값은 중복된 값이어도 상관이 없다.**

## Map은 <열쇠, 물건> 이라고 생각하자

상점에 열쇠랑 물건을 둘다 맡기는 것이다.
위 예시로 member1 저장 될때 마다 어떤 모양인가?
  -- store 장부--
 key            value
  1             0x100 -> "휴대폰 클래스"
  2             0x200 -> "컴퓨터 클래스"
  3             0x300 -> "냉장고 클래스"

```java
private static Map<Long, Member> store = new HashMap<>();
```

위에 이 코드에서 Map<Long, Member> 는 결국 <키, 벨류> 이므로

store.get(3L).getName(); 이렇게 하여 값을 가져 올수 있다.

### 위 코드를 반대로 한다면??

Map<Member, Long> 한다면 0x100을 '키' 값으로 넣고 '1'을 벨류값으로 받을 것이다.

---

<br/><br/>

2번.

# HashMap

여기서 키와 값은 모두 객체입니다.

### 키는 중복이 되지 않지만 값은 중복이 될 수 있다

만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대치 된다. 

HashMap은 이름 그대로 해싱을 사용하기 때문에 많은 양의 데이터를 검색하는 데 있어서 뛰어난 성능을 보인다.

---

<br/><br/>

3번.

# static 페이지

변하지 않는 페이지 즉, 내가 적은걸 그대로 페이지에 응답을 주는것. 

(파일을 그냥 던져 준것 프로그래밍이 아닌것.)

이렇게 만들었다면

![이미지](/programming/img/스.PNG)

실행창에 뒤에 .html 까지 하면 출력이 된다.

![이미지](/programming/img/스2.PNG)

---

<br/><br/>

4번.

# 인터페이스

인터페이스 끼리들은 상속 받는다고 표현한다.

### 인터페이스가 인터페이스를 받을때는 `implements` 가 아니고,

### `extends` 를 사용하는 것이다.

부모클래스를 상속받은 자식클래스에서는 부모클래스의 모든 메서드를 그대로 사용할 수 있다

인터페이스는 미구현된설계서(니가 구현해라) 및 강제성(임플리먼트시 무조껀 작성해라) 및 나중에 팀들이랑 표준으로도 메소드만들기좋아서 쓰는데 

결국

서비스를 인터페이스로 만들엇으니 impl에서 내가 이제 임플리먼트해서 강제로 구현하는거에요


---

<br/><br/>

5번.

# 싱글톤 패턴

싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 

이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 

조회 할땐 이렇게 사용하면 되는 것이다.

```java
package hello.core.singleton;

import org.junit.jupiter.api.Test;

public class SingletonService {

    //자기 자신을 내부에 private으로 하나 가지고 있는데 static 이므로,
    //클래스 레벨에 딱 하나만 존재하게 된다.
    //static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    public static SingletonService getInstance() {
        return instance;
    }

    private SingletonService() {

    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }

}
```

결국 하나의 bean이라는 놈한테 다른 애들이 먼짓을 하게 되는 것이다.

A도 어떤 bean한테 먼 짓하고, B도 bean한테 먼 짓하고 

결국 이용하는 애는 A, B에서 각각 new 객체 해서 생성된 애가 아니라

스프링이 그냥 첨에 만든 객체 하나에 A, B가 이용하게 대는 것이다. 

이걸 싱글톤패턴이라고 한다. 

하나의 객체를 생성해서 그 한 객체로 모든 애들이 돌려 쓰는 것.


---

<br/><br/>

6번.

# **Arrays.asList**

Array(배열)을 List로 변경할때 사용한다.

asList()를 사용해서 객체를 만들때 새로운 배열 객체를 만드는 것이 아니라,

**원본배열의 주소값**을 참조한다.

asList()를 사용해서 내용을 수정하면 원본 배열도 함께 바뀌게 됨

Arrays.asList()로 만든 List에 새로운 원소를 추가하거나 삭제는 할 수 없다.

### **2. 원소를 추가/삭제 할 수 있나?**

결론부터 말하면 `new ArrayList<>()`는 할 수 있고, 

`Arrays.asList()` 할 수 없다.

---

<br/><br/>

7번.


# **enum이란?**

enum은 **열거형(enumerated type)**이라고 부른다. 

열거형은 **서로 연관된 상수들의 집합**이라고 할 수 있다.

열거형은 연관된 값들을 저장하며, 저장된 값들이 변경되지 않도록 보장한다. 

또한 enum의 경우 열거형 그 자체이면서 클래스이기 때문에 

**enum내부에 생성자나 필드, 메서드를 가질 수 있어** 다양한 역할을 할 수 있다.

상수 목록이 필요해 상수목록만 적어놓은 class를 활용한 적이 있는데, 

이런 사용은 자제하고 enum을 활용할 수 있다.


---

<br/><br/>

8번.

# *`public* Order(int a, int b, *int c*,)`

### 생성자 여러개 사용하는 이유

나이와 키를 갖는 사람 객체를 생각해보겠습니다.

```java
class Person {

	int age;
	int height;
}
```

Person p = new Person();

현재 Person p는 나이가 0이고 키도 0입니다. 

이런 사람은 존재할 수 없겠죠? 

그래서 이런 객체는 유효하지 않다고 합니다. 

이 문제를 해결하기 위해 생성자를 이용합니다.

```java
class Person {
	int age;
	int height;

	public Person(int age, int height) {

    this.age = age;
    this.height = height;

	}
}
```

Person p = new Person(10, 130);

Person p 는 생성과 동시에 나이 10, 키는 130을 갖습니다. 

이것은 유효하다고 할 수 있습니다.



---

<br/><br/>

9번.


추가 설명 : final 로 되어 있으면 무조건 생성자를 통해서 할당 되어야 한다.



---

<br/><br/>

10번.



Collection은 인터페이스이고, Collections는 클래스 이다.
Collections 유틸 클래스란? math 클래스 처럼 컬렉션을 다루는 데 있어
필요한 메서드들을 제공하는 클래스 이다. 안에 sort 정렬 등등 메서드들이 있다


---

<br/><br/>

11번.


# static, static() 메서드

### 클래스 안에다가

static class 를 썻다는 것은

밖에 있는 클래스의 안에서만 사용 하겠단 뜻이 된다.

### static() 메서드

static 메서드는 static 변수로 지정 되어 있는 것을 가져와서 사용할때 static 메서드를 사용한다.

즉, 핵심은 static 메서드에 인스턴스 변수는 들어 올수 있지만, 

인스턴스 메서드에 static 변수는 들어 올수 없다.

### 정리해보면,

생성될때 자바가 뜰때 생성해 놓을것을 그냥 가져다 사용하는 것이다.

```java
package hello.core.singleton;

import org.junit.jupiter.api.Test;

public class SingletonService {

    //자기 자신을 내부에 private으로 하나 가지고 있는데 static 이므로,
    //클래스 레벨에 딱 하나만 존재하게 된다.
    //1. static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    //2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
    public static SingletonService getInstance() {
        return instance;
    }

    private SingletonService() {

    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }

}
```

이렇게 작성하고 에러가 뜨는 이유는.

생성자의 private 때문에 안되는 것이다.



---

<br/><br/>

12번.



# **equals와 == 의 차이점**

equals() 는 **메소드** 입니다. 

객체끼리 내용을 비교할 수 있도록 합니다.

== 은 비교를 위한 **연산자** 입니다.

equals 메소드는 비교하고자 하는 **대상의 내용 자체를 비교**하지만,

== 연산자는 비교하고자 하는 대상의 **주소값을 비교**합니다.




---

<br/><br/>

13번.

# ...

### (Object...a) 는 배열이다.  == 가변 매개변수

가변: 갯수가 정해져 있지 않다.

매개변수 여러 개 넣어도 된다는 말이다.


---

<br/><br/>

14번.


# List의 특징

읽기 전용이다.

그리하여 추가 하려면 `UnsupportedOperationException` 예외 발생한다. (지원하지 않는 기능)

그릭하여 추가 하고 싶으면

```java
// 생성자에다가 넣어서 다시 만들어야 하는것이다.
List list = new ArrayList(Arrays.asList(1,2,3,4,5)); 
```


---

<br/><br/>

15번.



# paralleXXX()

XXX 는 뒤에 이름이 여러개가 온다는 것이다.


---

<br/><br/>

16번.


클래스 타입이 뭔지 알 수 있다.



---

<br/><br/>

17번.


# hasNext()

읽어올 요소가 있는지 확인.


# next()

요소 하나 꺼내오기.

---

<br/><br/>

18번.


# **length 와 length() 그리고 size()**

https://mine-it-record.tistory.com/126 참고



---

<br/><br/>

19번.

![이미지](/programming/img/스4.PNG)

인자라고도 부른다.


---

<br/><br/>

20번.



# null ≠ “”;

서로 두개 다르다.


---

<br/><br/>

21번.


# 개발할때 순서

### 실제로 개발하면

1. 요청 파라미터를 받는다.
2. 객체를 만든다. 
3. 객체에 값을 넣어준다.

```java
// 요청 파라미터를 받는다.
@RequestParam String username;
@RequestParam int age;

// 객체를 만든다. 
HelloData data = new HelloData();

// 객체에 값을 넣어준다.
data.setUsername(username);
data.setAge(age);
```

---

<br/><br/>

22번.


# 프로퍼티

### 프로퍼티

getXxx 첫 글자가 대문자 에서 → get을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

setXxx 첫 글자가 대문자 에서 → set을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

객체에 getUsername() , setUsername() 메서드가 있으면, 이 객체는 username 이라는 프로퍼티를 가지고 있다.

username 프로퍼티의 값을 변경하면 setUsername() 이 호출되고, 조회하면 getUsername() 이 호출된다.

```java
class HelloData {
	getUsername();
	setUsername();
}
```



---

<br/><br/>

23번.


# **instanceof**

예제 1

```java
class Simple1{  
	 public static void main(String args[]) {  

			 Simple1 s=new Simple1();  
			 System.out.println(s instanceof Simple1); // true  
	 }  
}

출력값.
true
```

예제 2.

```java
class Animal{ }  

 
class Dog1 extends Animal{  
	 public static void main(String args[]) {  

			 Dog1 d=new Dog1();  
			 System.out.println(d instanceof Animal)
	 }  
}

출력값.
true  
```

예제 3.

```java
class Dog2{  
	 public static void main(String args[]) {  
			
		  Dog2 d=null;  
		  System.out.println(d instanceof Dog2);//false  
	 }  
}

출력값.
false  
```


---

<br/><br/>

24번.


• keySet() 메서드는 key의 값만 출력



---

<br/><br/>

25번.


# 메서드 레퍼런스

메소드 레퍼런스란??

첫번째 추천 사이트.

*Hanumoka, IT Blog - https://www.hanumoka.net/2019/01/30/java-20190130-java8-system-out-println/*

두번째 추천 사이트.

*https://myhappyman.tistory.com/65*

![이미지](/programming/img/스5.PNG)

getBan() 메서드를 보면 작성 되어 있다.
```java
int getBan() {
		return ban;
}
```


---

<br/><br/>

26번.


JDBC



---

<br/><br/>

27번.



겟터 셋터, 자비빈 표준 방식 셋다 부를수 있다. (제목까지 포함)

 private 이니깐 외부에서 바로 못꺼내 오니, 메서드를 통해서 꺼내 오는 방식을 말한다.


---

<br/><br/>

28번.


# API

API 방식은?

객체를 반환 하는 것이다.

예를 들어, @ResponseBody 를 풀어 적으면 이렇다.

```java
@Controller
public class HelloController {
	
		@GetMapping("hello-api")
    @ResponseBody
    public String helloApi(@RequestParam("name") String name) {
				Hello hello = new Hello();
				hello.setName = new Hello();	        
				return "hello";
    }

		static class Hello {
			private String name;

			public String getName() {
					return name;
			}

			public void setName(String name) {
					this.name = name;
			}
		}
}
```


---

<br/><br/>

29번.


# **스프링 컨테이너와 빈**

### 스프링 컨테이너

스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 

생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다. 

### 여기서 말하는 자바 객체를 스프링에서는 빈(Bean)이라고 부른다.

개발자는 new 연산자, 인터페이스 호출 방식으로 객체를 생성하고 소멸 시킬 수 있는데, 

스프링 컨테이너가 이 역할을 대신 한다. 

즉, 제어 흐름을 외부에서 관리하는 것이다.

스프링 컨테이너 안에 스프링 빈 저장소가 있고, 그 안에 빈이 들어있다고 생각하시면 됩니다.

![이미지](/programming/img/스6.PNG)


---

<br/><br/>

30번.


영구 저장 하다란 뜻이다.



---

<br/><br/>

31번.



# 스프링 다형성

![이미지](/programming/img/스8.PNG)

이렇게도 가능하다. 

![이미지](/programming/img/스9.PNG)

`interface MemberRepository` 이기 때문에 다형성을 이용해 이렇게 받는 것도 가능하다.

이렇게도 다형성에 의해 가능한 것이다. (빨간줄은 무시하기.)


---

<br/><br/>

32번.


주입이라는 뜻



---

<br/><br/>

33번.


# 커스터마이징

쉽게 말하면 특정 url 주소에 접속 할 때 접근 제한을 설정 하는 방법이다.



---

<br/><br/>

34번.


# 레퍼런스란??

참조를 뜻한다.

## **레퍼런스 변수란?**

변수 객체의 위치를 가리킨다.



---

<br/><br/>

35번.


# 배열에 저장 공간이 부족할때

배열에 저장 공간이 부족해서 새로운 배열을 만들때 

어떻게 해야되나요? 물어보면 

첫번째. 더 큰 배열을 만들고

두번째. 기존 내용을 복사하고

세번째. 참조를 변경해야 됩니다.



---

<br/><br/>

36번.


# 렌더링이란?

만약 클라이언트가 별 사진을 보고 싶다고 가정하자.

그러면 웹 브라우저에서 서버로 요청을 한 다음에 서버가 응답을 보낼 때

HTML로 변환해서 웹 브라우저로 보내 주는 것이다.

그러면 웹 브라우저가 렌더링을 해서 별 사진을 볼 수 있게 되는 것이다.



---


<br/><br/>


37번.


# `Integer.*parseInt*(request.getParameter("age"))`

```java
int age = Integer.parseInt(request.getParameter("age"));
```

문제는 `request.getParameter()` 응답 결과는 항상 ‘문자’ 인 것이다.

그리하여 `Integer.parseInt()` 으로 변환하여 숫자로 변환 해야 되는 것이다.



---

<br/><br/>

38번.


# `getRequestDispatcher`()

```java
request.getRequestDispatcher()
```

`getRequestDispatcher()` 는 ‘컨트롤러’에서 ‘뷰’ 로 이동할 때 사용 하는 것이다.

`forward()` 이걸 사용하면 진짜로 서블릿에서 jsp로 호출할 수 있게 되는 것이다.

이렇게 하면 jsp를 찾아서 넘어가게 되는 것이다.
```java
// 여기로 제어권을 보내는 것이다.
String viewPath = "/WEB-INF/views/new-form.jsp";

RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
```


---

<br/><br/>

39번.


# 절대 경로, 상대 경로

### ‘절대 경로’ : "C:\Users\UserID\Desktop\test.txt" → **최상위 /를 포함하고 있다.**

시작 지점부터 목표 지점 까지의 어느 누가 봐도 절대적으로 이곳을 가리킬 수 있는 곳입니다.

만약, <form action="save" method="post"> 부분이 

‘/save’ 로 한다면 localhost:8080/save 이렇게 들어가는 것이다.

### ‘상대 경로’ : “test.txt” → **최상위 /를 거치지 않고도 이동이 가능하다.**

‘/’이 없이 그냥 ‘save’ 되어 있다면 ‘상대 경로’ 인 것이다.

그러면 localhost:8080/servlet-mvc/members/new-form 로 시작하여

<form action="save" method="post"> 했다면 

localhost:8080/servlet-mvc/members/new-form save 이렇게 끝에만 변하는 것이다.



---

<br/><br/>

40번.



# json

키에 허용되는 타입이 문자열 뿐이라는 것이었다


---

<br/><br/>

41번.



# getParameterNames() 제발

제발 제대로 알자.

getParameterNames( ) 는 username 이랑 age를 뜻하는 것이다.

‘kim’, ‘바보’, ‘석’ 이런거 아니다 !!!!!!!!!!!!!!!!!!!!

![이미지](/programming/img/스10.PNG)


---

<br/><br/>

42번.


# @RequestParam

### @RequestParam 이 있으면 명확하게 요청 파리미터에서 데이터를 
읽는 다는 것을 알 수 있다.



---

<br/><br/>

43번.

# 요청 파라미터란? (중요)

GET에 쿼리 스트링 오는 것이다. 또는 HTML POST 방식 오는 것이다.

이 두개인 경우에만 

`@RequestParam`, `@ModelAttribute` 사용하는 것이다.

이 밖은 전부 데이터를 직접 꺼내야 하는 것이다.

# 요청 파라미터 vs HTTP 메시지 바디

### 요청 파라미터를 조회 할때는 이걸 사용: `@RequestParam` , `@ModelAttribute`

### HTTP 메시지 바디를 직접 조회 할때는 이걸 사용: `@RequestBody`




---

<br/><br/>

44번.


# input 태그 name=”name”

태그 안에 있는 name="name” 인 “name”이! ‘키’ 가 되는 것이다.

그리고 자연스럽게 Value인 ‘spring’은 내부적으로 어딘가에 저장된다.

그리하여 서버에 넘어가게 되는 것이다.

### 밑에 사진이 ‘키’ 이다.

![이미지](/programming/img/스11.PNG)

프로퍼티 바인딩



---

<br/><br/>

45번.


# `parameter`

입력값을 저장하는 변수.

예를들어 전화를 거는 메소드를 만든다고 할 때, 
우리는 전화를 걸 대상에 대한 입력값이 필요합니다. 
이러한 입력값을 기억해두는 변수가 바로 **파라미터** 입니다. 
이러한 **파라미터**는 메소드의 구조상에서 소괄호 사이에 위치합니다.



---

<br/><br/>

46번.


# `Optional<>`

### Optional 이란?

findById, findByName 에서 찾아온 값이 null 일 수도 있다.

그러므로 null 을 처리하는 방법으로 Optional 을 감싸서 사용하는 것이다. 

```java
public interface MemberRepository {
    Member save(Member member); // 회원이 저장소에 저장이 되는 것이다.

    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);

    // 지금까지 저장된 모든 리스트를 반환 해주는 것이다.
    List<Member> findAll();
}
```

### 테스트 코드 예시.

```java
    @Test
    public void save() { // 저장이 잘 되는지 테스트 해보기.
        Member member = new Member();
        member.setName("spring"); // 이름을 세팅 해준다.

        repository.save(member); // 저장한다.

        // 내가 넣은게 제대로 들어갔나? 확인
        // 마지막 .get()을 하는 이유는 반환 타입이 Optional이라서 꺼낼때는 
				// .get()해야 꺼낼수 있다.
        Member result = repository.findById(member.getId()).get();
```

### Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다

스프링 빈이 없으면, `Optional.empty` 라는걸로 넣어 준다. 

반대로 값이 있으면 `Optional`안에 값이 감싸져 있을 것이다.



---

<br/><br/>

47번.


# `findAny(), findAll`()

## findAny()

하나라도 찾으면 반환.

## findAll()

지금까지 저장된 모든 리스트를 반환 해주는 것이다.
```java
public interface MemberRepository {
    Member save(Member member); // 회원이 저장소에 저장이 되는 것이다.

    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);

    // 지금까지 저장된 모든 리스트를 반환 해주는 것이다.
    List<Member> findAll();
}
```


---

<br/><br/>

48번.


# `ifPresent`()

**Optional 객체가 감싸고 있는 데이터가 존재할 경우에만** 

**실행될 로직을 함수형 인자로 넘길 수 있습니다.**

이런 코드를 줄일 수 있다

```java
Optional isPresent != null;
```

### `ifPresent()` 메서드는 Optional 객체가 값을 담고 있을 때, 처리 한다.

### 예시로 본다면 result 값에 데이터가 있으면, 동작을 하게 하는 메서드 이다.

조건 : result 가 Optional 이기 때문에 가능한 것이다.

밑에 코드를 본다면 현재 새로운 member 객체가 들어와 

findByName으로 안에 똑같은 객체가 있는지 찾는 것이다. 

있으면 result로 반환. 없으면 null.


```java
// 전체적으로 설명하면, 
// findByName 해서 그 결과는 Optional<Member> 니깐 바로 
// Optional<Member> (.) ifPresent()로 연결 할 수 있는 것이다

memberRepository.findByName(member.getName())
                        .ifPresent(m -> {
                            throw new IllegalStateException("이미 존재하는 회원입니다.");
                        });
```

---

<br/><br/>

49번.


# Optional.ofNullable, **of**

### Optional 에서 제공하는

**of**와 **ofNullable** 매서드를 사용합니다. 

### 둘의 차이점은

of는 인자로서 null값을 받지 않는다는 것이고 

ofNullable은 null값을 허용한다는 것입니다.



---

<br/><br/>

50번.


# 생성자 주입

### 생성자 주입

생성자에 @Autowired 라고 되어 있다. 뭐나면??

스프링이 @Component 가 있네 하면서 `OrderServiceImpl` 클래스를 등록을 할때

<br/>등록이 되면 생성자를 호출해야 되는 것이다.

그러면 생성자를 호출할때 “@Autowired 가 있네” 하고 스프링 컨테이너에서 

<br/>스프링 빈을 꺼낸다. `MemberRepository` 랑 `DiscountPolicy` 를 딱 `OrderServiceImpl` 에 주입 

해주는 것이다.

![이미지](/programming/img/스12.PNG)

### 중요! 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다

만약 어떤 값을 세팅하고 “이것은 더 이상 값을 변경하면 안돼” 한다면 생성자에 값을 넣고, 
set메서드 같은걸 만들지 않으면 된다. <br/>(불변 == 절대 변하지 않는것)

<br/>

### 참고: 어쩌면 당연한 이야기이지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다. <br/>스프링 빈이 아닌 Member 같은 클래스에서 @Autowired 코드를 적용해도 아무 기능도 동작하지 않는다.




---

<br/><br/>

51번.


# 스프링 컨테이너

하는 일은??

크게 두가지 하는 일이 있다.

1. 스프링 빈을 등록하는 것.
2. 연관 관계를 자동으로 주입한다.



---

<br/><br/>

52번.


# 스프링 빈의 이벤트 라이프사이클

스프링 빈의 이벤트 라이프사이클은 이렇게 된다.

1. 스프링 컨테이너 생성 
2. 스프링 빈 생성 
3. 의존관계 주입 
4. 초기화 콜백 
5. 사용 
6. 소멸전 콜백 
7. 스프링 종료

초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출

소멸전 콜백: 빈이 소멸되기 직전에 호출

### 객체의 생성과 초기화를 분리하자.

생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 

반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 

무거운 동작을 수행한다.

따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 

객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 

물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 

생성자에서 한번에 다 처리하는게 더 나을 수 있다.



---

<br/><br/>

53번.


# getBeanDefinitionNames()

- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.



---

<br/><br/>

54번.



# `@RequestMapping()`

@RequestMapping("/basic/items") 설명.

클라이언트에서 "/basic/items" 로 url을 요청하는 모든건 여기 클래스에서 받게 되는 것이다.

그리고, 여기 클래스에 있는 모든 메서드들은 url이 "/basic/items" 포함 되어 있는 것이다.

그리하여 items() 메서드 같은 경우는 생략 된것이라고 생각하면 된다.

item() 메서드 같은 경우는 /basic/items/{itemId} 경로가 되는 것이다.


---

<br/><br/>

55번.


# AnnotationConfigApplicationContext

이 클래스는 ApplicationContext 인터페이스의 구현체이다

추가로 위에 코드처럼 이렇게 AppConfig.class 를 넘기면 AppConfig클래스도 빈에 등록이 된다.

```java
ApplicationContext applicationContext
                = new AnnotationConfigApplicationContext(AppConfig.class);
```

---

<br/><br/>

56번.


# getBean()

- ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회한다.



---

<br/><br/>

57번.


# getRole()

- 스프링이 내부에서 사용하는 빈은 getRole() 로 구분할 수 있다.
    - ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈
    - ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈



---

<br/><br/>

58번.


# ROLE_APPLICATION

- ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈

  ROLE_APPLICATION 란??

  스프링이 내부에서 뭔가를 하기 위해서 등록한게 아니라,

  내가 애플리케이션을 개발하기 위해서 등록한 빈이라고 생각하면 되는 것이다.


---

<br/><br/>

59번.


# ROLE_INFRASTRUCTURE

- ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈



---

<br/><br/>

60번.


# @NonNull

Null 체크

@NonNull 어노테이션을 변수에 붙이면 자동으로 null 체크를 해줍니다.

즉, 해당 변수가 null로 넘어온 경우, NullPointerException 예외를 일으켜 줍니다.



---

<br/><br/>

61번.


# @Data

@Getter 와 @Setter는 각각 접근자와 설정자 메소드를 작성해주는 
Lombok 어노테이션으로 유명하다.



---

<br/><br/>

62번.


# @RequiredArgsConstructor

@NotNull 어노테이션이나 final 키워드를 사용하고 있는 

속성들만으로 이루어진 생성자를 자동으로 만들어 준다.


<br/>

```java

@RequiredArgsConstructor // 사용시 final 이 붙은 클래스를 생성자 주입 과정을 자동 생성 해주는 것이다.
public class BasicItemController {

    private final ItemRepository itemRepository;

/*
위에 있는 @RequiredArgsConstructor 가 대신 이 과정을 해준다.

    @Autowired
    public BasicItemController(ItemRepository itemRepository) {
        this.itemRepository = itemRepository;
    }
*/

```



---

<br/><br/>

63번.

테스트 코드에서 Optional 꺼낼때는 get()해야 꺼낼수 있다.

---

<br/><br/>

64번.


@Service -> 이걸 해놔야 맴버컨트롤러에서 여길 찾아서 @Autowired 할수 있는 것이다.



---

<br/><br/>

65번.

String이 null인지 empty인지 확인할 수 있습니다. 

isEmpty()는 문자열이 ""처럼 비어있을 때 true를 리턴합니다.

```java

public class checkIfStringEmptyOrNull {

    public static void main(String[] args) {

        String str1 = null;
        String str2 = "";
        String str3 = "a1";

        System.out.println("str1, empty or null ? " + isEmptyOrNull(str1));
        System.out.println("str2, empty or null ? " + isEmptyOrNull(str2));
        System.out.println("str3, empty or null ? " + isEmptyOrNull(str3));
    }

    private static boolean isEmptyOrNull(String str) {
        if (str != null && !str.isEmpty()) {
            return false;
        } else {
            return true;
        }
    }
}

```


---

<br/><br/>

66번.


invalidate()란? 세션이랑 그안에 데이터까지 싹다 지운다.



---

<br/><br/>

67번.


### @EqualsAndHashCode 란

equals, hashCode 자동 생성
자바 빈을 만들 때 equals와 hashCode 메소드를 자주 오버라이딩 한다

@EqualsAndHashCode 어노테이션을 사용하면 자동으로 이 메소드를 생성할 수 있다.

callSuper 속성을 통해 eqauls와 hashCode 메소드 자동 생성 시 부모 클래스의 필드까지 감안할지의 여부를 설정할 수 있다.

<br/>

IpPort 클래스

```java

@Getter
@EqualsAndHashCode
public class IpPort {

    // 여기는 "127.0.0.1.8080" 포트가 문자로 들어온다.
    // 이걸 숫자로 바꾸고 싶은 것이다.
    // 그리고 반대로 숫자로 들어오면 문자로 바꾸고 싶은 것이다.

    private String ip;
    private int port;

    public IpPort(String ip, int port) {
        this.ip = ip;
        this.port = port;
    }
}

```

<br/>

StringToIpPortConverter 클래스

```java

@Slf4j
public class StringToIpPortConverter implements Converter<String, IpPort> {

    @Override
    public IpPort convert(String source) {

        // "127.0.0.1:8080" 이라는 문자가 들어올 것이다.
        log.info("convert source={}", source);
        String[] split = source.split(":");// ":" 이걸 통해서 잘라 주는 것이다.

        // 즉, "127.0.0.1:8080" 이걸
        // ":" 기준으로 앞쪽 127.0.0.1 은 문자로 사용 할것이고,
        // ":" 기준으로 뒤쪽 8080 은 숫자로 사용 할 것이라고 말하는 것이다.
        String ip = split[0];
        int port = Integer.parseInt(split[1]);

        return new IpPort(ip, port); // IpPort 객체 생성
    }
}
```

<br/>

테스트 코드

이렇게 되는 이유는 주석으로 적어 놨다.

```java
// result 객체랑 new IpPort(```) 객체랑 참조값이 달라도 상관없다.
// 안에 있는 ip랑 port 라는 데이터가 다 같으면 true가 나오는 것이다.
Assertions.assertThat(result).isEqualTo(new IpPort("127.0.0.1", 8080));
```


<br/>

### hashCode() 메서드 란?

Java의 Hash Code란, 객체를 식별할 수 있는 유니크한 값을 말한다. 

메모리에 생성된 객체의 주소를 정수로 변환한 형태를 얘기하는데, 이 정수는 중복되지 않는 고유의 값입니다.

Object Class에서 hashCode()를 가지고 있어서 객체를 생성하여 확인해보면 Hash Code 값을 확인 할 수 있다.

<br/>

처음에 hashCode() 메소드의 결과 값이 동일한지를 확인한다. 

그런다음 Hash Code 값이 다르면 서로 다른 객체로 판단하고, Hash Code 값이 같으면 equals()메소드로 다시 비교한다. 

두 조건이 모두 맞아야 동일한 객체로 판단한다.
	
	
<br/>	
	
### 자바의 데이터 타입은 크게 2가지로 나눌수 있다.

- primitive(기본형 타입)
- object

primitive 타입은 byte, short, int, long 과 같이 size 가 정해져 있는 값이다.

object 타입은 Byte, Short, Integer, Long, Class 과 같이 주소값을 참조하는 형태다.
	

<br/>

int number = Integer.parseInt("123");

Integer number = Integer.valueOf("123");

두개의 차이점은 primitive 으로 리턴할 것인지,

object 타입으로 리턴할 것인지 차이가 있다.

<br/>
	
```java

int i = Integer.parseInt("String value");

```

valueOf 는 결국 parseInt 를 호출하는 형태이다.

문자열을 변환할 때 객체로 받아서 사용하느냐, 기본 자료형으로 받아서 사용하느냐의 차이다.
	
	
---

<br/><br/>

68번.






---

<br/><br/>

69번.






---

<br/><br/>

70번.






---

<br/><br/>

71번.






---

<br/><br/>

72번.






---

<br/><br/>

73번.






---

<br/><br/>

74번.






---

<br/><br/>

75번.






---

<br/><br/>

76번.






---

<br/><br/>

77번.






---

<br/><br/>

78번.






---

<br/><br/>

79번.






---

<br/><br/>

80번.






---

<br/><br/>

81번.






---

<br/><br/>

82번.






---

<br/><br/>

83번.






---

<br/><br/>

84번.






---

<br/><br/>

85번.






---

<br/><br/>

86번.






---

<br/><br/>

87번.






---

<br/><br/>

88번.






---

<br/><br/>

89번.






---

<br/><br/>

90번.






---

<br/><br/>

91번.






---

<br/><br/>

92번.






---

<br/><br/>

93번.






---

<br/><br/>

94번.












