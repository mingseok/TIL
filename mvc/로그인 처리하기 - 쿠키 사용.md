## 로그인 처리하기 - 쿠키 사용

로그인 상태 유지하기
로그인의 상태를 어떻게 유지할 수 있을까?

<br/>

쿠키를 사용해보자.

쿠키서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달하자. 

그러면 브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.

![이미지](/programming/img/나8.PNG)

<br/>

![이미지](/programming/img/나9.PNG)

<br/>

![이미지](/programming/img/나10.PNG)

### 쿠키에는 영속 쿠키와 세션 쿠키가 있다.

- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

브라우저 종료시 로그아웃이 되길 기대하므로, 우리에게 필요한 것은 세션 쿠키이다.

<br/>

## 쿠키 생성 로직

로그인에 성공하면 쿠키를 생성하고 `HttpServletResponse` 에 담는다. 

쿠키 이름은 `memberId` 이고, 값은 회원의 `id` 를 담아둔다. 

웹 브라우저는 종료 전까지 회원의 `id` 를 서버에 계속 보내줄 것이다.

```java
Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
response.addCookie(idCookie);
```

<br/>

### 쿠키 테스트를 해보자.

F12를 켠 다음에 

밑에 아이디 비밀번호 치고 로그인하기.

id : test 

password : test!

![이미지](/programming/img/나11.PNG)

쿠키가 나오는걸 알 수 있다. 

<br/>이렇게 된다면 웹 브라우저로 memberId=1 이 넘어가게 된 것이다.

이젠 다시 이 웹 브라우저로 들어오게 되면 (웹 브라우저를 닫으면 안됨) 

<br/>쿠키가 있는 것을 확인 할 수 있다.

![이미지](/programming/img/나12.PNG)

<br/>

HomeController 

```java
package hello.login.web;

@Slf4j
@Controller
@RequiredArgsConstructor
public class HomeController {

    private final MemberRepository memberRepository;

//  @GetMapping("/")
    public String home() {
        return "home";
    }

    @GetMapping("/")
    public String homeLogin(@CookieValue(name = "memberId", required = false) Long memberId, 
																	Model model) {

        // 어너테이션 required = false인 이유는? 
				// 로그인 안한 사용자도 여기에 들어 오기 때문에 false인 것이다.

        if (memberId == null) {
            return "home";
        }

        // 로그인 성공한 사용자
        Member loginMember = memberRepository.findById(memberId);
        if (loginMember == null) {
            return "home";
        }

        model.addAttribute("member", loginMember);
        return "loginHome";
    }
}
```

@CookieValue 를 사용하면 편리하게 쿠키를 조회할 수 있다.

로그인 하지 않은 사용자도 홈에 접근할 수 있기 때문에 required = false 를 사용한다.

<br/>

## 로직 분석

로그인 쿠키( memberId )가 없는 사용자는 기존 home 으로 보낸다. 

추가로 로그인 쿠키가 있어도 회원이없으면 home 으로 보낸다. 

로그인 쿠키( memberId )가 있는 사용자는 로그인 사용자 전용 홈 화면인 loginHome 으로 보낸다. 


<br/>

추가로

홈 화면에 화원 관련 정보도 출력해야 해서 member 데이터도 모델에 담아서 전달한다.

`th:text="|로그인: ${member.name}|"` : 로그인에 성공한 사용자 이름을 출력한다.

상품 관리, 로그아웃 버튼을 노출한다.

<br/>

### 실행

로그인에 성공하면 사용자 이름이 출력되면서 상품 관리, 로그아웃 버튼을 확인할 수 있다. 

로그인에 성공시 세션 쿠키가 지속해서 유지되고, 

웹 브라우저에서 서버에 요청시 memberId 쿠키를 계속 보내준다

![이미지](/programming/img/나13.PNG)


<br/>

## 로그아웃 기능

이번에는 로그아웃 기능을 만들어보자. 로그아웃 방법은 다음과 같다.

세션 쿠키이므로 웹 브라우저 종료시 서버에서 해당 쿠키의 종료 날짜를 0으로 지정

LoginController - logout 기능 추가

```java
	
    ``

@PostMapping("/logout")
    public String logout(HttpServletResponse response) {
        expireCookie(response, "memberId");
        return "redirect:/";
    }

    private void expireCookie(HttpServletResponse response, String cookieName) {
        Cookie cookie = new Cookie(cookieName, null);
        cookie.setMaxAge(0);
        response.addCookie(cookie);
    }
```

<br/>

실행 시켜 로그아웃 하면,

이렇게 쿠키가 과거 시간대로 돌아갔으므로, 쿠키가 없어진 걸 알 수 있다.

![이미지](/programming/img/나14.PNG)

<br/>

## 보안 문제

쿠키 값은 임의로 변경할 수 있다.

클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.

<br/>

실제 웹브라우저 개발자모드 Application Cookie 변경으로 확인

Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임)

<br/>

### 쿠키에 보관된 정보는 훔쳐갈 수 있다.

만약 쿠키에 개인정보나, 신용카드 정보가 있다면?

이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.

<br/>

쿠키의 정보가 나의 로컬 PC가 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다

해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.

해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.

<br/>

## 대안

쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 

서버에서 토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.

<br/>토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.

해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 

<br/>만료시간을 짧게(예: 30분) 유지한다. 

또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다