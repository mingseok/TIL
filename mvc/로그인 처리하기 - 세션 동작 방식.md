## 로그인 처리하기 - 세션 동작 방식

### 목표

앞서 쿠키에 중요한 정보를 보관하는 방법은 여러가지 보안 이슈가 있었다. 

이 문제를 해결하려면 결국 중요한 정보를 모두 서버에 저장해야 한다. 

<br/>그리고 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.

이렇게 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.

![이미지](/programming/img/나15.PNG)

<br/>

사용자가 loginId , password 정보를 전달하면 서버에서 해당 사용자가 맞는지 확인한다

![이미지](/programming/img/나16.PNG)

세션 ID를 생성하는데, 추정 불가능해야 한다.

UUID는 추정이 불가능하다.

<br/>

`Cookie: mySessionId=zz0101xx-bab9-4b92-9b32-dadb280f4b61`

생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관한다

![이미지](/programming/img/나17.PNG)

클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.

서버는 클라이언트에 mySessionId 라는 이름으로 세션ID 만 쿠키에 담아서 전달한다.

클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관한다.

<br/>

## 중요

여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다.

오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.

클라이언트의 세션id 쿠키 전달

![이미지](/programming/img/나18.PNG)

클라이언트는 요청시 항상 mySessionId 쿠키를 전달한다.

서버에서는 클라이언트가 전달한 mySessionId 쿠키 정보로 세션 저장소를 조회해서 

로그인시 보관한 세션 정보를 사용한다.

<br/>

## 정리

세션을 사용해서 서버에서 중요한 정보를 관리하게 되었다. 

덕분에 다음과 같은 보안 문제들을 해결할 수 있다.

- 쿠키 값을 변조 가능 → 예상 불가능한 복잡한 세션Id를 사용한다.
- 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다.  → 세션Id가 털려도 여기에는 중요한 정보가 없다.
- 쿠키 탈취 후 사용 → 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서
    
    세션의 만료시간을 짧게(예: 30분) 유지한다.  또는 해킹이 의심되는 경우 서버에서 해당 
    세션을 강제로 제거하면 된다.

<br/><br/>

## 로그인 처리하기 - 세션 직접 만들기

세션 관리는 크게 다음 3가지 기능을 제공하면 된다.

세션 생성

- sessionId 생성 (임의의 추정 불가능한 랜덤 값)세션 저장소에 sessionId와 보관할 값 저장
- sessionId로 응답 쿠키를 생성해서 클라이언트에 전달

세션 조회

- 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 값 조회

세션 만료

- 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 sessionId와 값 제거

<br/>

### 세션 만들기.

주석 잘보기.

```java
package hello.login.web.session;

import org.springframework.stereotype.Component;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 세션 관리
 */
@Component
public class SessionManager {

    // 쿠키를 서버에서 만들어서 웹 브라우저로 보낼때,
    // mySessionId 라는 이름으로 UUID를 보내야 된다.
    // 그때 사용하는 것이 SESSION_COOKIE_NAME 이름인 것이다.
    public static final String SESSION_COOKIE_NAME = "mySessionId";

    private Map<String, Object> sessionStore = new ConcurrentHashMap<>();

    /**
     * 세션 생성
     */
    public void createSession(Object value, HttpServletResponse response) {

        //세션 id를 생성하고, 값을 세션에 저장
        String sessionId = UUID.randomUUID().toString();

        sessionStore.put(sessionId, value); //쿠키 생성
        Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId);
        response.addCookie(mySessionCookie);
    }

    /**
     * 세션 조회
     */
    public Object getSession(HttpServletRequest request) {

        Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME);
        if (sessionCookie == null) {
            return null;
        }

        // 여기서 쿠키 UUID 를 가져오는 것이다.
        // 윗 부분들은 쿠키 name이 존재하는지 확인 하는 과정이였다.
        return sessionStore.get(sessionCookie.getValue());
    }

    /**
     * 세션 만료
     */
    public void expire(HttpServletRequest request) {
        Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME);
        if (sessionCookie != null) {
            sessionStore.remove(sessionCookie.getValue());
        }
    }

    private Cookie findCookie(HttpServletRequest request, String cookieName) {
        if (request.getCookies() == null) {
            return null;
        }

        return Arrays.stream(request.getCookies())
                .filter(cookie -> cookie.getName().equals(cookieName))
                .findAny()
                .orElse(null);
    }
}
```

@Component : 스프링 빈으로 자동 등록한다.

ConcurrentHashMap : HashMap 은 동시 요청에 안전하지 않다. 

동시 요청에 안전한 ConcurrentHashMap 를 사용했다.