## 오류 코드와 메시지 처리3 (중요)

오류 코드를 만들 때 다음과 같이 자세히 만들 수도 있고,

```
required.item.itemName : 상품 이름은 필수 입니다.
range.item.price : 상품의 가격 범위 오류 입니다.
```

<br/>

또는 다음과 같이 단순하게 만들 수도 있다.

```java
required : 필수 값 입니다.
range : 범위 오류 입니다
```

그런데 오류 메시지에 `required.item.itemName` 와 같이 객체명과 필드명을 조합한

세밀한 메시지 코드가 있으면 이 메시지를 높은 우선순위로 사용하는 것이다.


Name: 상품 이름은 필수 입니다.


<br/>


### 디테일한 메시지가 있으면 디테일한 메시지를 찾아서 사용한다. 

하지만 디테일한 메시지가 없으면 그냥 기본 레벨2 를 사용한다는 것이다.

- 목적을 잘 생각하자.
    - 현재 이걸 하는 이유는, 자세히 알려줘야 될 에러가 있고,
        
        대충 알려줘도 되는 코드가 있는 것이다. 그걸 편하게 나누기 위해 이걸 사용하는 것이다.
        
<br/>

1. 프로그램 코드에는 밑에 코드 처럼 `“required"` 만 해놓은 것이다.

```java
if (!StringUtils.hasText(item.getItemName())) {
            bindingResult.rejectValue("itemName", "required");
}
```

<br/>

2. 그리고 이렇게 배열로 담아 놓은 것이다. 이 뜻은 우선순위로 디테일한것 부터 찾는 것이다. 
    
    그리고 디테일한게 없으면 "required" 를 찾는다는 뜻이다.
    


```java
new String[]{"required.item.itemName", "required"};
```

<br/>

3. 이런식으로 개발을 해놓으면 개발자는 뭐만 하면 되냐면, 메시지만 추가 하면 되는 것이다.

2. 그 해당 부분에 디테일 한게 있다면 디테일한 것이 사용이 되는 것이고, 없으면 기본이 사용 되는 것이다.
    
3. 이렇게 되면 어떤 기획자가 “이거 좀 수정해주세요” 한다면 메시지 프로퍼티스만 수정하면 되고, 
<br/>개발코드를 손댈 필요 없이 전부 관리 할 수 있는 것이다.

4. 다시 정리해서, "required" 만 코드상 작성 해놓고, 디테일한게 있다면 그걸 실행 시키고, 아니면 다른걸 실행 시키는 것이다. <br/>(=메세지 프로퍼티스 부분만 새로 작성해주고 하면 되는 것이다)

```java
#Level1
required.item.itemName: 상품 이름은 필수 입니다.

#Level2
required: 필수 값 입니다.
```

<br/>

물론 이렇게 객체명과 필드명을 조합한 메시지가 있는지 우선 확인하고, 

없으면 좀 더 범용적인 메시지를 선택하도록 추가 개발을 해야겠지만, 

범용성 있게 잘 개발해두면, 메시지의 추가 만으로 매우 편리하게 오류 메시지를 관리할 수 있을 것이다.

스프링은 MessageCodesResolver 라는 것으로 이러한 기능을 지원한다.

<br/>

테스트 코드.

### 중요한 점은 resolveMessageCodes() 메서드가 ‘에러 이름’ 을 생성해서 뱉어 내는 것이다.

```java
package hello.itemservice.validation;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.validation.DefaultMessageCodesResolver;
import org.springframework.validation.MessageCodesResolver;

public class MessageCodesResolverTest {
    
    MessageCodesResolver codesResolver = new DefaultMessageCodesResolver();

    @Test
    void messageCodesResolverObject() {
        
		// 설명.
		// required.item 랑 required 를 뱉는다.
		// 이건 생성 한것이다.

		String[] messageCodes = codesResolver.resolveMessageCodes("required", "item");

        Assertions.assertThat(messageCodes).containsExactly("required.item", "required");
    }


    @Test
    void messageCodesResolverField() {
        String[] messageCodes = codesResolver.resolveMessageCodes("required","item", "itemName", String.class);

        Assertions.assertThat(messageCodes).containsExactly(
                "required.item.itemName",
                "required.itemName",
                "required.java.lang.String",
                "required"
        );
    }
}
```

<br/>

### 객체 오류 생성되는 과정은 이렇다.

객체 오류란?

`품의 가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}` 해당 부분이 객체 오류이다.

```java
객체 오류의 경우 다음 순서로 2가지 생성

1.: code + "." + object name
2.: code

예) 오류 코드: required, object name: item
1.: required.item
2.: required
```

<br/>

### 필드 오류 생성되는 과정은 이렇다.

필드 오류란?

`상품 이름은 필수입니다.`

`가격은 {0} ~ {1} 까지 허용합니다.`

`수량은 최대 {0} 까지 허용합니다.`

```java
필드 오류의 경우 다음 순서로 4가지 메시지 코드 생성

1.: code + "." + object name + "." + field
2.: code + "." + field
3.: code + "." + field type
4.: code

예) 오류 코드: typeMismatch, object name "user", field "age", field type: int
1. "typeMismatch.user.age"
2. "typeMismatch.age"
3. "typeMismatch.int"
4. "typeMismatch"
```

<br/>

## MessageCodesResolver

검증 오류 코드로 메시지 코드들을 생성한다.

`MessageCodesResolver` 인터페이스이고 `DefaultMessageCodesResolver` 는 기본 구현체이다.

주로 다음과 함께 사용 `ObjectError` , `FieldError`
rejectValue() , reject() 는 내부에서 MessageCodesResolver 를 사용한다. 

<br/>

여기에서 메시지 코드들을 생성한다.

FieldError , ObjectError 의 생성자를 보면, 오류 코드를 하나가 아니라 여러 오류 코드를 가질 수 있다.

MessageCodesResolver 를 통해서 생성된 순서대로 오류 코드를 보관한다.

<br/>

## FieldError rejectValue`("itemName", "required")`

다음 4가지 오류 코드를 자동으로 생성

```java
required.item.itemName
required.itemName
required.java.lang.String
required
```

<br/>

## ObjectError `reject("totalPriceMin")`

다음 2가지 오류 코드를 자동으로 생성

```java
totalPriceMin.item
totalPriceMin
```

<br/>

### 오류 메시지 출력

타임리프 화면을 렌더링 할 때 `th:errors` 가 실행된다. 

만약 이때 오류가 있다면 생성된 오류 메시지 코드를 순서대로 돌아가면서 메시지를 찾는다. 

그리고 없으면 디폴트 메시지를 출력한다.