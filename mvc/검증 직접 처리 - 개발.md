## 검증 직접 처리 - 개발



사용자가 잘못 입력 했을 경우이다.

![이미지](/programming/img/13.PNG)

고객이 상품 등록 폼에서 상품명을 입력하지 않거나, 

가격, 수량 등이 너무 작거나 커서 검증 범위를 넘어서면, 서버 검증 로직이 실패해야 한다. 

<br/>

이렇게 검증에 실패한 경우 고객에게 다시 상품 등록 폼을 보여주고, 

어떤 값을 잘못 입력했는지 친절하게 알려주어야 한다.

<br/><br/>

컨트롤러.

```java
@PostMapping("/add")
public String addItem(@ModelAttribute Item item, RedirectAttributes redirectAttributes) {

     // 검증 오류 결과를 보관
     Map<String, String> errors = new HashMap<>();

     // 검증 로직
     // StringUtils라는 추상클래스이다.
     // 이 클래스는 String을 다루는데 편리한 기능들이 몇개 있다.
     // hasText는 파라미터가 문자열인지 확인해서 true 또는 false를 반환하는 메서드이다.
     if (!StringUtils.hasText(item.getItemName())) {

          // @ModelAttribute Item item 넘어온 걸 저장 시키는 것이다.
          // 이렇게 하는 이유는 "itemName" 키로 잡아서 클라이언트에게 뿌려 주는 것이다 뭐를??
          // "상풍 이름은 필수입니다." 를 Map으로 저장해둔 errors 변수인곳에 저장했다가 뿌려 줄때 사용하는 것.
          errors.put("itemName", "상풍 이름은 필수입니다.");
      }

			if(item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
            errors.put("price", "가격은 1,000 ~ 1,000,000 까지 허용합니다.");
      }

			if (item.getQuantity() == null || item.getQuantity() >= 9999) {
            errors.put("quantity", "수량은 최대 9,999 까지 허용합니다.");
      }

			// 특정 필드가 아닌 복합 룰 검증
			// 가격 * 수량의 합은 10,000원 이상
      if (item.getPrice() != null && item.getQuantity() != null) {
           int resultPrice = item.getPrice() * item.getQuantity();

           if (resultPrice < 10000) {
                 errors.put("globalError", "가격 * 수량의 합은 10,000원 이상이여야 합니다. 현재 값 = " + resultPrice);    
           }
       }			

			 // 검증에 실패하면 다시 입력 폼으로
       if (!errors.isEmpty()) {
					
						log.info("errors={}", errors); // 검증 해보자.
					
            model.addAttribute("errors", errors);
            return "validation/v1/addForm";
       }

			 // 성공 로직
			 Item savedItem = itemRepository.save(item);
       redirectAttributes.addAttribute("itemId", savedItem.getId());
       redirectAttributes.addAttribute("status", true);
       return "redirect:/validation/v1/items/{itemId}";
 }
```

<br/>

실행 시켜, ‘상품명’ 을 등록하지 않고 저장한다면

![이미지](/programming/img/14.PNG)

<br/>

이렇게 출력 되는 걸 알 수 있다.

![이미지](/programming/img/15.PNG)

<br/><br/>

## 그런데 궁금점이 있다.

지금 ‘상품명’ 을 입력하지 않고 저장을 하여 다시 ‘상품 등록’ 화면으로 돌아오게 된 것이다.

그런데, 가격이랑 수량은 그대로 값이 유지되고 있다.

<br/>

### 이유는 무엇인가???

이유는 item 에 폼 데이터가 넘어 온다, 즉, `Item` 클래스에 데이터가 저장 되는 것이고,

그리고 `@ModelAttribute` 가 있으니 자동으로 

`model.addAttribute(”item”, item);` 들어가게 되는 것이다.

<br/>

그리하여 다시 `"validation/v1/addForm"` html로 이동하게 되는데

여기에 `th:object=”${item}”` 에 저장 되어 있기 때문에 가격이랑 수량은 그대로 값이 유지 할 수 있었다.

![이미지](/programming/img/16.PNG)

```java
@PostMapping("/add")
public String addItem(@ModelAttribute Item item, 
					  RedirectAttributes redirectAttributes,Model model) {

	     ```
```

<br/>

추가로 설명하면,

 `("item", new Item())` 객체 생성함으로써, 유용하게 재사용이 가능한 것이다.

```java
@GetMapping("/add")
public String addForm(Model model) {
    model.addAttribute("item", new Item());
		return "validation/v1/addForm";
}
```

<br/><br/>

## 그리고 클라이언트에게 뭐가 잘못 되었는지 확인 시켜주자.

이렇게 확인 할 수 있다.

‘globalError’ 키 가 있는지  확인하는 것이다.

```html
<div th:if="${errors?.containsKey('globalError')}">
    <p class="field-error" th:text="${errors['globalError']}">전체 오류 메시지</p>
</div>
```

![이미지](/programming/img/17.PNG)


<br/>

웹 브라우저 소스를 보면 이렇다.

![이미지](/programming/img/18.PNG)

<br/>

### 그리고 추가적으로 작성 해주기.

```html

<style>

		```		
		
		 .field-error {
     border-color: #dc3545;
     color: #dc3545;
}
	</style>

```

<br/>

이렇게 변하는 걸 알 수 있다.


![이미지](/programming/img/19.PNG)

<br/>

## 나머지들도 작업해주기.

이런식으로 다들 넣어주기.

<br/>

### ?. 뭐지????

`errors?.` 은 errors 가 null 일때 `NullPointerException` 이 발생하는 대신, `null` 을 반환하는
문법이다. 

`th:if` 에서 null 은 실패로 처리되므로 오류 메시지가 출력 되지 않는다.

null 일 경우 ‘줄’ 자체가 null 로 처리 된다고 생각 하면 된다.

```html
		
		 ```

<div class="field-error" th:if="${errors?.containsKey('itemName')}" th:text="${errors['itemName']}">
   상품명 오류
</div>
```

<br/>

이렇게 출력 되는 걸 알 수 있다.

![이미지](/programming/img/20.PNG)

```html
<div>
   <label for="itemName" th:text="#{label.item.itemName}">상품명</label>
   <input type="text" id="itemName" th:field="*{itemName}"
       th:class="${errors?.containsKey('itemName')} ? 'form-control field-error' : 'form-control'"
          class="form-control" placeholder="이름을 입력하세요">
  

	 <div class="field-error" th:if="${errors?.containsKey('itemName')}"
        th:text="${errors['itemName']}">
				상품명 오류
	 </div>
</div>
```

<br/>

위 코드도 좋지만 더 좋은 코드

만약 ‘_’ 가 선택 된다면 윗줄은 무시하고 밑에 `class="form-control"` 가 되는 것이다.

```html
<input type="text" 
				th:classappend="${errors?.containsKey('itemName')} ? 'fielderror' : _"
        class="form-control">
```

<br/>

![이미지](/programming/img/21.PNG)

<br/>

## 정리

만약 검증 오류가 발생하면 입력 폼을 다시 보여준다.

검증 오류들을 고객에게 친절하게 안내해서 다시 입력할 수 있게 한다.

검증 오류가 발생해도 고객이 입력한 데이터가 유지된다.

하지만 지금까지 한걸로 문제점이 많다…