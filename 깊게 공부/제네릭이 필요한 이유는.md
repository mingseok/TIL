## 제네릭이 필요한 이유는?

<br/>

## 제네릭이란?

타입 형변환에서 발생할 수 있는 문제점을 `“사전”`에 없애기 위해서 만들어졌다



여기서, “사전”이라고 하는 것은 `컴파일`할 때 점검할 수 있도록 한 것을 말한다.

<br/>

만약에 우리가 어떤 자료구조를 만들어 배포하려고 한다. 

그런데 `String` 타입도 지원하고 싶고,
 `Integer`타입도 지원하고 싶고 많은 타입을 지원하고 싶다. 

```
그러면 String에 대한 클래스, Integer에 대한 클래스 등 하나하나 타입에 따라 만들 것인가? 
```

<br/>

이건 너무 비효율적이다. 

이러한 문제를 해결하기 위해 우리는 제네릭이라는 것을 사용한다.

<br/>

### 이렇듯.

제네릭은 클래스 내부에서 지정하는 것이 아닌 

외부에서 사용자에 의해 지정되는 것을 의미한다. 

<br/><br/>

## 제네릭은

```java
ArrayList<Integer> list1 = new ArrayList<>();
ArrayList<String> list2 = new ArrayList<>();
```

클래스 내부에서 사용하는 어떤 데이터 타입을, 해당 클래스에서 사용 할때,

직접 설정을 함으로서, 해당 클래스 타입을 핸들링 할 수 있게 하는 것을 제네릭이라고 한다.

<br/>

### 제네릭을 사용하지 않는다면,

`Object`로 선언을 할 수 밖에 없다.

<br/>

그러고, 나중에는 `(int)`, `(String)` 캐스팅을 강제로 해줘야 하는 것이다.

그렇기에, 제네릭은 애초에 개발자의 `버그`를 방지할 수 있다.

<br/><br/>

## Generic(제네릭)의 장점

1. 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

2. 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 

    - 즉, 관리하기가 편하다.
    
3. 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.




<br/><br/>


## 제네릭과 타입 소거 개념


제네릭은 타입 안정성을 보장한다. 

- 제네릭 코드는 컴파일되면 제네릭 타입은 사라지게 된다. 

- 즉, 클래스 파일(.class)에는 제네릭 타입에 대한 정보는 존재하지 않는 것이다.



<br/>



컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고 개발자가 지정한 코드에 따라 

필요한 곳에 형변환을 넣어주고 최종적으로 컴파일 코드에 타입 소거로 제네릭 타입을 제거하게 된다. 


<br/>

## 그리하여, 타입 소거란?

타입 매개변수의 경계가 없는 경우에는 Object로, 

경계가 있는 경우에는 경계 타입으로 타입 파라미터를 변경하는 것입니다.


![이미지](/programming/img/입문542.PNG)

<br/>

![이미지](/programming/img/입문543.PNG)
