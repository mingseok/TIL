## 동시성 문제 해결 방법

<br/>

## 첫번째. synchronized

여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 

사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.

<br/>

현재 데이터를 사용하고 있는 해당 스레드를 제외하고, 

나머지 스레드들은 메서드에 접근 시 블록 전체에 `lock`을 걸어 막는 개념이다.

<br/>

따라서 해당 스레드가 블럭을 빠져나가기 전까지 

다른 스레드들은 동기화 처리된 블록에 접근할 수 없다. 

<br/><br/>

## synchronized 정리

동시성 문제를 해결하기 위해 `synchronized` 키워드는 매우 간단한 해결방법이 될 수 있지만, 

다른 스레드들은 아무런 작업을 하지 못하고 기다릴 수밖에 없어 자원의 낭비가 발생할 수 있다.

<br/><br/>

## 두번째. volatile

```java
public volatile long count = 0;
```

### volatile 사용하기 전 문제점.

일반적으로 컴파일러는 성능을 향상 시키기 위해 변수 값을 `CPU 레지스터`에 `캐싱`하여 사용한다. 

그러나 멀티 스레드 환경에서는 여러 스레드가 동일한 변수에 동시에 접근할 수 있으므로, 

해당 변수의 값을 캐시에서 읽는 것이 예상치 못한 결과를 가져올 수 있다.

<br/>

### `volatile` 키워드를 사용하면

`컴파일러`는 해당 변수를 `CPU 레지스터`에 `캐싱`하지 않고, 항상 메모리에서 `읽고`, 

`쓰도록` 강제함으로써, 항상 메모리에 접근하도록 보장합니다.

<br/>

따라서, **`volatile`** 키워드는 변수가 다중 스레드 환경에서 

안전하게 사용될 수 있도록 보장 합니다.

<br/>

### 하지만 `volatile` 키워드로 문제 해결이 되지 않는다.

`volatile` 을 통해 모든 동기화 문제가 해결되는 건 아닙니다.

`++` 연산과 같이 원자성이 보장되지 않는 경우 동시성 문제는 동일하게 발생합니다. 

<br/><br/>

## 세번째. ****Atomic 타입****

앞에서 설명한 두 가지 키워드 `synchronized`, `volatile` 만으로는 

동시성 문제를 깔끔하게 해결할 수 없습니다.

```java
Atomic 클래스는 원자적인 연산을 제공하여 동기화 문제를 해결합니다.
```

<br/>

Atomic 클래스는 `CAS`(compare-and-swap)를 이용하여 동시성을 하므로 

여러 스레드에서 데이터를 사용해도 문제가 없습니다. 

- `synchronized` 보다 적은 비용으로 동시성을 보장할 수 있습니다.

<br/><br/>

## CAS 알고리즘 설명



CAS 알고리즘이란 현재 스레드가 존재하는 `CPU`의 `CacheMemory`와 `MainMemory`에 
저장된 값을 비교하여, 

`일치하는 경우, 새로운 값으로 교체`하고 → `true`, 

`일치하지 않을 경우, 기존 교체가 실패`되고 → `false`를 반환하게 하는 알고리즘이다.

<br/>

## 여담이라고 하지만,

만약 `false`를 반환 했을때는 개발자의 요구사항에 따라 달라진다고 한다. 

- `while`문을 돌면서 `true`가 나올때까지 재시도하는 방법

- 몇번 시도하다가 `exception`을 터뜨리고 끝내는 방법

<br/>

### 원자성을 보장 할 수가 있다.

```java
"원자성이란?" 
여러개의 쓰레드가 있을 때 특정 시점에 어떤 메소드를
두개 이상의 쓰레드가 동시에 호출 못한다는 것이다.

멀티 쓰레드 기반의 프로그래밍을 하게 되면 중요한 것이 바로 "원자성"의 보장이다.
```


<br/>


### 자바는 위 문제들을 해결하기 위한 방법

동기화를 빠르고, 쉽게 이용하기 위한 클래스 모음을 제공합니다.

```java
java.util.concurrent.atomic.AtomicLong
```

<br/>

### 코드

```java
public class AtomicLong extends Number implements java.io.Serializable {
	
    private volatile long value; // volatile 키워드가 적용되어 있다.
	
    public final long incrementAndGet() { // value 값을 실제로 증가시키는 메서드
        return U.getAndAddLong(this, VALUE, 1L) + 1L;
    }
	
}
```

<br/><br/>

## 정리

복잡한 비즈니스 로직 사이사이에 들어가 있는 비-원자적 연산을 

여러개의 `synchronized` 블록으로 설정 하는건 가능하겠지만 코드가 복잡해질 것이고, 

개발자가 모든 코드에 동시성 문제를 하나하나 검토해야만 완벽하게 적용할 수 있을 것이다.

<br/>

### 그렇기에

`concurrent 패키지`의 클래스들을 이용하는 것이 자바에서 

동시성 문제를 해결하는 적절한 방법이라고 생각한다.