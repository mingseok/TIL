## B tree 설명

![이미지](/programming/img/입문488.PNG)

<br/>

### 특징

- 자녀 노드의 최대 개수를 늘리기 위해서 부모 노드에 key를 하나 이상 저장한다.

- 부모 노드의 key들을 오름차순으로 정렬한다.

- 정렬된 순서에 따라 자녀 노드들의 key 값의 범위가 결정된다.

- internal 노드의 key 수가 x개라면 자녀 노드의 수는 언제나 x + 1개이다.

```sql
"B tree는 BST를 일반화한 tree 라고도 말을 한다."
```

<br/><br/>

## B tree 용어 정리

최대 몇개의 자녀 노드를 가질 것인지가? B tree를 사용할 때 중요한 파라미터이다.

- `M : 각 노드의 최대 자녀 노드 수`

    - 최대 m개의 자녀를 가질 수 있는 B tree를 M차 B tree라 부른다.

        - 위 그림을 기준으로 말한다면 → 3차 B tree 라고 부르는 것이다.

- `M - 1 : 각 노드의 최대 key 수`

    - 간단하다. 3차 B tree라고 한다면 당연히 k는 두개가 될 것이기에 m-1인 것이다.

- `[M / 2] : 각 노드의 최소 자녀 노드 수`

    - [ ] → 무엇인가? 반올림을 해줘야 한다는 것이다.

- `[M/2]-1 : 각 노드의 최소 KEY 수`

    - root node는 제외한다.

```sql
"전체적으로 정리하면"
 M 파라미터만 우리가 정해주면 나머지 파라미터들은 자연스럽게 알아서 결정 되는 것이다.
```

<br/><br/>

## B tree 데이터 삽입

```sql
"추가는 항상 leaf 노드에 한다"
```

- 노드가 넘치면 중간 key를 기준으로 좌, 우 key들은 분할하고 중간0 key는 승진한다.

<br/><br/>

## e.g. 10을 추가한다고 가정해보자.

1. root 부터 10을 비교하여 내려간다.

![이미지](/programming/img/입문489.PNG)

<br/>

2. 10은 `7보다 크고`, `9보다 크기에` 9 옆에 추가한다. 그리고 leaf 노드가 3개가 되었다.

![이미지](/programming/img/입문490.PNG)

<br/>

3. leaf 노드가 2개가 되었으므로, 가장 큰 수를 분할 하고, 중간값을 한칸 위로 승진 시켜야 한다.

    - 분할 한다는건 새로운 노드를 하나 생성한다는 것이다.

![이미지](/programming/img/입문491.PNG)

<br/>

4. 9를 승진 시켰는데, leaf 노드가 다시 3개가 되었다.

    - 다시 가장 큰값은 나누고, 중간값은 승진 시켜야 한다.

![이미지](/programming/img/입문492.PNG)

<br/>

5. 가장 큰 값인 9를 때어 낸다. 즉, 노드를 하나 생성한다는 말.

![이미지](/programming/img/입문493.PNG)

<br/>

6. 중간값이였던, 7은 승진 시킨다.

![이미지](/programming/img/입문494.PNG)

<br/>

7. 원래 15가 왼쪽에 있었는데, leaf 노드들은 정렬 되어 있어야 하기 때문에 7보다 크므로 오른쪽을 옮겼다.
    

![이미지](/programming/img/입문495.PNG)

<br/><br/>

## 이런 B tree의 특징을 바탕으로 → balanced tree 라고 한다.

- 검색 avg / worst case O(log N) 이 된다.

![이미지](/programming/img/입문496.PNG)