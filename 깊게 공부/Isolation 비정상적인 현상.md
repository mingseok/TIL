## Isolation 비정상적인 현상

<br/>

## Dirty read

데이터 베이스에 `x = 10, y = 20` 값을 가지고 있다.

이런 상황에서 두개의 트랜잭션을 실행한다고 한다면?



```java
--"상황 예시"--
1. 트랙잭션1 이라는 놈은 `x에 y를 더하는 역할`을 합니다.
2. 트랜잭션2 라는 놈은 `y를 70으로 변경 시키는 역할`을 합니다.
```


<br/>

![이미지](/programming/img/입문649.PNG)


<br/>

### 동작 순서 하나씩 설명

먼저 트랜잭션1이 동작하여 `x에 y를 더하려고 할것이다.`

하지만, 트랜잭션은 현재 x의 값이 얼마인지 알아야 하기에 때문에 x를 읽는다.

<br/>

그렇기에 이처럼 `read(x) → 10` 이라는 작업 하나 수행하고, 트랜잭션 1에서 `y의 값을 읽으려는 순간`, 

트랜잭션2가 y를 70으로 변경 시킵니다 왜죠? → 저희 현재 상황이 동시에 실행 했다는 가정이다.

그렇게 때문에 트랜잭션 2도 실행하여 70으로 변경 시킨다.

<br/>

때문에 데이터 베이스에는 `y = 20 이였으나, y = 70으로 업데이트`가 된다.

그러고, 트랜잭션1이 y의 값을 읽는다. 그러면 현재 y가 뭐로 저장되어 있을 것이다.

70이기에  `read(y) → 70`이기에 70을 x와 더한다.

<br/>

그러면 10 + 70 이 계산 되니깐 80을 x에 업데이트 하게 됩니다.

그리고 트랜잭션 1번은 커밋하고 종료 합니다.

<br/>

그런데, 갑자기 트랜잭션2번이 문제가 생겨 `rollback를 하게 된 상황입니다.`

그렇다면, 트랜잭션2번은 `이전 상태`로 돌아가야 하기 때문에 `y = 20인 상태로 돌아갑니다.`

<br/>

데이터베이스에도 `y = 70`으로 저장 되어 있었으나, 

-> 이전 상태로 돌아갔기 때문에 `y`는 20이 저장 되어 있는 것입니다.

<br/><br/>


## Dirty read 정리 해보자.

`문제가 발생한 이유는 뭐죠?` x = 80이라는 점이 문제 입니다. 

왜죠? → 트랜잭션1번이 트랜잭션2번에 의해 변경된  y값 70인 상태에서 데이터를 읽고 계산하여 

나온 결과이기에 문제점이라고 볼 수 있습니다. 즉, 트랜잭션2번이 rollback 하였기에 때문에, 

`70 이란 값은 이젠 유효한 값이 아니라고 말할 수 있습니다.`


<br/>

그렇다면, x가 80이라는 데이터는 정상적인 값이 아니라는 말이 됩니다."

그래서 "데이터베이스의 80은 이상한 값이 되는 것이고", 

이런 상황을 "Dirty read"라고 부른다는 것입니다.






<br/><br/>


## Non-repeatable read

데이터 베이스에 `x = 10` 값을 가지고 있다.

이런 상황에서 두개의 트랜잭션을 실행한다고 한다면?

```java
--"상황 예시"--
1. 트랙잭션1은 x를 두번 읽는 역할.
2. 트랜잭션2은 x에 40을 더하는 역할.
```

<br/>

![이미지](/programming/img/입문650.PNG)

<br/>

### 동작 순서 하나씩 설명

다시 동작 순서를 설명 드려 보자면 가장 먼저 트랜잭션1이 동작하여 x를 한번 읽는다. 

`read(x) → 10` 이 되겠죠? 그리고 트랜잭션2번이 동작하면서, `x에 40을 더해야 하기 때문에` 

`일단은 x를 한번 읽는다.`

<br/>

곧 이어 바로, 트랜잭션2번이 x가 10이란 값에 40을 더해서 x = 50 이라는 데이터를 

데이터 베이스에 쓰게 됩니다. `write(x = 50)` 데이터 베이스에서는 50이 저장 되는 것이다

그러고 트랜잭션2번은 커밋 하고 종료 한다

<br/>

`문제 발생은 다음인데요`

트랜잭션1번이 다시 x를 또 읽는 겁니다. x를 읽으면 값이 뭐죠? 50입니다. 왜 그렇죠? 

`트랜잭션2번에 의해서 x의 값이 변경되었기 때문입니다.`

그러고, 트랜잭션1번도 커밋하고 종료하게 됩니다.

<br/><br/>

## Non-repeatable read 정리

트랜잭션1번이 수행을 하는 동안에 x를 두번 읽었는데 각각 값이 다른 것입니다.

즉, 같은 데이터를 한 트랜잭션안에서 두번 읽었는데도, 서로 다른 값이 출력 된다는 것입니다.

<br/>

### 이게 왜 문제일까?

```
생각해보면, 트랜잭션 아이솔레이션 속성이 의미하는 것에서 답을 찾을 수 있습니다.

그 답은 여러 트랜잭션이 "동시에 실행" 되어도 각각의 트랜잭션이 마치 

"혼자서 실행되는 것처럼 동작" 해야 된다는 것이 아이솔레이션의 속성이기 때문입니다.

그렇기에 "isolation 관점에서 보면 일어나면 안되는 현상이라고 말 할 수 있습니다.
```










<br/><br/>

## Phantom read

데이터 베이스에 2개의 튜플이 있다.

- 1번 튜플은 v = 10으로 가지고 있다.

- 2번 튜플은 v = 50으로 가지고 있다.

<br/>

이런 상황에서 두개의 트랜잭션을 실행한다고 한다면?

```java
--"상황 예시"--
1. 트랙잭션1은 v가 10인 데이터를 두번 읽는 역할.
2. 트랜잭션2은 t2의 v를 10으로 변경시키는 역할.
```

<br/>

![이미지](/programming/img/입문651.PNG)

### 동작 순서 하나씩 설명


먼저 트랜잭션1이 동작하여, v를 한번 읽습니다. 현재 v값이 10인 데이터가 뭐가 있는가?

T1만 V가 10이기 때문에 때문에, T1을 읽는다. 그리고 트랜잭션2번이 동작하면서, t2의 v값을 10으로 변경 시킨다.

<br/>

그러면, 50에서 10으로 변경 되는것다. 그러고 곧, 트랜잭션2번은 커밋을 합니다.

`그 다음 동작에서 문제가 발생을 하는 것입니다.` 

<br/>

트랜잭션1번은 두번 데이터를 읽는다는 것인데, 한번이 남았으니 실행을 할 것이다.

그런데, 처음에는 t1만 반환 했었는데, t2 까지 둘다 반환 하게 되는 것이다.


<br/><br/>


## Phantom read 정리

트랜잭션 1은 동일한 조건으로 두번을 읽었는데, 각각의 결과가 다른 것입니다.

```java
"이것 또한 isolation 관점에서 보면 일어나면 안되는 현상입니다."

하나의 트랜잭션 안에서 같은 조건으로 두번 읽었는데,

두번의 결과가 다르기에 나오는 경우가 발생한 것입니다. 

그렇기에, 이것또한 "이상 형상" 이라고 판단 되는 것입니다.
```


<br/><br/>


## 전체 정리

동일한 조건으로 두번을 읽었는데, 각각의 결과가 다른 것이다.

```java
"isolation 관점에서 보면 일어나면 안되는 현상이다."

하나의 트랜잭션 안에서 같은 조건으로 두번 읽었는데,
두번의 결과가 다르기에 나오는 경우 또한, "이상 형상"이라고 판단한다.
```