## B tree 데이터 삭제 방식

<br/>

## 두가지를 기억하자.

- 삭제는 항상 leaf 노드에서 발생한다.

- 삭제 후 최소 key 수보다 적어졌다면 재조정 해야 한다.

<br/>

### 재조정 절차 3가지 절차를 따른다.

즉, 삭제 후 최소 ‘key’ = ‘밑에 있는 노드’ key수 조건 보다 적어졌다면 밑에 순서를 따른다.

```jsx
1. key 수가 여유 있는 형제의 지원을 받는다.
2. 1번이 불가능하다면, 부모의 지원을 받고 형제와 합친다.
3. 2번 후 부모에 문제가 있다면 거기서 다시 1번, 2번을 반복하며 재조정한다.
```

<br/><br/>

## 정리

- 삭제는 항상 leaf(맨 밑 노드) 노드에서 진행한다.

- internal(맨 밑 노드가 아닌 노드들) 노드의 경우 선임자(나보다 적은 가장 큰 값)와 위치 바꾼 후 삭제한다.
    
- 삭제 후 최소 key 수보다 적어졌다면 재조정한다.

- 부모 지원을 받았을 경우에는 형제를 무조건 합쳐야 한다.

    - 부모 도움을 받고 부모쪽에서도 문제 발생 시 위 과정 반복하며 조정.

<br/><br/>

## 5차 B tree 시뮬레이션 그려보기

![이미지](/programming/img/입문497.PNG)

<br/>

### 삭제를 하기 위해서는 최소한의 key수를 구해야 된다.

- 5차 Bt tree 이기 때문에, 저 공식에 5를 대입하여 계산한다 ([ ] 표시는 반올림)

- 그리하여 최소 key 는 2이다.

![이미지](/programming/img/입문498.PNG)

<br/><br/>

## 90을 삭제 해보자.

- 90 자리가 삭제 되고 옆에 있던 95 숫자가 90자리를 대체 하게 된다.

- 이렇게 종료 된다.

![이미지](/programming/img/입문499.PNG)

<br/><br/>

## 75를 삭제 해보자.

- 그냥 삭제하면 안된다.

    - 왜? → 75는 현재 internal 노드이기에 leaf 노드로 옮겨 줘야 한다.

    - 그리하여 75의 선임자를 찾아야 한다.

![이미지](/programming/img/입문500.PNG)

<br/>

75를 기준으로 왼쪽 서브트리로 가야 하는 것이다. → 그중에서 가장 큰값을 찾으면 된다.

- 그렇다면 65, 70 이 있는데, B tree는 항상 정렬 되어 있기에 70을 선택하면 된다.

![이미지](/programming/img/입문501.PNG)

<br/>

이렇게, 70을 75의 선임자로 찾게 되고 이 2개를 교환 해주면 되는 것이다.

- 그리고 75를 삭제 해주면 되는 것이다.

![이미지](/programming/img/입문502.PNG)

<br/>

삭제를 하고 보니, leaf 노드의 개수가 1개가 된 것이다.

- 그렇다면, 5차 B tree 조건에 틀린 것이다. → 최소한의 key 수는 2개 였다.

- 이 문제를 해결해야 한다.

![이미지](/programming/img/입문503.PNG)

<br/>

해결 하는 방법은, (1차 : key 수가 여유 있는 형제의 지원을 받는다) 를 사용하면 된다.

- 즉, 첫번째로 만만한 동생 한테 요청을 보내보는 것이다.

- 하지만, 동생도 이미 최소한의 개수를 가지고 있어서 빌려 올 수 없다.

![이미지](/programming/img/입문504.PNG)

<br/>

그리하여 형한테 가서 여유가 있는지 물어봤는데, 여유가 있는 것이다.

- 그렇다면, 형이 65 leaf 에게 건네주면 되는 것이다.

    - 하지만 또 문제점이 있다. → B tree 는 바로 건네주면 안된다.

        - 왜? → 항상 정렬되어 있는 상태이기 때문에 바로 건네줄 경우 정렬이 깨지기 때문이다.

        - 밑에 사진 처럼, 정렬 된다.

![이미지](/programming/img/입문505.PNG)

<br/>

그렇다면, 나와 형 사이에 있는 70이라는 값을 내려준다.

- 그리고 형이 가지고 있는 값중에 가장 작은 값을 부모님한테로 올려준다.

- 올려주고 난 뒤 형은 한칸씩 왼쪽으로 땡겨 자리를 채운다.

- 이렇게 된다면 이제, 최소 key 수의 조건을 만족하게 되며 75에 대한 삭제도 완료 되게 된다.

![이미지](/programming/img/입문506.PNG)

<br/><br/>

## 45를 삭제 해보자.

45 같은 경우는 맨위에 있다. → 하지만 이걸 바로 삭제 할 수는 없는 것이다

- 왜? → internal 노드이기에 leaf 노드로 옮겨 줘야 하는 것이다.

![이미지](/programming/img/입문507.PNG)

<br/>

45의 선임자는 왼쪽 서브트리에 있다.

- 즉, 왼쪽 서브트리에서 가장 큰값을 찾으면 되는 것이다.

- 빨간색 선 순으로 정렬이 되어 있다.

![이미지](/programming/img/입문508.PNG)

<br/>

- 그렇다면 40이 가장 큰값이고 leaf 노드이기에 정확히 찾았다.

    - 40이 45의 선임자가 되는 것이다.

    - 그리고 교환 해주는 것이다.

![이미지](/programming/img/입문509.PNG)

<br/>

45를 삭제 할 수 있게 되었다.

- 하지만 또 문제가 발생했다.

- 35만 남아 있는 leaf 노드가 최소 key보다 작아진 것이다.

![이미지](/programming/img/입문510.PNG)

<br/>

해결 방법으로는 먼저, 형제들에게 도움을 요청해야 한다 (1차)

- 만만한 왼쪽인 동생부터 요청을 했더니, 최소한의 key 만 가지고 있는 것이다.

- 그리고, 오른쪽은 더이상 없기 때문에 부모님한테 도움을 요청해야 되는 것이다. (2차)

    - 부모님이 도와주신다면 조건이 있다. (2차 조건)

        - 부모님의 도움은 받고 형제와 같이 살아야 된다는 것이다.

        - 지원 해주는 값의 기준은 정렬된 값이다.

![이미지](/programming/img/입문511.PNG)

<br/>

옮겨주고 나면, 비어 있는 노드는 삭제 해주면 되는 것이다.

![이미지](/programming/img/입문512.PNG)

<br/>

이번에는 부모 노드가 문제가 발생 했다.

- 그렇다면, 부모 노드 기준으로 다시 1차 과정부터 진행하는 것이다.

- 이렇게 다시 형제한테 찾아가 물어보고 진행하고 하는 것이다.

![이미지](/programming/img/입문513.PNG)

