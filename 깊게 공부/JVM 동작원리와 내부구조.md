## JVM 동작원리와 내부구조



JVM, 자바 가상머신은 단순하게 말하면 컴파일 된 코드(바이트코드)를 

실행시켜주는 가상의 컴퓨터라고 생각하면 편하다.

```java
어딜 가든간에 현금 뽑으려면 'ATM' 찾듯이 -> 
어느 컴퓨터에서든 바이트코드를 돌리려면 'JVM'을 찾으면 된다
```

<br/><br/>

## 자바는 JVM에 의해 실행 된다

즉, 운영체제에 상관없이 실행 될 수 있고, 가비지 컬렉터(GC)로 메모리 관리를 

자동으로 해준다는 점에서 안정적인 프로그래밍을 할 수 있다는 것이다

<br/><br/>

## 간단한 순서를 보면 이렇다

1. 사람이 이해할 수 있게 만들어진 컴퓨터 언어 `“java”`로 소스코드를 입력한다

    - `(.java)`
2. 컴파일(=`javac.exe` 라고 표현)하면 `IDE`가, 컴퓨터가 이해할 수 있는 언어로 변환해준다
    - `(.class)`
3. 실행을 누르면 `IDE`가 컴퓨터에 설치된 `JVM`으로 사인을 보낸다

4. 사인을 받은 `JVM`은 컴퓨터에 사인을 보낸다
5. 그러면, 프로그램이 실행된다

<br/><br/>

## JVM의 구성은 크게 4가지로 구분된다

4가지에 대해서는 밑에서 하나씩 설명하겠다.

- `Class Loader`

- `Runtime Data Area`
- `Execution Engine`
- `Garbage Collector`

<br/><br/>

## JVM 원리

### 첫번째)

자바 소스 코드는 → `.java` 형태로 저장이 된다.

```java
public A {
  public static void main(String[] args) {

  }
}
```

<br/><br/>

### 두번째)

위, 자바 소스 파일을 자바 컴파일러가 바이트코드로 변경해주는데, 그것이 바로 → `.class` 파일로 저장된다

![이미지](/programming/img/입문396.PNG)

```java
바이트코드로 변환하는 이유는?

-> 작성한 코드를 1차적으로 숨기는 이유도 있을 것이고, 
   바이트코드로 변경하였으니, 문법 검사와 같은 작업을 이후에는
   하지 않게 되면서, 시간을 단축시키는 의미도 있다고 한다
```

<br/><br/>

### 세번째)

클래스 파일(바이트코드를 말함)들은 `Class Loader`가 JVM 메모리 영역인, → 

`Runtime Data Area`로 로딩 시키게 되는 것이다.

<br/>

클래스 로더는 .class 파일을 묶어서 JVM이 운영체제로부터 

할당 받은 메모리 영역인 `Runtime Data Area`로 적재한다

```java
바이트코드를 읽고, 클래스 정보를 메모리의 Heap/Method Area에 저장하는 곳
```

<br/>

![이미지](/programming/img/입문397.PNG)

<br/><br/>

## `Class Loader`의 내부는 어떠한가?

![이미지](/programming/img/입문398.PNG)

- `Loading`

    - 프로그램을 실행시키기 위해 필요한 `class`를 찾기 위한 동작
- `Linking`
    - `JVM`의 메모리에 로드 하기 위해 연결(link) 한다.

- `Initialization`

    - class variable을 초기화하는 역할도 수행

```java
클래스를 메모리에 올리는 로딩 기능은 메모리에 올리지 않고,
어플리케이션에서 필요한 경우 동적으로 메모리에 적재하게 되는 것이다
```

<br/>

이런 클래스 파일의 로딩은 `Loading` → `Linking` → `Initialization`인 

3단계들을 거쳐서 `Runtime Data Area` 로 넘어가게 되는 것이다.

<br/><br/>

## `Runtime Data Area` 영역은 5가지 영역이 있다

실행 중인 프로그램의 정보가 올라가 있는 JVM 메모리

![이미지](/programming/img/입문399.PNG)

크게 설명하면 이렇다.

- `Method Area`, `Heap` 영역 : 모든 스레드가 공유되고 있다

- `Stack`, `PC Register`, `Native Method Stack` 영역 : 스레드마다 하나씩 생성되는 공간이다

<br/><br/>

## Method 영역

`JVM`이 시작될 때, 생성되는 공간으로 바이트코드가 이 영역에 저장된다

- `클래스 정보`, `변수 정보`, `static으로 선언한 변수`가 저장되고, 모든 스레드가 공유하는 영역

### Method Area 에는 별도의 영역이 존재한다.

- `Runtime Constant Pool`이라는 별도의 영역이 존재

    - 상수 자료형을 저장하여 참조하는 역할을 한다

```java
저장되는 정보의 종류는?
- Field Info : 멤버 변수의 이름, 데이터 타입, 접근 제어자의 정보
- Method Info : 메소드 이름, Return 타입, 매개변수, 접근 제어자의 정보
- Type Info : Class인지 Interface인지 여부 저장, Type의 속성, 이름, Super Class의 이름
```

<br/><br/>

## Heap 영역

![이미지](/programming/img/입문400.PNG)

- `Eden` 영역 : 새롭게 생성된 객체들이 할당되는 영역

- `Survival` 영역(S0, S1) : `minor gc`로부터 살아남은 객체들이 존재하는 영역

    - `Survival` 영역의 특별한 규칙 : `Survival 0`, 혹은 `Survival 1` 둘 중 하나는 꼭 비어 있어야 한다는 것이다
        
<br/>

### Heap 영역은

동적으로 생성된 객체가 저장되는 영역으로 GC의 대상이 되는 공간이다

- `new` 연산자로 생성된 모든 `Object`와 `인스턴스 변수`, 그리고 `배열`을 저장한다

<br/>

### Heap 영역은 두 영역으로 구분할 수 있다

- `Young Generation`
    - 생명 주기가 짧은 객체를 GC 대상으로 하는 영역
    - 여기 객체들은 `Eden`이라는 곳에 할당이 된 후에, `Survivor 0`과 `1`을 거쳐,
        
        오래 사용되었다고 판단된 객체들은 `Old Generation`으로 이동하게 되는 것이다
        
        
- `Old Generation`

    - 생명 주기가 긴 객체를 GC 대상으로 하는 영역

```java
이렇게 "Method Area"와 "Heap Area"는 여러 스레드들 간에 공유되는 메모리이다
```

<br/><br/>

## Stack 영역

Stack 영역은 `지역변수`나 `메서드의 매개변수`, 임시적으로 사용되는 변수, 메서드의 정보가 저장되는 영역이다

- 지역변수와, 매개변수의 특성상 해당 메서드의 호출이 종료되면 사라진다

    - 그렇기에, 금방 사용되고, 사라지는 데이터들을 저장하는 공간이다

<br/><br/>

## PC Register 영역

스레드가 시작될 때, 생성되며 현재 수행중인 `JVM`의 명령어 `주소`를 저장하는 공간이다

- 즉, 스레드가 어떤 부분을 어떤 명령어로 수행할 지를 저장하는 공간이다

<br/><br/>

## Native Method Stack 영역

`Java`가 아닌 다른 언어로 작성된 코드를 위한 공간이다

- 자바 프로그램이 컴파일 되어 생성되는 바이트코드가 아닌,
    
    실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다
    

```java
각 스레드 별로 생성된다는 특징이 있다
```

<br/><br/>

## 여기까지 진행하였다면, 

`Runtime Data Area`에 로딩된 `.class` 파일이 `Execution Engine`을 통해 해석 될 차례인 것이다

<br/>

## `Execution Engine` 이 무엇인가?

바이트 코드를 네이티브 코드로 변환 시켜주고, GC를 실행하는 실행 엔진

![이미지](/programming/img/입문401.PNG)

로드된 `.class` 파일에 바이트코드를 실행하는 엔진인 것이다

<br/>

### 바이트코드를 실행 시키기 위해서는?

바이트코드를 컴퓨터가 이해할 수 있도록 기계어로 바꿔주는 작업이 필요한데, 

여기, `Execution Engine`는 두가지 방법을 사용한다.

- `Interpreter` : 명령어를 한줄 한줄 해석하면서 실행한다

- `JIT Complier` : Interpreter 의 단점을 해결하기 위한 방법으로 런타임 시간에 한꺼번에 변경하여 실행한다
    
- `Garbage Collector` : 더 이상 참조되지 않는 메모리 객체를 모아 제거하는 역할을 수행

<br/><br/>

## Garbage Collector 추가 설명

생명주기에 의해 지속적으로 메모리가 정리되는 곳

<br/>

### 크게 두가지로 나눌 수 있다

- `Minor GC`

    - `Heap` 영역의 `Young Generation`에서 발생하는 GC를 말한다

- `Major GC`

    - `Heap` 영역의 `Old Generation`에서 발생하는 GC를 말한다

앞으로 사용되지 않는 객체의 메모리를 `'Garbage'`라고 부른다

이런 `'Garbage'`를 정해진 스케줄에 의해 정리해주는 것을 'GC'라 부른다

<br/><br/>

## GC가 왜 필요하지?

GC는 메모리 관리 기법 중 하나이다.

```java
프로그램이 "동적으로 할당했던 메모리 영역" 중 "필요 없게 된 영역"을 알아서 해제한다
```

위의 `“동적으로 할당했던 메모리 영역”` 은 → `Heap` 영역 메모리를 뜻하고

`“필요 없게 된 영역”` 은 → 어떤 변수도 가리키지 않게 된 영역을 의미한다

<br/>

### GC의 장점은?

- 개발자의 실수로 인한 메모리 누수를 막을 수 있다

- 해제된 메모리에 접근하는 오류를 막을 수 있다
- 해제된 메모리를 또 해제하는 이중 해제 또한 막을 수 있다

<br/>

### GC의 단점은?

- GC 작업은 순수 오버헤드

- 개발자는 언제 GC가 메모리를 해제하는지 모른다

<br/><br/>

## 'GC' 를 제대로 이해하기 위해서는?

`‘Stop The World’` 를 이해 해야 한다.

- GC를 수행하기 위해 `JVM`이 멈추는 현상을 말한다

- GC가 작동하는 동안 GC관련 `Thread`를 제외한 모든 `Thread`는 멈춘다

- 일반적으로 `‘튜닝’`이라는 것은 이 시간을 최소화하는 것을 의미한다

<br/><br/>

## GC의 종류로는?

- Serial GC

- Parallel GC → 자바 8버전에서 사용
- CMS GC

- G1 GC → 자바 9버전, 10버전 부터 사용 (디폴트)
- Z GC

```java
그럼, 이중에서 뭘 선택해야 하는데?
- 나의 어플리케이션에 서비스 특성에 맞는 GC를 선택하는것이 옳다
```

<br/><br/>

## 이렇게까지 하면 

기계어로 해석된 것들이 `Runtime Data Area`로 

다시 배치되어 `스레드 동기화` or `가비지 컬렉션`을 수행하게 되는 것이다

<br/>

### Native Method Interface(=JNI)

`JVM`에 의해 실행되는 코드 중 `네이티브`로 실행하는 것이 있다면

해당 `네이티브` 코드를 호출하거나 호출 될 수 있도록 만든 일종의 프레임워크이다

<br/>

### Native Method Libraries

네이티브 메소드 실행에 필요한 라이브러리