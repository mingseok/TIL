## 1장. 객체지향 개념 소개

## 객체는 정확히 무엇인가?

사람들이 이미 객체(물체)라는 관점에서 생각하며 산다는 점을 보면 간단하게 볼 수 있다.

<br/>

### 예를 들어,

어떤 사람을 보게 된다면 사람을 일종의 객체로 간주하게 된다.

그리고 객체는 속성과 행위라는 두 가지 성분으로 정의된다.

```
사람에게는
속성 : 눈 색깔, 나이, 키 등.. 있다.
행위 : 사람은 걷기, 말하기, 호흡 등.. 있다.
```

<br/><br/>

## 객체에 대한 기본적인 정의에 따르자면

객체란 데이터와 행위라는 양면을 포함하는 엔터티(entity =실재)다.

<br/>

### 양면이란?

양면은 객체지향 프로그래밍과 다른 프로그래밍 방법론과의 주요 차이점이다.

예를 들어, 절차적 프로그래밍에서 코드는 완전히 다른 함수나 절차로 구별 된다.

<br/>

### 엔터티란?

엔터티란 우리말로 ‘개체’, ‘실재’ 로 번역이 된다.

이는 속성(=특성)이나 **이름이 있고, 다른 것과 구별되는 존재 또는 존재성**을 의미한다.

엔터티는 객체보다는 더 포괄적인 개념이라고 할 수 있다. 

<br/><br/>

## 절차

절차는 ‘블랙 박스’ 를 생각하면 된다.

블랙 박스로 입력 내용이 들어가면 출력 내용이 나온다.

데이터는 별도의 구조로 배치 되며, 이러한 함수 또는 절차에 맞춰 진다.

<br/>

### 객체지향 프로그래밍과 절차적 프로그래밍과의 차이점

객체지향 설계에서 속성과 행위는 한가지 객체 안에 모두 포함되는 반면,

절차적 설계나 구조적 설계에서는 행위가 일반적으로 분리된다.

<br/><br/>

## 데이터 은닉

객체지향 용어에서는 데이터를 속성이라고 하며, 행위를 메서드라고 한다. 

속성이나 메서드에 접근하지 못하게 제한하는 일을 ‘데이터 은닉’ 이라고 한다.

<br/>

객체지향 용어로는 캡슐화라고 불리는 행위이다, 

즉, 동일한 엔터티에서 속성들과 메소드들을 한 곳으로 합침으로써, 

Math 객체의 데이터에 대한 접근을 제어할 수 있다.

<br/><br/>

## 건실한 클래스가 되게 설계하는 지침

클래스 속성으로 접근하는 일을 제한하지 않으면, 

객체지향 클래스를 잘못 설계할 수 있다는 점에 유념하자.

<br/>

### 다른 객체, (=’메시지’ 설명)

```
myObject가 myInt1과 myInt2를 합산한 결과에 접근 하려는 경우라면 어떨까?
```

이는, math 객체가 하기 나름이다.

<br/>

myObject는 math 객체에 메시지를 보낸다.

여기서 쓰인 메시지 라는 것은 실제로는 math 객체의 sum() 메서드에 대한 호출이다.

이렇게 호출되면 sum() 메서드는 값을 myObject에 반환한다.

<br/>

장점은 myObject가 합계를 계산하는 방법을 알 필요가 없다는 점이다. 

(물론, 추측할 수는 있지만), 

이 설계 방법론을 사용하면 myObject를 변경하지 않고, Math 객체에서 합계를 계산하는 방법을 변경할 수 있다.



나는 그저 합계만 원할 뿐, 계산 방법까지 알아야 하는 것은 아니기 때문이다.

<br/>

### 간단한 예시로 계산기가 나올수 있다. (=’책임’ 설명)

계산기에는 키를 순서대로 정확히 누를 때 호출되는 합산 방법이 있다.

나는 정답을 돌려받게 되더라도, 전자적으로나 알고리즘적으로 어떻게 처리한 것인지 전혀 알 필요가 없다.

<br/>

합계를 계산하는 일은 myObject의 책임이 아니고, math 객체의 책임이다.

myObject가 math객체에 접근하는 한 적절한 메시지를 보내고 요청한 결과를 얻을 수 있다.

<br/>

일반적으로 객체는 다른 객체의 내부 데이터를 조작해서는 안된다.

즉, myObject는 myInt1 및 myInt2의 값을 직접 변경하지 말아야 한다.

<br/><br/>

## 절차적 개발에서 객체지향적 개발로 옮겨 타기

객체지향 프로그래밍의 반대 개념이 절차지향이라고 오해하는 분들이 많은데 절대 반대개념이 아니다.

절차적 프로그래밍은 '데이터를 중심으로 함수'를 만들어 쓰는편이고, 

<br/>

객체지향은 '데이터와 기능(함수)들을 묶어 하나의 객체'로 만들어 씁니다.

두가지를 지원한다면 객체지향, 지원하지 않는다면 절차적 성격이 강하다.

1. 캡슐화, 다형성, 클래스 상속을 지원하는가?
2. 데이터 접근 제한을 걸 수 있는가?

<br/><br/>

## 절차적 프로그래밍

단어 그대로 '절차적'으로 코드를 구성한다는 것입니다. 

쉽게 말하면 '흐름도(순서도)'라고 보시면 됩니다.

![이미지](/programming/img/사고프로세스1.PNG)

<br/><br/>

## 객체지향 프로그래밍

객체지향 프로그래밍의 경우 기능들을 묶어 하나의 객체로 만든다고 했습니다. 

아래 그림과 같은 형식이죠.

![이미지](/programming/img/사고프로세스2.PNG)

<br/><br/>

## 객체지향 프로그래밍의 기본 장점

데이터와 이 데이터를 다루는 연산(코드)이 객체에 캡슐화 되어 있다는 점이다.

예를 들어, 어떤 한가지 객체가 네트워크를 통해 전송되면 이 객체에 포함된 데이터와 행위까지 함께 전송된다는 것이다.

(단일 엔터티 : 전체 객체를 단일한 엔터티 하나로 생각하는 게 중요.)

<br/><br/>

## 객체란 정확히 무엇일까?

객체는 객체지향 프로그램의 빌딩블록이라고 한다.

객체지향 기술을 사용하는 프로그램은 기본적으로 객체들의 모음인 것이다.

<br/>

예를 들어, 회사 시스템에 해당 회사의 직원을 나타내는 객체가 포함되어 있다고 가정해보자.

이러한 객체는 데이터와 행위로 이루어 진다.

<br/><br/>

## 객체의 데이터

객체 내에 저장된 데이터는 객체의 상태를 나타낸다.

객체지향 프로그래밍 용어에서 이 데이터를 속성이라고 한다.

<br/>

직원을 나타내는 속성으로는 사회보장번호, 생년월일, 성별, 전화번호 등이 있다.

다양한 객체(직원들)를 구별하는 정보가 속성에 담기는 것이다.

<br/><br/>

## 객체의 행위

객체의 행위는 객체가 할 수 있는 일을 나타낸다.

객체지향 프로그래밍 용어로 표현하자면 이러한 행위라는 용어는 메서드라는 

용어로 부를 수 있는데, 나는 메시지를 보내어 메서드를 호출한다.

<br/>

예로 든 직원 예제에서 직원 객체에 필요한 행위 중 하나가 다양한 속성값을 설정하고 

반환하는 역할을 담당한다. 따라서 각 속성에는 이에 대응하는 메서드인 set, get 등이 있어야 하는 것이다.

<br/>

정보가 필요한 그 밖의 객체는 직원 객체로 메시지를 보내어 직원의 성별이 무엇인지를 물어 볼 수 있을 것이다.

<br/><br/>

## 게터와 세터

게터와 세터라는 개념이 있기 때문에 데이터 은닉이라는 개념이 성립할 수 있게 된다.

객체들이 그 밖의 객체 내 데이터를 직접 조작해서는 안되므로, 게터와 세터로 객체 데이터에 대한 접근 권한을 제어 해야 한다.

<br/>

우리는 메서드의 인터페이스 (=접속부)만을 보여주고 있을 뿐, 메서드 내의 구현(=구현부)을 

보여주고 있지 않다는 점에 유념하자.

<br/>

Payroll 객체는 이 직원의 사회보장번호를 얻어야 한다.

이 정보를 얻으려면 급여 객체가 Employee(직원) 객체(getSocialNumber() 메서드)에 메시지를 보내야 한다. 

<br/>

메시지를 보낸다는 말은 기본적으로 Payroll 객체가 Employee 객체의 getSocialNumber() 메서드를 호출한다는 의미이다. 

메시지를 받은 Employee 객체는 메시지를 인식해 요청받은 정보를 반환한다.

<br/><br/>

## 모델링 도구

클래스란 객체를 만드는 템플릿이다.

객체가 생성되면 우리는 객체가 인스턴스화 되었다고 말한다.

<br/>

세 명의 직원을 만들었다는 것은, 실제로는 Employee 클래스를 가지고 완전히

서로 다른 세 개의 인스턴스를 만들었다는 뜻이다.

속성 및 메서드의 복사본이 각 객체만의 고유한 속성과 메서드가 된다.

<br/><br/>

## 클래스란 정확히 무엇을 일컫는 말인가?

간단히 말하자면 클래스란 객체의 설계도이다.

클래스와 객체를 설명하려는 것은 ‘닭이 먼저냐 계란이 먼저냐’를 따지는 일처럼 설명하기 곤란하다.

<br/>

객체라는 용어를 사용하지 않고 클래스를 설명하기 어렵고 그 반대도 마찬가지이다.

하지만, 우리는 어떤 것이 먼저인지 알고 있다. 그건 바로 클래스가 먼저이다.

클래스가 없으면 객체를 인스턴스화할 수 없다.

<br/><br/>

## 객체 생성

객체의 템플릿이라고 생각하거나, 과자를 여러 모양으로 잘라 구울 때 쓰는 모양틀에 비유할 수 있다.

각 객체에는 고유한 속성(데이터)과 행위(함수 또는 루틴)가 있다.

<br/>

클래스로 생성할 모든 객체가 소유할 속성과 행위가 정의되어 있다.

클래스로 객체를 생성하므로, 클래스에 객체의 기본 빌딩 블록을 정의 해야 한다.

<br/><br/>

## 속성

클래스의 데이터는 속성으로 표시된다.

각 클래스는 해당 클래스에서 인스턴스화된 각 객체의 상태를 저장할 속성을 정의 해야 한다.

<br/><br/>

## 메서드

메서드는 클래스의 필수 행위를 구현한다.

클래스에서 인스턴스화된 모든 객체에는 해당 클래스에서 정의한 메서드가 포함되어 있다.

<br/>

메서드는 다른 객체에서 호출된 행위(메시지)를 구현하거나 클래스의 기본 내부 행위를 제공할 수 있다. 


<br/>내부 행위란 다른 객체가 접근할 수 없는 비공개(private) 메서드를 말한다.

Person 클래스에서 행위는 getName(), setName() 이러한 메서드들을 사용하면 그 밖의 객체가 이 객체의 

속성값을 살펴본 후에 변경할 수 있다.

어떤 객체도 다른 객체의 속성을 직접 변경해서는 안된다.

<br/><br/>

## 메시지

메시지는 객체 간의 소통 메커니즘이다.

예를 들어, 객체 A가 객체 B의 메서드를 호출할 때 객체 A는 객체 B에 메시지를 전송한다.

객체 B의 응답은 반환값으로 답장하게 되는 것이다.

<br/>

객체의 비공개(private) 메서드를 다른 객체에서 호출할 수 없는 반면에, 공개(public) 메서드를 다른 객체에서 호출할 수 있다.

Payroll 객체는 getName() 메서드를 통해  Person 객체의 name 속성을 조회하기 위해 Person 객체로 메시지를 전송한다.

<br/><br/>

## 캡슐화 및 데이터 은닉

캡슐화는 객체 속에 속성뿐만 아니라 행위도 함께 들어 있다는 사실에 기반하여 정의할 수 있는 개념

데이터 은닉은 캡슐화의 주요 부분이다.

<br/>

예들 들어, 숫자의 제곱을 계산하는 객체라면 계산 결과를 얻을 수 있게 하는 인터페이스를 제공해야 한다. 

그러나 제곱을 계산하는 데 사용된 내부 속성 및 알고리즘을 요청 객체에 제공할 필요는 없다.

캡슐화를 엽두에 두고 클래스를 설계하면 클래스가 견고해진다.

<br/><br/>

## 인터페이스

클래스 설계는 적절한 인스턴스화 및 연산을 위한 인터페이스를 지정한다.

<br/>

### 비공개 데이터

데이터 은닉이 제대로 작동하려면 모든 속성을 private으로 선언해야 한다.

따라서 속성은 인터페이스의 일부가 아니다.

<br/>

public 메서드들만이 클래스 인터페이스의 일부이다.

속성을 public 으로 선언하게 되면 데이터 은닉 개념이 깨진다.

<br/>

### 구현부

사용자는 정답이 제대로 나오는 한 제곱근을 계산하는 방법에 신경 쓰지 않는다.

따라서 구현부는 인터페이스와 다르게 언제든 필요할 때 변경 할 수 있으며, 

변경해도 나머지 사용자 코드에 영향을 미치지 않는다.

<br/>

예를 들어, 계산기를 제조해서 판매하는 회사가 있다고 할때, 

계산 결과에 영향을 미치지 않게 하면서도 내부 알고리즘을 바꿀 수 있을 것이다.

<br/><br/>


## 인터페이스/구현부 패러다임의 실제 예시

토스터기에는 전기가 필요하다.

전기를 얻으려면 토스터기의 코드를 전기 콘센트(인터페이스)에 꽂아야 한다.

<br/>

필요한 전기를 얻기 위해 모든 토스터기는 전기 콘센트 규격에 맞게 코드를 구현 해야 한다.

이러한 규격은 토스터기와 전력 회사 사이의 인터페이스 이다.

<br/>

실제 구현부 부분이 석탄을 태워서 전기를 생산하는 발전소이든 그렇지 않든 간에

토스터기 쪽에서 신경 쓸 일이 아니다.

인터페이스 사양을 준수하는 한 모든 기기에 전기를 공급할 수 있다.

![이미지](/programming/img/사고프로세스3.PNG)

<br/><br/>

## 인터페이스/구현부 패러다임의 모델

```java
public class IntSquare {
	 public int getSquare(int value) {
		 return calculateSquare(value);
	 }

	 private int calculateSquare(int value) {
		 return value * value;
	 }
}
```

공개 메서드인 getSquare(인터페이스)다.

제곱 알고리즘의 구현부는 비공개인 calculateSquare() 메서드에 있다.

<br/>

또한, 사용자가 이 속성이 존재한다는 점을 알 필요가 없으므로 squareValue 속성은 공개되지 않는다.

따라서, 우리는 구현부의 일부를 감췄다.

<br/>

객체는 사용자가 인터페이스와 상호 작용해야 하는 인터페이스만 나타내며, 

객체 사용과 관련이 없는 세부 사항은 다른 객체에는 숨겨진다.

구현부가 변경되더라도 인터페이스는 변경할 필요가 없다.

<br/>

사용자는 인터페이스가 변하지 않아서 이전과 동일한 함수를 사용할 수 있지만,

구현부는 변경되었다. 데이터를 다루는 코드를 작성할 때 이게 아주 중요하다.

예를 들어, 사용자가 애플리케이션 코드를 변경하지 않은 채로 데이터 저장소를 파일이 아닌 데이터베이스로 바꿀 수 있기 때문이다.

<br/><br/>

## 합성

객체에 다른 객체가 들어있다고 생각하는게 자연스럽다.

텔레비전에는 동조기와 화면이 포함되어 있다.

컴퓨터에는 비디오 카드와 키보드 및 드라이버가 있다.

<br/>

컴퓨터 자체도 객체로 간주 할 수 있지만, 그 안에 담긴 디스크 드라이버 또한 객체와 다름 없다.

컴퓨터에는 디스크 드라이버와 같은 객체가 그 밖에도 여러 개 들어 있다.

이런식으로 객체를 종종 그 밖의 객체들을 사용해 구축하거나 합성할 수 있는데, 이것을 합성이라는 개념이다.

<br/><br/>

## 정리

캡슐화 : 객체지향 및 개발에서 데이터와 행위를 단일 객체로 캡슐화(즉, ‘봉지로 둘러싸기’ 또는 ‘포장’)하는 것이 가장 중요하다. 

단일 객체에는 데이터와 행위가 모두 포함되며, 이러한 데이터와 행위 중에 우리가 원하는 것들을 골라 그밖의 객체로 부터 은닉해 둘 수 있다.

<br/><br/>

참고 : 

>**Reference** <br/>http://www.yes24.com/Product/Goods/90688759