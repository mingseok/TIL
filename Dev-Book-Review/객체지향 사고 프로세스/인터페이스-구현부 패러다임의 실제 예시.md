## 인터페이스/구현부 패러다임의 실제 예시

클래스 설계는 적절한 인스턴스화 및 연산을 위한 인터페이스를 지정한다.

<br/>

## 비공개 데이터

데이터 은닉이 제대로 작동하려면 모든 속성을 private으로 선언해야 한다.

따라서 속성은 인터페이스의 일부가 아니다.

<br/>

public 메서드들 만이 클래스 인터페이스의 일부이다.

속성을 public 으로 선언하게 되면 데이터 은닉 개념이 깨진다.

<br/><br/>

## 구현부

사용자는 정답이 제대로 나오는 한 제곱근을 계산하는 방법에 신경 쓰지 않는다.

따라서 구현부는 인터페이스와 다르게 언제든 필요할 때 변경 할 수 있으며, 

변경해도 나머지 사용자 코드에 영향을 미치지 않는다.

<br/>

예를 들어, 계산기를 제조해서 판매하는 회사가 있다고 할때, 

계산 결과에 영향을 미치지 않게 하면서도 내부 알고리즘을 바꿀 수 있을 것이다.

<br/><br/>

## 인터페이스/구현부 패러다임의 실제 예시

토스터기에는 전기가 필요하다.

전기를 얻으려면 토스터기의 코드를 전기 콘센트(인터페이스)에 꽂아야 한다.

필요한 전기를 얻기 위해 모든 토스터기는 전기 콘센트 규격에 맞게 코드를 구현 해야 한다.

<br/>

이러한 규격은 토스터기와 전력 회사 사이의 인터페이스 이다.

실제 구현부 부분이 석탄을 태워서 전기를 생산하는 발전소이든 그렇지 않든 간에 토스터기 쪽에서 신경 쓸 일이 아니다.

<br/>

인터페이스 사양을 준수하는 한 모든 기기에 전기를 공급할 수 있다.

![이미지](/programming/img/사고프로세스3.PNG)

<br/><br/>

## 인터페이스/구현부 패러다임의 모델

```java
public class IntSquare {
	 public int getSquare(int value) {
		 return calculateSquare(value);
	 }

	 private int calculateSquare(int value) {
		 return value * value;
	 }
}
```

공개 메서드인 `getSquare`(인터페이스)다.

제곱 알고리즘의 구현부는 비공개인 `calculateSquare()` 메서드에 있다.

따라서, 우리는 구현부의 일부를 감췄다.

<br/>

객체는 사용자가 인터페이스와 상호 작용해야 하는 인터페이스만 나타내며, 

객체 사용과 관련이 없는 세부 사항은 다른 객체에는 숨겨진다.

구현부가 변경되더라도 인터페이스는 변경할 필요가 없다.

<br/>

사용자는 인터페이스가 변하지 않아서 이전과 동일한 함수를 사용할 수 있지만,

구현부는 변경되었다. 데이터를 다루는 코드를 작성할 때 이게 아주 중요하다.

<br/>

예를 들어, 사용자가 애플리케이션 코드를 변경하지 않은 채로 데이터 저장소를 파일이 아닌 

데이터베이스로 바꿀 수 있기 때문이다.

<br/><br/>

## 합성

객체에 다른 객체가 들어있다고 생각하는게 자연스럽다.

텔레비전에는 동조기와 화면이 포함되어 있다.

컴퓨터에는 비디오 카드와 키보드 및 드라이버가 있다.

<br/>

컴퓨터 자체도 객체로 간주 할 수 있지만, 그 안에 담긴 디스크 드라이버 또한 객체와 다름 없다.

컴퓨터에는 디스크 드라이버와 같은 객체가 그 밖에도 여러 개 들어 있다.

이런식으로 객체를 종종 그 밖의 객체들을 사용해 구축하거나 합성할 수 있는데, 이것을 합성이라는 개념이다.

<br/><br/>

## 정리

캡슐화 : 객체지향 및 개발에서 데이터와 행위를 단일 객체로 캡슐화(즉, ‘봉지로 둘러싸기’ 또는 ‘포장’)하는 것이 가장 중요하다. 

단일 객체에는 데이터와 행위가 모두 포함되며, 이러한 데이터와 행위 중에 우리가 원하는 것들을 골라 그밖의 객체로 부터 은닉해 둘 수 있다.

<br/><br/>

참고 : 

>**Reference** <br/>http://www.yes24.com/Product/Goods/90688759