## 예제로 구현하는 파일 업로드, 다운로드

실제 파일이나 이미지를 업로드, 다운로드 할 때는 몇가지 고려할 점이 있는데, 

구체적인 예제로 알아보자.

<br/>

### 요구사항

- 상품을 관리

    - 상품 이름
    - 첨부파일 하나
    - 이미지 파일 여러개
- 첨부파일을 업로드 다운로드 할 수 있다.
- 업로드한 이미지를 웹 브라우저에서 확인할 수 있다.

<br/>

### Item - 상품 도메인

```java
package hello.upload.domain;

@Data
public class Item {

    private Long id;
    private String itemName;
    private UploadFile attachFile;
    private List<UploadFile> imageFiles;
}
```

<br/>

### ItemRepository - 상품 리포지토리

```java
package hello.upload.domain;

@Repository
public class ItemRepository {

    private final Map<Long, Item> store = new HashMap<>();

    private long sequence = 0L;

    public Item save(Item item) {
        item.setId(++sequence);
        store.put(item.getId(), item);
        return item;
    }

    public Item findById(Long id) {
        return store.get(id);
    }
}
```

<br/>

### UploadFile - 업로드 파일 정보 보관

```java
package hello.upload.domain;

@Data
public class UploadFile {

    private String uploadFileName;
    private String storeFileName;

    public UploadFile(String uploadFileName, String storeFileName) {

        this.uploadFileName = uploadFileName; // originalFilename 넘어 온것이다.
        this.storeFileName = storeFileName; // storeFileName 넘어 온것이다.
    }
}
```

`uploadFileName` : 고객이 업로드한 파일명

`storeFileName` : 서버 내부에서 관리하는 파일명

고객이 업로드한 파일명으로 서버 내부에 파일을 저장하면 안된다. 

<br/>

왜냐하면 서로 다른 고객이 같은 파일이름을 업로드 하는 경우 

기존 파일 이름과 충돌이 날 수 있다. 

<br/>

서버에서는 저장할 파일명이 겹치지 않도록 내부에서 관리하는 별도의 파일명이 필요하다.

### FileStore - 파일 저장과 관련된 업무 처리 (주석으로 설명)

```java
package hello.upload.file;

@Component
public class FileStore {

    @Value("${file.dir}")
    private String fileDir;

    public String getFullPath(String filename) {
        return fileDir + filename;
    }

    /**
     * 여기 부분은 여러개 업로드 할때 사용 하는 것이다.
     */
    public List<UploadFile> storeFiles(List<MultipartFile> multipartFiles) throws IOException {

        // 왜 이렇게 하는가?
        // public UploadFile storeFile( ``` 에서 계속 생성 되는걸
        // 여기에 담아주기 위해서 이다.
        List<UploadFile> storeFileResult = new ArrayList<>();

        for (MultipartFile multipartFile : multipartFiles) {
            if (!multipartFile.isEmpty()) { // 비어 있지 않으면 조건문 실행
                storeFileResult.add(storeFile(multipartFile));
            }
        }
        return storeFileResult;
    }

    /**
     * 여기 부분은 하나를 업로드 할때 사용 하는 것이다.
     */
    // 파일 저장
    public UploadFile storeFile(MultipartFile multipartFile) throws IOException {

        if (multipartFile.isEmpty()) {
            return null;
        }

        // originalFilename 을 구했다.
        String originalFilename = multipartFile.getOriginalFilename();

        // 오리지널 파일 이름이 예를들어 image.png 이다.
        // 그러면 이걸 서버에 어떻게 저장할까?

        // 서버에 저장하는 파일명 구하는 코드.
        // 그리고 storeFileName 을 구했다.
        String storeFileName = createStoreFileName(originalFilename); // "qwe-qwsd-2342-esd.png" 넘어 왔다.

        // getFullPath(storeFileName) 넣으면 'fileDir + filename' 으로 반환 해주고, 파일로 만들어준다.
        multipartFile.transferTo(new File(getFullPath(storeFileName)));

        return new UploadFile(originalFilename, storeFileName);
    }

    private String createStoreFileName(String originalFilename) {

        // png 꺼내는 코드
        String ext = extractExt(originalFilename);

        // uuid 로 한다. 그런데 맨뒤에 확장자(=png)는 가져 오고 싶은 것이다.
        String uuid = UUID.randomUUID().toString();

        // 저장할 파일 name
        // "qwe-qwsd-2342-esd.png" 를 리턴하게 되는 것이다.
        return uuid + "." + ext;
    }

    private String extractExt(String originalFilename) {

        // 확장자를 뽑는다.
        int pos = originalFilename.lastIndexOf(".");
        return originalFilename.substring(pos + 1);
    }
}
```

<br/>

멀티파트 파일을 서버에 저장하는 역할을 담당한다.

- `createStoreFileName()` : 서버 내부에서 관리하는 파일명은 유일한 이름을
    
    생성하는 UUID 를 사용해서 충돌하지 않도록 한다.
    
- `extractExt()` : 확장자를 별도로 추출해서 서버 내부에서 관리하는 파일명에도 붙여준다.
    
    예를 들어서 고객이 a.png 라는 이름으로 업로드 하면 `51041c62-86e4-4274-801d-`
    
    `614a7d994edb.png` 와 같이 저장한다.
    
- MultipartFile 주요 메서드
    - `file.getOriginalFilename()` : 업로드 파일 명
    - `file.transferTo(...)` : 파일 저장

<br/>

### ItemForm - 상품 저장용 폼이다.

```java
package hello.upload.controller;

import lombok.Data;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Data
public class ItemForm {

    // 여기는 여러개 할때.

    private Long itemId;
    private String itemName;
    private MultipartFile attachFile; // 파일을 첨부
    private List<MultipartFile> imageFiles;

//    MultipartFile attachFile : 멀티파트는 @ModelAttribute 에서 사용할 수 있다.
//    List<MultipartFile> imageFiles : 이미지를 다중 업로드 하기 위해 MultipartFile 를 사용했다.

}
```

`MultipartFile attachFile` : 멀티파트는 `@ModelAttribute` 에서 사용할 수 있다.

`List<MultipartFile> imageFiles` : 이미지를 다중 업로드 하기 위해 `MultipartFile` 를 사용했다.

<br/>

### ItemController - 컨트롤러

```java
package hello.upload.controller;

@Slf4j
@Controller
@RequiredArgsConstructor
public class ItemController {

    private final ItemRepository itemRepository;
    private final FileStore fileStore;

    @GetMapping("/items/new")
    public String newItem(@ModelAttribute ItemForm form) {
        return "item-form";
    }

    @PostMapping("/items/new")
    public String saveItem(@ModelAttribute ItemForm form,
                           RedirectAttributes redirectAttributes) throws IOException {

//      MultipartFile attachFile1 = form.getAttachFile();
//      UploadFile uploadFile = fileStore.storeFile(attachFile1);

        // 위에 있는 두줄을 한줄로 만든 것이다.
        UploadFile attachFile = fileStore.storeFile(form.getAttachFile());

//      List<MultipartFile> imageFiles = form.getImageFiles();
//      List<UploadFile> uploadFiles = fileStore.storeFiles(imageFiles);

        // 위에 있는 두줄을 한줄로 만든 것이다.
        List<UploadFile> storeImageFiles = fileStore.storeFiles(form.getImageFiles());

        // -- 여기까지만 한다면 파일에 저장은 된다. --

        //데이터베이스에 저장
        // 이제 데이터베이스에 저장 하는 방법.
        // 결국 데이터베이스에 저장하는 것은 파일을 저장하는 것이 아니라,
        // 경로 정도만 저장하는 것이다.
        Item item = new Item();
        item.setItemName(form.getItemName());
        item.setAttachFile(attachFile);
        item.setImageFiles(storeImageFiles);
        itemRepository.save(item);
        redirectAttributes.addAttribute("itemId", item.getId());
        return "redirect:/items/{itemId}";
    }

    @GetMapping("/items/{id}")
    public String items(@PathVariable Long id, Model model) {
        Item item = itemRepository.findById(id);
        model.addAttribute("item", item);
        return "item-view";
    }

    /**
     * 이미지를 보여 줄때이다.
     */
    @ResponseBody
    @GetMapping("/images/{filename}")
    public Resource downloadImage(@PathVariable String filename) throws MalformedURLException {

        // 이렇게 파일을 접근 하는 것이다.
        // "file:/Users/.../file/68465ff-dddf-49dc-a003-c531351.png"
        // 바이너리 데이터를 웹브라우저에 전송
        return new UrlResource("file:" + fileStore.getFullPath(filename));
    }

    /**
     * 다운로드 하는 부분.
     * 그냥 눌러 버리면 그 파일을 열어 버리는 것이다.
     * 이걸 방지하기 위해 "attachment; filename=\"" + encodeUploadFileName + "\"";
     * 사용하여 파일이 열리지 않고, 다운로드 받을 수 있게 되었던 것이다.
     */
    @GetMapping("/attach/{itemId}")
    public ResponseEntity<Resource> downloadAttach(@PathVariable Long itemId) throws MalformedURLException {

        // 이 item을 접근 할 수 있는 사용자만 이 파일을 다운로드 받을 수 있게 하는 것이다.
        // 이렇게 하는 이유는, 아무나 자료를 다운로드 받을 수 있게 해서는 안되서 그런 것이다.
        Item item = itemRepository.findById(itemId);
        String storeFileName = item.getAttachFile().getStoreFileName();
        String uploadFileName = item.getAttachFile().getUploadFileName();

        UrlResource resource = new UrlResource("file:" + fileStore.getFullPath(storeFileName));

        log.info("uploadFileName={}", uploadFileName);

        String encodedUploadFileName = UriUtils.encode(uploadFileName, StandardCharsets.UTF_8);
        String contentDisposition = "attachment; filename=\"" + encodedUploadFileName + "\"";

        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition).body(resource);
    }
}
```

- `@GetMapping("/items/new")` : 등록 폼을 보여준다.
- `@PostMapping("/items/new")` : 폼의 데이터를 저장하고 보여주는 화면으로 리다이렉트 한다.
- `@GetMapping("/items/{id}")` : 상품을 보여준다.
- `@GetMapping("/images/{filename}")` : 태그로 이미지를 조회할 때 사용한다. 
    
    `UrlResource` 로 이미지 파일을 읽어서 @ResponseBody 로 이미지 바이너리를 반환한다.
    
- `@GetMapping("/attach/{itemId}")` : 파일을 다운로드 할 때 실행한다.
    
    예제를 더 단순화 할 수 있지만, 파일 다운로드 시 권한 체크 같은 복잡한 상황까지 가정한다. 
    
    생각하고 이미지 id 를 요청하도록 했다. 파일 다운로드 시에는 고객이 업로드한 파일 이름으로 
    
    다운로드 하는게 좋다. 이때는 `Content-Disposition` 해더에 `attachment; filename="업로드 파일명"`값을 주면 된다.
    
<br/>

### item-form.html

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container">
    <div class="py-5 text-center">
        <h2>상품 등록</h2>
    </div>
    <form th:action method="post" enctype="multipart/form-data">
        <ul>
            <li>상품명 <input type="text" name="itemName"></li>
            <li>첨부파일<input type="file" name="attachFile"></li>
            <li>이미지 파일들<input type="file" multiple="multiple" name="imageFiles"></li>
        </ul>
        <input type="submit"/>
    </form>
</div> <!-- /container -->
</body>
</html>
```

다중 파일 업로드를 하려면 `multiple="multiple"` 옵션을 주면 된다.

`ItemForm` 의 다음 코드에서 여러 이미지 파일을 받을 수 있다.

`private List<MultipartFile> imageFiles;`

<br/>

### item-view.html

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
</head>
<body>
<div class="container">

    <div class="py-5 text-center">
        <h2>상품 조회</h2>
    </div>

    상품명: <span th:text="${item.itemName}">상품명</span><br/>
    첨부파일: <a th:if="${item.attachFile}" th:href="|/attach/${item.id}|" th:text="${item.getAttachFile().getUploadFileName()}"/><br/>
    <img th:each="imageFile : ${item.imageFiles}" th:src="|/images/${imageFile.getStoreFileName()}|" width="300" height="300"/>

</div> <!-- /container -->
</body>
</html>
```

첨부 파일은 링크로 걸어두고, 이미지는 <img> 태그를 반복해서 출력한다.

<br/>

### 실행
localhost:8080/items/new

실행해보면 하나의 첨부파일을 다운로드 업로드 하고, 여러 이미지 파일을 한번에 업로드 할 수 있다

![이미지](/programming/img/나77.PNG)

<br/>

이렇게 출력 되는 걸 알 수 있다.

![이미지](/programming/img/나78.PNG)

<br/>

## 콘솔 보기

![이미지](/programming/img/나79.PNG)

<br/>

![이미지](/programming/img/나80.PNG)

<br/>

>**Reference** <br/>스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2