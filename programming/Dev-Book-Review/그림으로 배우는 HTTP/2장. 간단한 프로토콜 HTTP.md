## 간단한 프로토콜 HTTP

## HTTP는 클라이언트와 서버 간에 통신을 한다.

텍스트와 이미지 등과 같은 리소스를 필요하다고 요구 하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다.

한번 통신했을 때만 본다면 클라이언트와 서버의 역할은 반드시 정해져 있다.

<br/>

HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있습니다.

```
GET /index.html HTTP /1.1
Host: www.hackr.jp
```

- “GET”은 서버에 요구하는 종류를 나타내고 있으며 메소드라고 불린다.

- “/index.html” 은 요구 대상인 리소스를 나타내고 있는데, 리퀘스트 URI 라고 합니다.
- “HTTP /1.1” 은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호 입니다.

<br/>

즉, 여기서의 리퀘스트 내용은 HTTP 서버 상에 있는 “/index.html” 라는 리소스가 필요하다는 리퀘스트 입니다. 

리퀘스트 메시지는 메소드, URIL, 프로토콜, 버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성 된다.

![이미지](/programming/img/간단한프로토콜1.PNG)

<br/>

![이미지](/programming/img/간단한프로토콜2.PNG)

(그림 참조 : [https://beomy.github.io/tech/etc/http/](https://beomy.github.io/tech/etc/http/))

<br/>

리퀘스트를 받은 서버는 리퀘스트 내용을 처리한 결과를 리스폰스로 클라이언트에 되돌려 준다.

```
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
...
```

- “HTTP /1.1”은 서버의 HTTP 버전을 나타낸다.

- “200 OK”는 리퀘스트의 처리 결과를 나타내는 상태 코드
- 다음 줄은, 리스폰스가 발생한 일시를 나타내고 있는데 헤더 필드중 하나이다.
- 그리고 빈 줄로 구분하고, 아래에 있는 부분이 바디라고 불리는 리소스 본체이다.

<br/>

기본적으로 리스폰스 메시지는 프로토콜 버전, 상태 코드, 그 상태 코드를 설명한 프레이즈, 

옵션의 리스폰스 헤더 필드와 바디로 구성 되어 있다.

![이미지](/programming/img/간단한프로토콜3.PNG)

<br/><br/>

## HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지하지 않는 스테이트리스 프로토콜 이다.

- HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다는 것이다.

<br/>

### HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성된다.

- 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않는다.

<br/>

### 이유는? 

많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 위해서 이와 같이 간단하게 설계되어 있는 것이다.

그러나 웹이 진화함에 따라, 스테이트리스 특성만으로는 처리하기 어려운 일이 증가 되었다.


<br/>


### 예를 들면, 쇼핑 사이트에 로그인했을 때이다.

다른 페이지로 이동하더라도 로그인 상태를 유지할 필요가 있다.

즉, 누가 어떤 리퀘스트를 보냈는지를 파악하기 위해 상태를 유지할 필요가 있다.

그리하여 쿠키라는 기술을 도입한것이다.

<br/><br/>

## 리퀘스트 URI로 리소스를 식별

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다.

이 URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출이 가능한 것이다.

<br/><br/>

## 서버에 임무를 부여하는 HTTP 메소드

### GET: 리소스 획득

- 리퀘스트 URI로 식별된 리소스를 가져올수 있도록 요구
- 리소스 내용은 지정된 리소스를 서버가 해석한 결과

<br/>

### POST: 엔티티 전송

- 엔티티를 전송하기 위해서 사용
- GET 또한 엔티티를 전송할수 있지만, 일반적으로 POST 를 사용

<br/>

### PUT: 파일 전송

- 파일을 전송하기 위해서 사용
- 요청에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구
- HTTP/1.1 PUT은 인증기능이 없어 누구든지 파일업로드가 가능한 보안 문제가 있다.
- 일반적인 웹보다는 인증 기능과 짝을 이루거나 REST 와 같이 연계하는 양식에서 사용된다.

<br/>

### HEAD: 메세지 헤더 취득

- GET과 같은 기능이지만 메세지 바디를 돌려주지 않는다.
- URI 유효성과 리소스 갱신시간을 확인하는 목적 등으로 사용
- 리스폰스 헤더만 되돌려준다.

<br/>

### DELETE: 파일 삭제

- 파일 삭제를위해 사용된다.
- PUT 과 반대로 동작하며 지정된 리소스를 삭제한다.
- 인증기능이 없어 일반적인 웹사이트 에서는 사용되지 않는다.
- 인증기능이 포함된 웹앱 또는 REST를 사용하는 경우 사용된다.

<br/>

### OPTIONS: 제공하고 있는 메소드의 문의

- 지정된 리소스가 제공하고 있는 메소드를 조사하기 위해 사용

<br/>

### CONNECT: 프록시에 터널링 요구

- 프록시에 터널 접속확립을 요함으로, TCP 통신을 터널링 시키기위해 사용
- 주로 SSL, TLS 등의 프로토콜로 암호화된 것을 터널링 시키기위해 사용

<br/><br/>

## 지속 연결로 접속량을 절약

초기 당시는 작은 사이즈의 텍스트를 보내는 정도였기 때문에 문제가 없었다.

그러나, HTTP가 널리 보급되어감에 따라 다량의 이미지를 포함한 문서 등이 늘었다.

예를 들면, 하나의 HTML에 여러 이미지가 포함되어 있는 경우

이미지를 획득하기 위해서 여러 리퀘스트를 송신한다.

<br/>

그렇기 때문에 리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

<br/>

### 이 문제를 해결하기 위해 지속 연결이라는 방법을 고안한다.

지속 연결의 특징은 어느 한 쪾이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

지속 연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감된다.

또한, 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시 할 수 있다.

<br/><br/>

## 파이프라인화

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다.

리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 

리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.

그리하여 리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없다.

<br/>

### 예를 들자면, 

HTML 한 페이지에 10개의 이미지를 포함한 웹 페이지를 리퀘스트한 경우에는 개별 연결보다 

지속 연결이 리퀘스트 완료가 빠르고, 게다가 지속 연결 보다 파이프라인화 쪽이 빠릅니다.

이 차이는 리퀘스트의 수가 늘어날수록 현저하게 나타 납니다.

<br/><br/>

## 쿠키를 사용한 상태 관리

HTTP는 스테이트리스 프로토콜이기 때문에, 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않았습니다. 

결국, 과거 상태를 근거로 해서 현재 리퀘스트를 처리한다는 것은 불가능 했습니다.

<br/>

예를 들자면, 인증이 필요한 웹 페이지에서 상태 관리를 하지 않는다면 인증을 마친 상태를 잊어버리기 때문에 

새로운 페이지로 이동할 때마다 재차 로그인 정보를 보내든지 리퀘스트마다 매개 변수나 추가 정보를 

붙여서 로그인 상태를 관리해야 하는 상황이 발생했습니다.

<br/>

(물론 스테이트리스 프로토콜에도 이점이 있다. 상태를 유지하지 않는다는 점에서 서버의 

CPU나 메모리 같은 리소스의 소비를 억제할 수 있다)

<br/>

### 이런 문제를 해결하기 위해 쿠키를 도입한다.

쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.

쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다. 

다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼때, 자동으로 쿠키 값을 넣어서 송신한다.

<br/>

서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 

서버 상의 기록을 확인해서 이전 상태를 알 수 있습니다.

<br/>

서버 : 쿠키를 발행, 누구에게 무엇을 전달했는지 기억해둔다.

클라이언트 → 서버 : “앗, 전에 왔던 사람이다.”

<br/>

### 리스폰스(서버가 쿠키를 발행)

```
HTTP /1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
<Set-Cookie: sid=12341234235; path=/;expires=Wed, => 10-Oct-12 07:12:20 GMT>
Content-Type: text/plain; charset=UTF-8
```

<br/>

### 리퀘스트(보관하고 있던 쿠키를 자동 송신)

```
GET /image/ HTTP /1.1
Host: www.youngjin.com
Cookie: sid=12341234235
```