## 객체 지향과 인지 능력



객체라고 부를 수 있는 다양한 존재를 볼 수 있다.

객체 = 인간이 분명하게 인지하고 구별 할 수 있는 물리적이고, 개념적인 것이라고 생각한다

- 현실 세계에서는 사람이 직접 주문 금액 계산하지만,소프트웨어 세계에서는 주문 객체가 자신의 금액을 계산한다.
- 현실 세계의 전등은 사람의 손길 없이는 스스로 불을 밝힐 수 없지만, 

    소프트웨어 세계의 전등은 외부의 도움 없이도 스스로 전원을 켜거나 끌 수 있다.

    <br/>

예를 들어 ‘사람들’ , ‘자동차’ , ‘가로수’ , ‘컴퓨터’ , ‘모니터’ 등등

### 객체지향세계 ≠ 현실세계

<br/><br/>

## 객체, 그리고 이상한 나라



저자는 객체지향을 **이상한 나라의 앨리스**  동화책에 기초하여 설명 하십니다.

### 앨리스의 행동에 따라 상태 변화

상태 결정 = 행동

행동의 결과 결정 = 상태

<br/>

결국 행동의 결과는 상태에 의존적이다.

행동 = -20cm

상태 = 280cm → (행동) 260 = 행동의 결과는 상태로 결정

<br/>

행동 간 순서 중요하다고 알려주고 있다. → 이유는 “목적을 달성할 수 있기 때문”

1. 앨리스는 상태를 갖는다. (=상태는 변경 가능하다)

2. 앨리스의 상태를 변경 시키는 것은 앨리스의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술 가능

    - 행동의 순서가 결과에 영향을 미친다.
3. 앨리스는 어떤 상태여도 식별 가능하다

즉, 나의 생각으로는 
앨리스의 상태를 결정하는 것은 행동이지만, 행동의 결과를 결정하는 것은 상태라고 생각한다.

<br/>

## 객체 그리고 SW나라



객체는 ‘상태’ , ‘행동’ , ‘식별자’ 이다.

그리고, 숫자, 문자열, 양, 속도, 시간, 날짜 → 객체가 아니다. 객체의 특성 이다.


<br/><br/>

## 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다. 

- 즉, 어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존한다는 것이다

<br/>

앨리스가 문을 통과하기 위해서는 자신의 키를 작게 줄여야만 한다.

- 문을 통과한다는 행동의 결과를 예상할 수 있는 방법은 앨리스가 과거에 음식을 먹었던 적이 있는지 살펴보는 것이다.

- 하지만 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 복잡하고 번거로우며 <br/>이해하기 어렵다고 말하고 있습니다.

<br/>

따라서 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안했다

- 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.
- 앨리스의 키와 문의 높이라는 상태만 알면 문을 통과하는 행동의 결과를 쉽게 예측할 수 있는 것이다.

<br/>

그러므로, **상태란? 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다.**

1. 여행을 위해 비행기를 이용하려면 탑승 전에 항공권을 발권해야 한다. <br/>항공권을 발권해 놓았다면 비행기를 탈 수 있겠지만, 발권하지 않았다면 비행기를 타지 못한다. 

2. 다른 예로 자판기에 충분한 금액을 투입하기전에는 원하는 음료를 선택할 수 없다.

3. 엘리베이터가 움직이기 위해서는 먼저 원하는 층의 버튼을 눌러야 한다. 
4. 텔리비전 전원을 켜지 않는 한 채널을 변경할 수 없다.
5. 여자친구와 드라이브 하려면 먼저 자동차의 시동을 걸어야 한다.

<br/>

### 상태와 프로퍼티

- 단순한 값은 객체가 아니지만 객체의 상태를 표현하기 위한 중요한 수단이다.
- 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 **프로퍼티** 라고 한다.
- 프로퍼티는 정적인 반면, **프로퍼티 값** 은 동적이다.
- 링크 = 객체와 객체 사이 의미 있는 연결
    - Link 통해서 메시지 주고 받기 가능
- 객체 간의 선으로 표현되는 링크와 달리 객체를 구성하는 단순한 값은 **속성** 이라고 한다.

<br/>

왜 상태가 필요 할까? 라는 질문에 대한 답은

- 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.
- 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.

<br/><br/>

## 행동


객체의 상태를 변경하는 것은 객체의 자발적인 행동 뿐이다.

- 앨리스가 특정한 행동을 취할 때마다 앨리스의 키와 위치가 변경된다.

- 객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 **부수 효과** 를 초래한다는 것을 의미한다.
- 행동의 결과 = 상태 의존적 (결국 이게 상태니깐 똑같다 생각한다..)

<br/>

### 상태와 행동 사이의 관계

객체의 행동은 상태에 영향 받는다.

- 상호작용이 현재 상태에 어떤 방식으로 의존하는가

객체의 행동은 상태를 변경 시킨다.

- 상호작용이 어떻게 현재 상태를 변경 시키는가

<br/>

### 상호 작용

- 다른 객체와의 협력
- 다른 객체에 요청을 보내기 (메시지 따라 행동) → (자신 상태 변경)
- 객체의 행동
- 다른 객체 상태 변경도 가능하다

<br/>

### 협력과 행동

- 객체는 다른 객체와 메시지를 통해서만 의사소통할 수 있다.
- 객체는 수신된 메시지에 따라 적절히 행동하면서 협력에 참여하고 그 결과로 자신의 상태를 변경한다.

<br/>

### 상태 캡슐화

객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.

- 현실 세계라면 음료는 스스로 아무것도 할 수 없는 수동적인 존재다.

- 객체지향 세계에서는 음료 객체의 양을 줄이는 것은 메시지를 전달 받은 음료 스스로의 몫이다.
- 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않으며, 외부에 노출하는 것은 행동 뿐이다.

- 감추기 = 상태
- 노출하기 = 행동 (다른 객체 접근 유일 법)

<br/>

상태 변경 여부는 그 객체의 자율!! 

캡슐화 → 자율성이 좋다, 지능이 놓다, 협력에 유연하다

<br/>

### 상태를 캡슐화해야 하는 이유는?

상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은, 

객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.

<br/>

### 캡슐화 추가 설명.

현실과 객체지향 세계가 다른것은 상태가 캡슐화 되어있다는 점. 

현실과 달리 객체 지향 세계에서는 앨리스 객체는 음료 객체에게 음료를 마셧다는 메세지를 

전달해 음료객체 스스로 상태 값을 변화 시켜야 한다. 

<br/>

음료 객체의 상태 변화는 메세지 송신자인 앨리스 객체는 알지 못하고 음료 객체만이 알고 있다. 

이러한 것을 상태 캡슐화라 한다.

<br/><br/>

## 식별자


객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.

<br/>

### 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태르 변경한다.

- 따라서 객체는 가변 상태를 가진다고 말한다.

- 인간의 인지 능력을 이용해 식별 가능한 경계를 가진 모든 사물
- 구별 가능한 특정 property = 식별자 존재

<br/>

### 값의 상태는 변하지 않기 때문에 불변 상태를 가진다고 말한다.

값(value) - 식별자가 없다

- 변하지 않는 값 모델링
- 불변 상태
- 원시적인 타입
- 상태가 같은지로 판단
- 동등성 = 상태를 이용해 두 값이 같은지 판단 가능

<br/>

객체 - 식별자가 있다.

- 시간에 따라 변경되는 상태를 포함한다.
- 가변 상태
- 두 객체의 상태가 모두 같아도 두 객체는 다르다 (식별자가 필요)
- 동일성 = 식별자 기반으로 객체가 같은지 판단가능
- 식별자가 상태에 독립적이다.

<br/>

그리고

타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다뤄야 한다.

- 동명이인에 키도 동일하다고 해서 두 사람이 같은 사람은 아니다.
- 하지만 키도 작고 나이가 어린 과거의 나는 현재의 나와 동일한 인물이다.

<br/><br/>

## 기계로서의 객체


개발자 → 객체 상태 조회 / 상태 변경 (get / set)

### 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.

- 객체의 상태를 조회하는 작업을 쿼리

- 객체의 상태를 변경하는 작업을 명령

이 두 가지가 대부분의 행동이다.

<br/>

### 기계 버튼으로 설명한 챕터.

버튼 : 상태조회 / 변경 ~ 객체 행동 유발 위해 메시지 전송

→ 사용자는 버튼으로만 객체 접근 (= 인터페이스)

사용자는 객체가 제공하는 명령과 쿼리로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.

<br/><br/>

## 행동이 상태를 결정한다.


객체의 상태를 먼저 결정하고 행동을 나중에 결정하는 경우 설계에 나쁜 영향을 끼친다.

선 상태 → 후 행동 은 나쁜 방법.

- 상태가 공용 인터페이스 그대로 노출 가능성이 높다

    - 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 <br/>공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.

- 객체가 협력자 x 고립된 섬O

    - 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 <br/>자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다.
- 객체 재사용성 저하

<br/>

협력 안에서 객체의 행동은 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다.

- 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.
- 책임-주도 설계는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.

<br/><br/>

## 책임-주도 설계란..?

"상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다"

<br/>

예를 들어

호랑이라는 객체에 ‘상태’ 는 ‘움직임’ 이라는 것이고, 상태 함수가 ‘달린다’ 가 있다고 생각해 봅시다

그리고 독수리라는 객체가 추가되면 ‘상태’ 는 ‘움직임’ 이라는 것이 같고, ‘상태’는 ‘난다’ 인데 <br/>여기서 상태 함수가 원래 ‘달린다’ 여서 못쓰는 겁니당

<br/>

## 즉, 위에 설명이 무슨 말인가?

컴파일 의존성을 줄이는 방향이라고 보는 게 맞는 것 같다 <br/>
컴파일 의존성 = 클래스 사이의 의존성 <br/>

### 예를 들자면,

A 클래스에서 B 클래스의 함수를 호출한다고 했을 때 나중에 B 대신 C로 갈아끼고 싶다고 해도 <br/>이미 A에서 B의 함수를 직접 코드에서 호출하니까 그 호출하는 부분도 모두 갈아끼워야 하죠 <br/>근데 객체지향에서 지원하는 상속과 인터페이스 구조를 사용한다면 공통되는 인터페이스 I를 두고 B와 C가 그걸 상속받게 할 수 있고 <br/>코드 상에서 A가 I에 대해 함수를 호출하게 만들면 특정 컨트롤러 상에서 B를 만드느냐 C를 만드느냐만 해결하면 <br/>이제 자유롭게 B와 C를 갈아치울 수 있는거고요 이게 런타임에 메서드를 선택한다... 라고 보시면 되겠습니다

<br/><br/>

## 은유와 객체

현실과 객체지향 세계의 가장 큰 다른점은 현실 속의 수동적 존재가 능동적으로 변한다는 것이다. 

현실의 객체는 객체지향 세계속에서 현실보다 더 많은 행동을 할 수 있게 되고 이를 객체의 의인화라고 부른다.

<br/>

wrong) ‘객체 지향이란 현실 세계의 모방’ 

객체 지향 → 현실세계의 추상화(=추상화란 자신이 원하는 특성만 취함)

결국 현실을 간추리고 요약해 모방 이란게 아니라는 것이다.

<br/>

즉, 현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점

- 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다.
- 소프트웨어 객체가 현실 객체의 부분적인 특징을 모장하는 것이 아니라 현실 객체가 가지지 못한 추가적인 능력을 보유하게 된다.

<br/><br/>

## 의인화

현실 : 수동적인 존재 

sw 객체 : 능동적인 존재(추가적인 능력) → 현실 보다 더 많은 일이 가능하다.

현실보다 sw에서 더 능력 있는 객체

현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 **의인화** 라고 부른다.

<br/>

## 은유

현실 세계와 객체지향 세계는 **은유** 의 관계를 가지고 있다.

- 은유란 실제로는 적용되지 않는 한 가지 개념을 이용해 다른 개념을 서술하는 대화의 한 형태다.
- 그 여자는 양 같아요, 그 남자는 사자 같아요

현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.

표현적 차이, 의미적 차이 두가지가 있다.

<br/>

차이 = SW 생각하는 모습, 실제 SW 표현의 차이

은유 관계의 실체 객체 이름을 SW 객체 이름으로 사용하자.

이해와 유지보수가 좋아진다.

<br/>

깔끔하게 현실세계 무시 → 나만의 새로운 SW세계 창조.

소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, <br/>이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다.

<br/><br/>

참고 : 

>**Reference** <br/>https://product.kyobobook.co.kr/detail/S000001628109