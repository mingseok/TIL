# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차

1. 실무에서는 `new HashMap<>()` 안되는 이유.

2. `List<List<Integer> 정렬 방법`

3. join, joining

4. 우테코 - 페어매칭 기술

5. 우테코 - 최단거리 기술

6. contains에 대한 오해

---

<br/><br/>

## 1번. 실무에서는 `new HashMap<>()` 안되는 이유.

실무에서는 `new HashMap<>()` 하면 안되고, `new ConcurrentHashMap<>()` 을 사용해야 한다. 

이유는 쓰레드 문제 이므로, 여러 사람들이 접속 했을때, `new HashMap<>()` 인 경우 전부 받을 수 없기 때문이다.

그리고 `long` 도 같은 이유다. `AtomicLong` 을 사용해야 된다.


<br/><br/>

## 2. List<List<Integer>> 정렬 방법


```java
for (List<Integer> randomNumber : randomLotto) {
    randomLottoTicket.add(randomNumber.stream().sorted().collect(Collectors.toList()));
}
```

<br/><br/>

## 3. join, joining

### join("추가할 문자", "대상 list")

```java
ArrayList foods = new ArrayList<>();

	foods.add("피자");

	foods.add("치킨");

	foods.add("맥도날드");

	foods.add("불고기");

	foods.add("샐러드");

	System.out.println(String.join(", ", foods));

출력 : 피자, 치킨, 맥도날드, 불고기, 샐러드
```

### Collectors.joining("추가할 문자")

[https://www.techiedelight.com/ko/collectors-joining-method-java/](https://www.techiedelight.com/ko/collectors-joining-method-java/)

```java
public class run {
    public static void main(String[] args) {
        List<String> colors = Arrays.asList("RED", "BLUE", "BLACK", "GREEN");

        // 요소를 문자열로 변환하고 쉼표로 구분하여 연결합니다.
        String joined = colors.stream().collect(Collectors.joining(", "));

        System.out.println(joined);
    }
}

출력 : RED, BLUE, BLACK, GREEN
```

<br/><br/>

## 4. 우테코 - 페어매칭

### 파일 입출력

조건. Files 보기 - [https://hianna.tistory.com/587](https://hianna.tistory.com/587)

![이미지](/programming/img/페어매칭.PNG)


<br/><br/>

## 5. 우테코 - 최단거리

```java
class a {
    public static void main(String[] args) {

      WeightedMultigraph<String, DefaultWeightedEdge> graph =
              new WeightedMultigraph<>(DefaultWeightedEdge.class);

      graph.addVertex("서울역");
      graph.addVertex("부산역");
      graph.addVertex("광주역");

      graph.setEdgeWeight(graph.addEdge("서울역", "부산역"), 1);
      graph.setEdgeWeight(graph.addEdge("부산역", "광주역"), 1);
      graph.setEdgeWeight(graph.addEdge("서울역", "광주역"), 100);

      DijkstraShortestPath shortestPath = new DijkstraShortestPath<>(graph);
      List<String> path = shortestPath.getPath("서울역", "광주역").getVertexList();

      double distance = shortestPath.getPathWeight("서울역", "광주역");

      System.out.println(distance);

    }
}

출력시 -> System.out.println(distance);
출력: 2.0

출력시 -> System.out.println(path);
출력: [서울역, 부산역, 광주역]
```

<br/>

![이미지](/programming/img/우테코.PNG)


<br/><br/>

## 6. contains에 대한 오해

지금까지 contains는 컬렉션에만 적용되는것 인줄 알았다..

하지만, 내생각이 틀렸다. `String`인 문자열에서도 가능하다.

```java
public static void main(String[] args) {
    String SSS = " a ana";

    if (SSS.contains("n")) {
        System.out.println("있다");
    }
}
```

### 다음 상황 처럼은 안된다.

```java
int num = 12345; // 사용 못함
int[] numberArr = {1,2,3,4,5,5,6}; // 사용 못함
String[] strArr = {"abc", "abc", "ac", "ccc", "bb"}; // 사용 못함
```




<br/><br/>

## 7. ㅁㅁ





<br/><br/>

## 8. ㅁㅁ





<br/><br/>

## 9. ㅁㅁ





<br/><br/>

## 10. ㅁㅁ





<br/><br/>

## 11. ㅁㅁ





