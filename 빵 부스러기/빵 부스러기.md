# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---

<br/><br/>


### 소켓(Socket)의 개념과 역할
1. 소켓의 정의와 배경
소켓은 1986년 BSD UNIX 4.3에서 개정된 통신 접속점으로, 처음에는 BSD UNIX 4.1에서 소개되었습니다.
네트워크 응용 프로그램이 데이터를 송수신하는 창구 역할을 하며, 추상적인 개념으로 소프트웨어로 구현됩니다.
2. 소켓의 기능과 역할
통신 창구:
소켓은 응용 프로그램이 TCP/IP 프로토콜을 통해 네트워크에 접근할 수 있는 인터페이스를 제공합니다.
프로세스 간 연결:
두 소켓이 연결되면 서로 다른 프로세스 간 데이터 전달이 가능해집니다.
캡슐화:
소켓을 통해 네트워크 계층과 전송 계층의 기능을 응용 프로그램에서 캡슐화하여 사용할 수 있습니다.
3. 소켓의 역사적 배경
캘리포니아 버클리 대학 분교에서 UNIX용으로 개발되었습니다.
UNIX의 파일 입출력 표준인 open(), read(), write(), close() 메커니즘을 따릅니다.
4. TCP/IP 소켓 통신
포트 사용:
클라이언트와 서버 프로그램은 각각 고유한 포트를 통해 통신합니다.
포트는 연결 설정과 데이터 교환 모두에 사용됩니다.
소켓의 종류:
서버 소켓: 서버에서 사용하며 클라이언트 요청을 기다립니다.
클라이언트 소켓: 서버와 연결을 설정하고 데이터를 교환합니다.
자바에서의 활용:
소켓을 통해 자바 프로그램에서 네트워크 통신을 구현할 수 있습니다.

 

- 클라이언트 프로그램과 서버 프로그램은 각각 자신이 포트를 통해 통신해야 한다.
- 연결을 할때도 포트를 사용하고 데이터를 교환할때도 포트를 사용한다.
- 자바 프로그램 안에서 포트를 사용하기 위해서는 소켓을 이용해야 한다.
- 자바안에서 소켓의 종류에는 서버소켓과 클라이언트 소켓이 있다.

---

<br/>

### 소켓과 저수준 I/O 개념 정리
1. Socket Library
소켓 라이브러리는 소켓을 구현하기 위한 다양한 함수를 제공하여 개발자가 별도의 구현 없이 소켓을 사용할 수 있도록 돕습니다.
운영 체제의 프로토콜 스택에 데이터 송신을 요청하면, 소켓 라이브러리는 내부 도구들을 정해진 순서대로 호출하여 작업을 처리합니다.
이후 논리적인 파이프라인이 완성되면, 상대방에게 데이터를 전송하게 됩니다.

2. Low-Level I/O (저수준 I/O)
정의:
저수준 I/O는 ANSI 표준 함수가 아닌, 리눅스 운영 체제에서 제공하는 파일 입출력 함수들을 의미합니다.
표준이 아니므로 다른 운영 체제와의 호환성은 보장되지 않습니다.

특징:
리눅스에서는 소켓을 파일로 취급하므로, 저수준 I/O 함수를 이용해 소켓 데이터를 송수신할 수 있습니다.
예: open(), close(), write(), read() 등.

3. File Descriptor (파일 디스크립터)
정의:
파일 디스크립터는 Linux/Unix 계열 시스템에서 파일을 식별하기 위해 사용되는 정수 값입니다.
프로세스는 파일에 접근하기 위해 파일 디스크립터를 사용하며, 이를 메모리에 저장해 관리합니다.

특징:

fd 0: 표준 입력 (Standard Input)
fd 1: 표준 출력 (Standard Output)
fd 2: 표준 에러 (Standard Error)
저수준 I/O 함수는 파일 디스크립터를 입력으로 받아 처리하며, 소켓과의 데이터 송수신도 동일한 방식으로 수행됩니다.
4. 소켓 통신의 전형적인 흐름
소켓은 생성부터 소멸까지 반드시 정해진 절차를 따라야 정상적으로 동작합니다.
특히 클라이언트와 서버의 소켓 동작에는 차이가 있습니다.

서버:
소켓을 생성하고 클라이언트의 연결 요청을 기다립니다.
클라이언트:
서버에 연결 요청을 보낸 후, 서버와 통신을 시작합니다.
소켓 통신 흐름을 한 번에 이해하기 어렵다면, 이후 관련 개념을 학습한 후 다시 흐름을 살펴보는 것이 효과적입니다.


---

3-2. 연결 요청 ( connect() )
connect() API는 IP주소와 포트 번호로 식별되는 대상으롤 연결 요청을 보낸다. connect() API는 블록(Block) 방식으로 동작하기 때문에 연결 요청에 대한 결과가 결정되기 전에는 connect()의 실행이 끝나지 않는다. connect() API 호출이 성공하면 send() / recv() API를 통해 데이터를 주고 받을 수 있다.


3-3. 데이터 송수신 ( send() / recv() )
연결된 소켓을 통해 데이터를 보낼 때는 send(), 데이터를 받을 때는 recv() API를 사용한다. send()와 recv() API 역시 블록(Block) 방식으로 동작하기 때문에 두 API 모두 실행 결과가 결정되기 전까지는 API가 리턴되지 않는다.

---

클라이언트 연결 요청 대기 ( listen() )
서버 소켓에 포트 번호를 결합(bind)하고 나면, 서버 소켓을 통해 클라이언트의 연결 요청 수신을 기다리게 되는데 이 역할을 listen() API가 수행한다.

listen() API는 서버 소켓에 바인딩된 포트 번호로 클라이언트의 연결 요청이 있는지 확인하며 대기 상태에 머무른다. 클라이언트에서 호출된 connect() API에 의해 연결 요청이 수신되면 대기 상태를 종료하고 리턴한다.

listen() API가 대기 상태에서 빠져나오는 경우는 두 가지이다. 클라이언트 요청이 수신되는 경우와 에러가 발생(소켓 close() 포함)하는 경우다. 그런데 listen() API가 성공하더라도 리턴 값에는 요청이 수신되었는지, 실패해서 에러가 발생했는지에 대한 정보만 있고, 요청에 대한 정보는 들어있지 않다.

대신 클라이언트 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐(Queue)에 쌓이게 되는데, 이 시점에서 클라이언트와의 연결은 아직 완전히 연결되지 않은 대기 상태이다. 대기 중인 연결 요청을 큐(Queue)로부터 꺼내와서 연결을 완료하기 위해서는 accept() API를 호출해야 한다.

---

### TCP란 무엇인가?

TCP 소켓 통신을 구현해보기에 앞서, TCP가 무엇인지부터 이해하고 넘어가는 것이 좋다고 생각한다. 우선 TCP란 Transmission Control Protocol의 줄임말으로, 주된 특징으로는 다음과 같다.

서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.
데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜이다.
데이터가 전달되는 과정에서 손실되거나 순서가 뒤바뀔 수 있으나, TCP는 손실을 검색하여 이를 교정할 수 있다.
특징에 대한 간략한 소개는 여기서 마치고, 참조할 만한 사이트 링크를 첨부하겠다.
[참조] https://kotlinworld.com/94

클라이언트 접속 부분
```
private void connect_btn_Click(object sender, EventArgs e)
{
	... 	// IP, Port가 정상적으로 입력되었는지 확인하는 부분
    
    Thread connectThread = new Thread(new ThreadStart(Connect));
    connectThread.IsBackground = true;
    connectThread.Start();
}
```
Connect 버튼을 클릭하게 되면 위의 코드가 실행된다. 메인 쓰레드에서 connectThread를 분리하여 Connect() 메소드를 실행시킨다. (분리시키는 이유는 메인 쓰레드에서 바로 Connect 시, 클라이언트가 접속하지 않은 시간동안은 메인 쓰레드가 아무것도 할 수 없기 때문이다..)
```
private void Connect() 
{
	try
    {
    	TcpListener listener = new TcpListener(IPAddress.Parse(ip), int.Parse(port));
        listener.Start();
        WriteLog("Ready to connect ...");

        client = listener.AcceptTcpClient();
        WriteLog("Client connected!");
    }
    catch (Exception ex)
    {
    	Debug.WriteLine(ex.ToString());
    }
}
```
메인 쓰레드에서 분리된 connectThread에서 실행된 Connect() 메소드이다. TcpLister라는 클래스는 TCP 네트워크 클라이언트에서 연결을 수신한다. 파라미터로 전달되는 IPAddress.Parse(ip), int.Parse(port)는 사용자로부터 입력받은 IP와 Port다. listener.Start();를 통해 들어오는 연결 요청 수신 대기를 시작한다.

client = listener.AcceptTcpClient(); 이 부분의 client는 전역에서 선언된 private static TcpClient client = new TcpClient();다. TcpClient 클래스는 TCP 네트워크 서비스에 대한 클라이언트 연결을 제공한다. listener.AcceptTcpClient() 이 부분에서 클라이언트의 접속을 기다리고, 접속이 된 경우에 client 객체로 클라이언트의 정보를 넘겨준다.


---


### 서버 전체 코드

```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SocketProgramming
{
    public partial class Tcp_Server : Form
    {
        private static string ip = string.Empty;
        private static string port = string.Empty;

        private static TcpClient client = new TcpClient();

        public Tcp_Server()
        {
            InitializeComponent();
        }

        private void Tcp_Server_Load(object sender, EventArgs e)
        {
            Thread receiveThread = new Thread(new ThreadStart(Receive));
            receiveThread.IsBackground = true;
            receiveThread.Start();
        }

        private void Receive()
        {
            while (true)
            {
                if (client.Connected)
                {
                    try
                    {
                        NetworkStream stream = client.GetStream();
                        byte[] buffer = new byte[1024];
                        int bytes = stream.Read(buffer, 0, buffer.Length);
                        if (bytes <= 0)
                        {
                            continue;
                        }

                        string message = Encoding.UTF8.GetString(buffer, 0, bytes);
                        WriteLog("[Other] " + message);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex.ToString());
                    }
                }
            }
        }

        private void connect_btn_Click(object sender, EventArgs e)
        {
            ip = tb_ip.Text;
            port = tb_port.Text;
            if (ip.Split('.').Length != 4 || port == "")
            {
                tb_ip.Text = string.Empty;
                tb_port.Text = string.Empty;
                return;
            }

            Thread connectThread = new Thread(new ThreadStart(Connect));
            connectThread.IsBackground = true;
            connectThread.Start();
        }

        private void Connect()
        {
            try
            {
                TcpListener listener = new TcpListener(IPAddress.Parse(ip), int.Parse(port));
                listener.Start();
                WriteLog("Ready to connect ...");

                client = listener.AcceptTcpClient();
                WriteLog("Client connected!");
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void send_btn_Click(object sender, EventArgs e)
        {
            string message = tb_message.Text;
            if (message.Length <= 0) { return; }

            try
            {
                NetworkStream stream = client.GetStream();
                byte[] buffer = Encoding.UTF8.GetBytes(message);
                stream.Write(buffer, 0, buffer.Length);

                WriteLog("[Me] " + message);
                tb_message.Text = string.Empty;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void WriteLog(string text)
        {
            string date = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            Invoke(new MethodInvoker(delegate ()
            {
                tb_log.AppendText("[" + date + "] " + text + "\r\n");
            }));
        }
    }
}
```


### Snapshot/M(Milstone)/RC(Release candidate)

Snapshot
daily build 버전.
실험 중인 버전.
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
M(Milstone)
Snapshot 보다 정리가 잘 되어 있는 버전. 
실험 중인 버전. 
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
RC(Release candidate)
Milstone 본다 더 정리가 잘 되어저 배포된 버전. 
왠만하면 개발된 기능들은 그대로 배포된다.

---

### 왜 인덱스가 필요할까?
테이블에 데이터가 많아지면 전체 테이블을 탐색(Full Table Scan) 하면 시간이 오래 걸립니다.
인덱스는 책의 목차처럼 작동하여, 원하는 데이터를 빠르게 찾을 수 있도록 돕습니다.

인덱스는 내부적으로 B-Tree(Balanced Tree) 구조로 저장됩니다.
MySQL이 인덱스를 사용하면 검색 시 이진 탐색과 같은 방식으로 데이터를 빠르게 찾을 수 있습니다.

상황	인덱스가 필요한 이유
WHERE 조건문에 자주 사용	특정 조건에 맞는 데이터를 빠르게 찾기 위해
JOIN 연산이 많은 경우	두 테이블을 연결할 때 검색 속도를 높이기 위해
ORDER BY 사용 시	데이터를 정렬할 때 성능을 최적화하기 위해
UNIQUE 제약 조건	중복되지 않는 값을 보장하기 위해

### 인덱스 생성

```sql
-- 단일 인덱스 생성
CREATE INDEX idx_name ON users(name);

-- 복합 인덱스 생성
CREATE INDEX idx_name_email ON users(name, email);
```

### Primary Key와 Unique Index

```sql
-- 테이블 생성 시 기본 키 인덱스
CREATE TABLE users (
    id INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(50),
    email VARCHAR(50),
    PRIMARY KEY (id)
);

-- Unique 인덱스
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

### Fulltext Index

```sql
-- 게시글 내용에 Fulltext 인덱스 생성
CREATE TABLE articles (
    id INT NOT NULL AUTO_INCREMENT,
    title VARCHAR(255),
    content TEXT,
    PRIMARY KEY (id),
    FULLTEXT (content)
);
```

### Composite Index 사용 예시

```sql
-- 복합 인덱스 생성
CREATE INDEX idx_user_info ON users(name, email);

-- 복합 인덱스를 활용한 쿼리
SELECT * FROM users
WHERE name = 'MinSeok' AND email = 'minseok@example.com';
```

### 인덱스가 효과적인 경우와 비효과적인 경우

효과적인 경우	비효과적인 경우
WHERE 조건에 자주 사용되는 컬럼	작은 테이블에서는 인덱스가 큰 이점이 없음
JOIN 연산이 자주 발생하는 경우	자주 변경되는 컬럼에 인덱스를 걸면 오히려 비효율
ORDER BY, GROUP BY에 사용되는 경우	WHERE 조건 없이 단순 조회하는 경우

---



### MVCC의 핵심 개념
Undo Log

이전 데이터를 보존하여 트랜잭션의 스냅샷을 제공
Rollback 시 데이터를 복구하거나 과거 버전을 읽을 때 사용
Transaction ID (트랜잭션 ID)

각 트랜잭션마다 고유한 ID를 부여하여 데이터 버전 관리에 사용
Hidden Columns

InnoDB 테이블에는 숨겨진 컬럼이 있으며, 데이터의 버전 정보를 관리
DB_TRX_ID : 마지막으로 변경된 트랜잭션 ID
DB_ROLL_PTR : Undo Log를 가리키는 포인터
Read View

트랜잭션이 시작될 때 Read View가 생성되어, 해당 시점의 데이터 스냅샷을 기반으로 조회

### MySQL MVCC 동작 예시
아래 예시를 통해 트랜잭션 간의 충돌이 MVCC로 어떻게 해결되는지 확인해보겠습니다.

### 실전 예제: MVCC 트랜잭션 처리 과정

### 테이블 생성
sql
코드 복사
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO users (name, balance) VALUES ('MinSeok', 1000);


### 트랜잭션 시나리오: 두 트랜잭션이 동시에 데이터를 처리
트랜잭션 1: 사용자 A가 조회 후 업데이트
sql
코드 복사
-- 트랜잭션 1 시작
START TRANSACTION;

-- 현재 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

-- balance를 1000 증가
UPDATE users SET balance = balance + 1000 WHERE name = 'MinSeok';
트랜잭션 2: 사용자 B가 동일한 데이터를 조회
sql
코드 복사
-- 트랜잭션 2 시작
START TRANSACTION;

-- 현재 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

### 트랜잭션이 동시에 실행될 때의 MVCC 동작 과정

트랜잭션 1이 데이터를 읽을 때, 해당 데이터의 스냅샷이 생성됩니다.
트랜잭션 2가 동일한 데이터를 조회할 때, 트랜잭션 1의 변경 사항은 보이지 않습니다.
이는 MVCC가 트랜잭션이 시작된 시점의 스냅샷을 제공하기 때문입니다.

### 결과 확인: 트랜잭션이 완료된 후

트랜잭션 1 커밋 후 상태:
sql
코드 복사
-- 트랜잭션 1 커밋
COMMIT;
트랜잭션 2 커밋 후 상태:
sql
코드 복사
-- 트랜잭션 2 커밋
COMMIT;

### 트랜잭션 2가 조회한 데이터는 트랜잭션 1의 변경 사항이 반영되지 않았던 시점의 스냅샷을 기준으로 조회합니다.

### Read View의 역할 확인
sql
코드 복사
-- 트랜잭션 시작
START TRANSACTION;

-- 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

-- 결과
+----+---------+---------+
| id | name    | balance |
+----+---------+---------+
|  1 | MinSeok | 1000    |
+----+---------+---------+
트랜잭션이 시작된 이후에는 다른 트랜잭션이 데이터를 변경해도 현재 트랜잭션의 조회 결과는 동일합니다.

🛠 MVCC의 주요 이점
1️⃣ 잠금 없이 동시 읽기 처리

데이터를 읽을 때 다른 트랜잭션이 변경 중이더라도 락 없이 읽기 가능
2️⃣ 일관된 읽기(Consistent Read)

트랜잭션이 시작된 시점의 스냅샷을 기준으로 일관된 데이터를 제공합니다.
3️⃣ Rollback 가능

변경 사항이 커밋되지 않으면 Undo Log를 통해 이전 상태로 복원 가능합니다.

### 핵심 포인트 요약
MySQL의 InnoDB 엔진은 MVCC를 지원하여 일관된 읽기와 동시성 제어를 제공합니다.
MVCC는 Undo Log를 통해 이전 버전의 데이터를 관리하며, 트랜잭션이 시작된 시점의 스냅샷을 제공합니다.
트랜잭션 격리 수준 중 REPEATABLE READ가 MySQL의 기본 격리 수준이며, MVCC의 주요 이점을 활용합니다.

---

### 대칭키 / 공개키 / 암호화 방식

대칭키
암호화, 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘

동일한 키를 주고 받기 때문에, 매우 빠르다는 장점.
그러나 대칭키 전달과정에서 해킹 위험에 노출

공개키 / 비대칭키
암호화와 복호화에 사용하는 암호키를 분리한 알고리즘

자신이 가지고 있는 고유한 암호키(비밀키)로만 복호화 할 수 있는 암호키(공개키)를 공개.

과정
1. A가 웹 상에 공개된 B의 공개키를 이용해 데이터를 암호화 하여 B에게 송신
2. B는 자기가 가진 비밀키로 복호화한 데이터를 확인후, A의 공개키로 응답을 암호화 하여 A에게 송신
3. A는 자신의 비밀키로 응답문을 복호화.
