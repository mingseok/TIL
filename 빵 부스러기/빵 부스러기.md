# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---


### MySQL 서브쿼리 최적화 기법 정리

### 1. **테이블 풀 아웃(Table Pull-out)**

- 서브쿼리에 사용된 테이블을 메인 쿼리로 끌어와 조인으로 변환하는 최적화.
- `IN (subquery)` 형태의 세미 조인에서 자주 발생.
- EXPLAIN 실행 계획에서 별도로 "Using table pullout"과 같은 문구는 표시되지 않음.
- 확인 방법:
    - 실행 계획에서 id 칼럼 값이 동일하면 서브쿼리가 조인으로 변환된 것.
    - `SHOW WARNINGS` 명령어를 사용하면 MySQL 옵티마이저가 변환한 쿼리를 볼 수 있음.
- **제한 사항:**
    - 세미 조인에서만 사용 가능.
    - 서브쿼리 부분이 UNIQUE 인덱스의 프라이머리 키 룩업 결과가 1건인 경우에만 적용 가능.
    - 서브쿼리 테이블을 아우터 쿼리로 가져와 조인하는 방식으로 변환.

---

### 2. **퍼스트 매치(First Match)**

- `IN (subquery)` 형태의 세미 조인을 `EXISTS (subquery)` 형태로 변환하는 최적화 기법.
- 서브쿼리를 조인으로 변환하여, 첫 번째 매칭되는 레코드를 찾으면 즉시 종료.
- **특징:**
    - 실행 계획에서 id 칼럼 값이 1로 설정됨.
    - Extra 칼럼에 "FirstMatch(table-N)" 문구가 표시됨.
- **제한 사항:**
    - 서브쿼리에서 하나의 레코드만 검색되면 최적화 효과가 큼.
    - 서브쿼리에서 GROUP BY가 사용된 경우 최적화 적용 불가.
    - `optimizer_switch`에서 `semijoin`, `firstmatch` 옵션이 모두 활성화되어야 함.

---

### 3. **루스 스캔(LooseScan)**

- 세미 조인에서 인덱스를 활용한 최적화 기법으로, `GROUP BY`와 함께 사용할 때 성능 향상.
- 서브쿼리 테이블의 프라이머리 키를 활용해 유니크한 값만 읽어 불필요한 레코드 접근을 최소화.
- **특징:**
    - 실행 계획의 Extra 칼럼에 "LooseScan" 문구 표시.
    - id 칼럼의 값이 1로 설정됨.
- **제한 사항:**
    - 루스 인덱스 스캔이 가능한 조건이 필요.
    - `optimizer_switch`에서 `loosescan` 옵션을 활성화해야 사용 가능.

---

### 4. **구체화(Materialization)**

- 서브쿼리의 결과를 임시 테이블로 생성하여, 반복 실행 시 성능을 최적화하는 방식.
- **특징:**
    - 실행 계획에서 select_type이 "MATERIALIZED"로 표시됨.
    - 서브쿼리 결과를 캐싱하여 동일한 서브쿼리 실행을 최소화.
- **제한 사항:**
    - `IN (subquery)`에서 서브쿼리는 상관 서브쿼리(Correlated subquery)가 아니어야 함.
    - GROUP BY 집합 함수가 사용된 경우만 구체화 가능.
    - `optimizer_switch`에서 `semijoin`, `materialization` 옵션이 활성화되어야 함.

---

### 5. **중복 제거(Duplicated Weed-out)**

- 서브쿼리를 일반적인 `INNER JOIN`으로 변환한 후 중복된 레코드를 제거하는 최적화 기법.
- **특징:**
    - 실행 계획에서 `GROUP BY` 절을 추가하여 중복을 제거.
    - 서브쿼리 결과에서 중복 제거가 필요한 경우에 효과적.
- **제한 사항:**
    - 특정 서브쿼리 패턴에서만 사용 가능.

---

### **요약**

- **Table Pull-out**: 서브쿼리를 메인 쿼리로 변환하여 조인 처리.
- **First Match**: 첫 번째 매칭되는 레코드를 찾으면 즉시 종료.
- **LooseScan**: `GROUP BY` 최적화, 인덱스를 활용해 중복된 접근 최소화.
- **Materialization**: 서브쿼리 결과를 임시 테이블로 저장하여 중복 실행 방지.
- **Duplicated Weed-out**: `INNER JOIN`으로 변환 후 중복 제거.

각 최적화 기법은 특정 조건에서만 동작하며, MySQL 옵티마이저의 설정(`optimizer_switch`)이 중요하게 작용함.


---

### **해시 조인 (Hash Join)**

MySQL 8.0.18부터 도입된 **대량 조인을 최적화하는 방식**. 기존 네스티드 루프 조인보다 속도가 빠름.

**기존 문제:**

- **해시 조인**: 작은 테이블의 데이터를 **메모리에 해시 테이블로 저장**한 후, 큰 테이블에서 해시 매칭 수행 → **빠른 조회 가능**

**동작 방식:**

1. **빌드 단계**: 작은 테이블 데이터를 해시 테이블로 변환.
2. **프로브 단계**: 큰 테이블에서 해시 테이블과 비교하여 매칭되는 데이터 검색.

**설정 방법:**

```sql
SET optimizer_switch='hash_join=on'
```

---

### **인덱스 정렬 선호 (Prefer Ordering Index)**

ORDER BY 또는 GROUP BY를 사용할 때 **인덱스를 활용하여 정렬 속도를 최적화하는 기법**.

**기존 문제:**

- MySQL 옵티마이저가 **ORDER BY, GROUP BY에 적합한 인덱스를 선택하지 않는 경우 발생**.

**해결 방법:**

- `prefer_ordering_index` 설정을 활성화하면 **ORDER BY, GROUP BY에 적합한 인덱스를 우선 선택**.

**설정 방법:**

```sql
SET optimizer_switch='prefer_ordering_index=on';
```

**적용 확인 (EXPLAIN 실행 결과):**

- 실행 계획에서 `"Using index"`가 표시되면 인덱스를 활용한 정렬이 적용된 것.

```sql
EXPLAIN SELECT *
FROM employees
WHERE hire_date BETWEEN '1985-01-01' AND '1985-02-01'
ORDER BY emp_no;
```

---

### **최적화 기법 요약**

| 최적화 기법 | 설명 | 사용 조건 |
| --- | --- | --- |
| **Skip Scan** | 다중 칼럼 인덱스에서 첫 번째 칼럼 없이도 후속 칼럼을 활용 | 다중 칼럼 인덱스 사용 시 |
| **Hash Join** | 대량 조인 시 해시 테이블을 활용하여 빠르게 매칭 | MySQL 8.0.18 이상, 대량 조인 |
| **Prefer Ordering Index** | ORDER BY, GROUP BY 정렬 최적화 | 정렬 연산이 필요한 경우 |

## **인덱스 힌트 (USE INDEX, FORCE INDEX, IGNORE INDEX)**

### **핵심 개념**

| 힌트 | 설명 | 사용 예제 |
| --- | --- | --- |
| **USE INDEX** | 특정 인덱스를 사용하도록 권장 | `USE INDEX (idx_name)` |
| **FORCE INDEX** | 특정 인덱스를 강제로 사용 | `FORCE INDEX (idx_name)` |
| **IGNORE INDEX** | 특정 인덱스를 무시 | `IGNORE INDEX (idx_name)` |

```sql
-- MySQL이 자동으로 인덱스를 선택하도록 권장
SELECT * FROM employees USE INDEX (idx_firstname) WHERE first_name = 'Matt';

-- 특정 인덱스를 강제로 사용
SELECT * FROM employees FORCE INDEX (idx_firstname) WHERE first_name = 'Matt';

-- 특정 인덱스를 사용하지 않도록 설정
SELECT * FROM employees IGNORE INDEX (idx_firstname) WHERE first_name = 'Matt';
```

---

## **실행 시간 제한 (MAX_EXECUTION_TIME)**

### **핵심 개념**

과부하가 걸리는 긴 쿼리를 방지하려면 **쿼리 실행 시간을 제한**할 수 있음.

특히 **대량 데이터 조회 시 타임아웃을 적용하는 용도로 유용**함.

```sql
-- 실행 시간이 100ms를 초과하면 쿼리 강제 중단
SELECT /*+ MAX_EXECUTION_TIME(100) */ * FROM employees ORDER BY last_name LIMIT 1;
```
