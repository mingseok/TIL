# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---


코드의 복잡도가 증가한다.

기존 동기 방식은 순차적으로 실행되기 때문에 이해하기 쉽지만, 비동기 방식은 콜백(Callback) 체인이 생길 수 있어 유지보수가 어려워질 수 있다.
thenApply(), thenCompose() 등의 체이닝이 많아지면 코드가 난해해질 가능성이 있다.
Thread Pool 크기를 적절히 조정하지 않으면 과부하(Overload)가 발생할 수 있다.

Thread Pool 크기가 너무 작으면 대기 시간이 길어지고, 너무 크면 오버헤드(Overhead)가 증가하여 성능이 저하될 수 있다.
적절한 Thread Pool 크기를 설정하고, 모니터링을 통해 최적의 값을 찾아야 한다.
예외 처리(Exception Handling)가 까다롭다.

비동기 작업이 여러 개 실행되기 때문에, 어떤 요청에서 오류가 발생했는지 추적하기 어렵다.
handle(), exceptionally(), whenComplete() 등의 메서드를 활용하여 예외 처리를 체계적으로 구성해야 한다.
병렬 요청 개수를 제한하지 않으면 서버가 과부하에 걸릴 수 있다.

한 번에 너무 많은 요청을 병렬로 실행하면 외부 API에 과부하를 줄 수 있으며, Rate Limit(요청 제한)에 걸릴 가능성이 있다.
이를 방지하려면 배치 크기 제한을 두거나, Rate Limiting(속도 제한) 기법을 적용해야 한다.
디버깅과 트러블슈팅이 어려울 수 있다.

동기 방식에서는 **스택 트레이스(Stack Trace)**를 따라가며 쉽게 디버깅할 수 있지만, 비동기 방식에서는 실행 흐름이 분산되어 있어 추적이 어려울 수 있다.
CompletableFuture의 내부 동작을 잘 이해해야 하고, 로깅(logging)과 모니터링을 적절히 설정해야 한다.
🎯 트레이드오프 (Trade-off) 분석
항목	동기 방식 (Blocking)	비동기 방식 (Non-blocking)
성능	느림 (순차 실행)	빠름 (병렬 실행)
응답 시간	높음 (요청이 많아질수록 증가)	낮음 (최적화 가능)
코드 복잡도	단순	복잡 (콜백, 예외 처리 필요)
자원 사용량	비효율적 (쓰레드 대기 발생)	효율적 (쓰레드 재사용)
예외 처리	쉬움	어려움 (추적 및 관리 필요)
디버깅	쉬움	어려움 (비동기 흐름 분석 필요)
💡 배운 점 및 적용 가능성
비동기와 병렬 처리를 활용하면 성능을 크게 개선할 수 있다.

API 요청을 동시에 실행하면 응답 시간이 줄어들고, 서버의 처리량이 증가한다.
예제에서는 평균 응답 시간이 24초 → 15초 (37% 단축) 되었으며, 실무에서도 활용 가능성이 크다.
비동기 방식 적용 시, 코드 구조를 신중하게 설계해야 한다.

CompletableFuture를 사용하면 성능 개선 효과가 크지만, 코드 복잡도가 증가할 수 있다.
**콜백 지옥(Callback Hell)**을 방지하기 위해, thenApply(), thenCombine() 등의 체이닝을 적절히 사용해야 한다.
Thread Pool과 병렬 요청 개수를 적절히 조정해야 한다.

병렬 요청 개수를 너무 많이 설정하면 오히려 서버가 과부하에 걸릴 수 있다.
Thread Pool 크기를 적절히 조정하고, **Rate Limiting 기법(예: Token Bucket, Leaky Bucket)**을 적용해야 한다.
예외 처리와 로깅을 철저히 해야 한다.

비동기 요청이 많아지면 에러 추적이 어려워질 수 있기 때문에, 예외 처리 전략을 잘 설계해야 한다.
handle(), exceptionally() 등을 사용하여 오류 발생 시 적절한 대응이 가능하도록 해야 한다.
