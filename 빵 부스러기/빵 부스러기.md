# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차

1. 실무에서는 `new HashMap<>()` 안되는 이유.

2. `List<List<Integer> 정렬 방법`

3. join, joining

4. 우테코 - 페어매칭 기술

5. 우테코 - 최단거리 기술

6. contains에 대한 오해

7. hashCode() 란?

8. 우선순위 큐

9. @PostConstruct

10. 추가 내용

---

<br/><br/>

## 1번. 실무에서는 `new HashMap<>()` 안되는 이유.

실무에서는 `new HashMap<>()` 하면 안되고, `new ConcurrentHashMap<>()` 을 사용해야 한다. 

이유는 쓰레드 문제 이므로, 여러 사람들이 접속 했을때, `new HashMap<>()` 인 경우 전부 받을 수 없기 때문이다.

그리고 `long` 도 같은 이유다. `AtomicLong` 을 사용해야 된다.


<br/><br/>

## 2. List<List<Integer>> 정렬 방법


```java
for (List<Integer> randomNumber : randomLotto) {
    randomLottoTicket.add(randomNumber.stream().sorted().collect(Collectors.toList()));
}
```

<br/><br/>

## 3. join, joining

### join("추가할 문자", "대상 list")

```java
ArrayList foods = new ArrayList<>();

	foods.add("피자");

	foods.add("치킨");

	foods.add("맥도날드");

	foods.add("불고기");

	foods.add("샐러드");

	System.out.println(String.join(", ", foods));

출력 : 피자, 치킨, 맥도날드, 불고기, 샐러드
```

### Collectors.joining("추가할 문자")

[https://www.techiedelight.com/ko/collectors-joining-method-java/](https://www.techiedelight.com/ko/collectors-joining-method-java/)

```java
public class run {
    public static void main(String[] args) {
        List<String> colors = Arrays.asList("RED", "BLUE", "BLACK", "GREEN");

        // 요소를 문자열로 변환하고 쉼표로 구분하여 연결합니다.
        String joined = colors.stream().collect(Collectors.joining(", "));

        System.out.println(joined);
    }
}

출력 : RED, BLUE, BLACK, GREEN
```

<br/><br/>

## 4. 우테코 - 페어매칭

### 파일 입출력

조건. Files 보기 - [https://hianna.tistory.com/587](https://hianna.tistory.com/587)

![이미지](/programming/img/페어매칭.PNG)


<br/><br/>

## 5. 우테코 - 최단거리

```java
class a {
    public static void main(String[] args) {

      WeightedMultigraph<String, DefaultWeightedEdge> graph =
              new WeightedMultigraph<>(DefaultWeightedEdge.class);

      graph.addVertex("서울역");
      graph.addVertex("부산역");
      graph.addVertex("광주역");

      graph.setEdgeWeight(graph.addEdge("서울역", "부산역"), 1);
      graph.setEdgeWeight(graph.addEdge("부산역", "광주역"), 1);
      graph.setEdgeWeight(graph.addEdge("서울역", "광주역"), 100);

      DijkstraShortestPath shortestPath = new DijkstraShortestPath<>(graph);
      List<String> path = shortestPath.getPath("서울역", "광주역").getVertexList();

      double distance = shortestPath.getPathWeight("서울역", "광주역");

      System.out.println(distance);

    }
}

출력시 -> System.out.println(distance);
출력: 2.0

출력시 -> System.out.println(path);
출력: [서울역, 부산역, 광주역]
```

<br/>

![이미지](/programming/img/우테코.PNG)


<br/><br/>

## 6. contains에 대한 오해

지금까지 contains는 컬렉션에만 적용되는것 인줄 알았다..

하지만, 내생각이 틀렸다. `String`인 문자열에서도 가능하다.

<br/>

그리고 중요한건 컬렉션에서의 `contains는()` 메서드는 target 데이터랑 

완전히 똑같은게 있어야만 true를 리턴해준다는 
것이다

<br/>

즉, `my_string.contains(target)` 이렇게 문자열이랑 직접적으로 비교할때는 

`my_string`에서 `target`이 포함 되어 있기만 하면 true를 리턴해준다.


<br/>

### 직접 문자열로 비교

```java
public static void main(String[] args) {
    String my_string = "banana";
    String target = "ana";

    if(my_string.contains(target)) {
        System.out.println("찾았다"); // 출력
    }else {
        System.out.println("못찾았다");
    }
}
```

<br/>

### 컬렉션으로 문자열 비교

```java
public static void main(String[] args) {
    String my_string = "banana";
    String target = "ana";

    List<String> arr = new ArrayList<>();
    arr.add(my_string);

    if(arr.contains(target)) {
        System.out.println("찾았다");
    }else {
        System.out.println("못찾았다");  // 출력
    }
}
```

<br/>

### 다음 상황 처럼은 안된다.

```java
int num = 12345; // 사용 못함
int[] numberArr = {1, 2, 3, 4, 5, 5, 6}; // 사용 못함
```




<br/><br/>

## 7. hashCode() 란?

hashCode() 메서드가 반환하는 값은 객체가 생성될 때 고유하게 

식별할 수 있는 값이 아니라, 객체의 내용을 기반으로 계산된 값이다.

<br/>

예를 들어, A 객체와 B 객체 각각의 필드에 "abc"라는 문자열을 포함하고 있다면, 

두 객체의 필드에 있는 "abc" 는 hashCode() 로 부터 계산된(반환하는) 값이 1000(`임의로`)을 

A객체, B객체 각각 1000을 반환해야 한다는 것이다.

<br/>

따라서 A 객체와 B 객체의 hashCode() 메서드가 반환하는 값이 같다.

equals() 메서드는 두 객체가 동등한지를 비교하는 메서드이다.



두 객체가 동등하다는 것은 내용이 같다는 것을 의미한다.

<br/>

그리하여 두 객체가 동등하다면, 그 두 객체의 hashCode() 메서드에서의 반환되는 값도 반드시 같아야 한다.

`Object`클래스의 `hashCode()`는 객체의 주소를 `int`로 변환해서 반환 한다.

<br/>

그리하여 객체의 주소를 가지고 만들기 때문에 객체마다 전~부 다른 값을 가진다.



그래서 → `“객체의 지문”` 이라고도 부른다.

```java
equals()를 오버라이드 한다면, hashCode()도 같이 오버라이드 해야 한다.
```

<br/><br/>

### 두개의 공통점은? → 객체의 주소를 가지고 작업한다.

`equals()`의 결과가 `true`인 두 객체의 해시코드는 같아야 한다.

```java
String str1 = new String("abc");
String str2 = new String("abc");

System.out.println(str1.equals(str2)); // true

System.out.println(str1.hashCode()); // 96354
System.out.println(str2.hashCode()); // 96354
```



### 코드 설명을 하자면,

1. `str1`, `str2` 둘다 `"abc"` 내용이 같다.

2. 그러면, `equals()` 호출 했을때도 `true`가 나오는 게 맞다.
3. 그런데 `true`가 나왔다면, 그 `해쉬코드` 값도 같아야 된다는 것이다.

<br/><br/>

### 예제)

```java
public class Card {
    String kind;
    int number;

    Card() {
        this("SPADE", 1);
    }

    public Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        boolean result = c1.equals(c2);
        System.out.println(result);
    }
}
```

출력은`false` 가 나온다. 

<br/><br/>

### 이유는?

`Card 클래스`에서 `equals()` 를 오버라이드 하지 않았기 때문이다.

그리하여 `Card 클래스`에 `equals()` 를 오버라이드 해줘야 한다.


<br/><br/>

### `equals()` 오버라이드 받기.

단축키 사용하여 `'equals()' and 'hashCode()’` 선택 하여 오버라이드 해줘야 정상 작동 한다.

```java
public class Card {
    String kind;
    int number;

    Card() {
        this("SPADE", 1);
    }

    public Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Card card = (Card) o;
        return number == card.number && kind.equals(card.kind);
    }
}

class abc {
    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        boolean result = c1.equals(c2);
        System.out.println(result);

        System.out.println(c1.hashCode());
        System.out.println(c2.hashCode());
    }
}
```

![이미지](/programming/img/입문247.PNG)

이렇게 출력 되는 것을 알 수 있다.

`true`는 나왔지만, `hashCode` 값들이 이상하다.



해결 방법은 `hashCode()`도 오버라이드 받아서 사용하는 것이다.

<br/><br/>

### `hashCode` 메서드 추가 해보기

```java
public class Card {
    String kind;
    int number;

    Card() {
        this("SPADE", 1);
    }

    public Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Card card = (Card) o;
        return number == card.number && kind.equals(card.kind);
    }

    @Override
    public int hashCode() {
        return Objects.hash(kind, number);
    }
}

class abc {
    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        boolean result = c1.equals(c2);
        System.out.println(result);

        System.out.println(c1.hashCode());
        System.out.println(c2.hashCode());
    }
}
```

![이미지](/programming/img/입문248.PNG)

출력값을 보면 알 수 있듯이, 같은 값이 나오게 되는 걸 알 수 있다.

<br/><br/>

### 규칙.

`equals()` 결과가 `true`가 나오면, `hashCode` 결과도 똑같이 나와야 되는 것이다.

`equals()` 오버라이드 할때 `hashCode`도 같이 오버라이드 해야 된다는 것이다.

`equals()`가 `true` 인 경우에는 → `hashCode`도 일치하도록 해야 한다는 것이다.




<br/><br/>

## 8. 우선순위 큐

정렬 설명은 주석으로 하였다.

```java
class Lecture implements Comparable<Lecture> {
    public int money;
    public int time;

    public Lecture(int money, int time) {
        this.money = money;
        this.time = time;
    }

    @Override
    public int compareTo(Lecture o) {
        return o.time - this.time; // this가 뒤에 있다면 -> 내림차순

        return this.tiem - o.tiem; // -> 오름차순
    }
}

public class Main {
    public int solution() {
        PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder());
        return answer;
    }
}
```


solution() 메서드는 PriorityQueue는 기능을 설정 할 수 있다.

<br/>

### 만약 기존으로 사용한다면?

PriorityQueue<Integer> pQ = new PriorityQueue<>();

poll을 사용 했을때 제일 작은값을 제일 우선순위로 꺼내준다. (디폴드)

<br/>

### 괄호에 값을 넣어준다면?

PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder());

이렇게 작성할 경우. -> 가장 큰값을 우선순위로 꺼내준다.




<br/><br/>

## 9. @PostConstruct

@PostConstruct는 의존성 주입이 이루어진 후 초기화를 수행하는 메서드이다. 

@PostConstruct가 붙은 메서드는 클래스가 service(로직을 탈 때? 로 생각 됨)를 수행하기 전에 발생한다.



<br/><br/>

## 11. ㅁㅁ





