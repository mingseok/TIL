# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---


## SSL이란 무엇인가?

- `SSL(Secure Sockets Layer)`은 인터넷 통신에서 **`데이터를 안전하게 전송하기 위한 초기 보안 프로토콜`**이다.
- 주로 웹 브라우저와 웹 서버 간의 데이터 암호화를 위해 사용되었다.
- SSL은 사용자의 **`비밀번호, 신용카드 정보 등 중요한 정보를 암호화`**하여 네트워크를 통한 정보 유출과 같은 보안 문제를 예방한다. 현재는 보안과 성능을 개선한 **TLS**가 SSL을 대체하여 더 널리 사용되고 있다.

## SSL의 주요 기능

- **`암호화**:` SSL은 데이터가 네트워크를 통해 전달될 때 **`암호화`**하여 중간에서 데이터를 가로채더라도 내용을 이해할 수 없도록 한다.
- **`인증**:` SSL을 사용하면 **`서버 인증서`**를 통해 사용자가 접속하는 웹 서버의 신뢰성을 보장받을 수 있다.
- **`데이터 무결성**:` 전송 중 데이터가 수정되지 않도록 **`해시 함수`**를 사용해 데이터의 무결성을 유지한다.

## SSL과 TLS의 차이?

- SSL은 원래의 보안 프로토콜로 시작되었으나, 시간이 지나며 **`보안 취약점이 발견`**되었다.
- 이러한 문제를 해결하기 위해 **`TLS`**가 개발되었으며, SSL의 후속 프로토콜 역할을 한다고 보면 된다.

## SSL 버전별 특징

### SSL 1.0

- 보안에 심각한 문제점이 많아 **`공식적으로 배포되지 않았다**.`
- 네트워크 보안 수준을 높이는 프로토콜이 필요함을 인식하는 데 기여했으나, 상용 사용에는 적합하지 않았다.

### SSL 2.0

- 데이터를 암호화하여 보호하는 초기 프로토콜로 자리잡았지만, **`중간자 공격`**(MITM)에 취약한 문제점이 있었다.
- 여러 보안 취약점이 발견되었다.

### SSL 3.0

- SSL 2.0의 취약점을 개선한 버전으로, **`더 강력한 인증 방식`**을 도입하여 보안성을 높였다.
- SSL 3.0은 한동안 많이 사용되었으나, 이후 **`POODLE`** 공격에 취약하다는 점이 밝혀졌다.
- 이러한 보안 문제를 해결하기 위해 SSL 3.0은 `더 이상 사용되지 않으며`, TLS 1.0으로 교체되었다.

## SSL과 TLS의 관계

- SSL은 인터넷 보안 통신을 위한 초기 프로토콜로 자리 잡았지만, 이후 여러 보안 취약점이 발견되면서, 이를 대체하기 위해 **`TLS가 개발`**되었다.
- TLS는 SSL 3.0의 구조를 기반으로 보안성을 강화하고 안정성을 개선한 프로토콜이다.

## 정리하기

- SSL은 초기 인터넷 통신 보안을 담당했던 프로토콜로, 웹 상에서 암호화된 연결을 제공했다.
- SSL 1.0부터 시작하여 SSL 3.0까지 발전해왔으나, 여러 보안 취약점으로 인해 현재는 SSL 3.0까지의 프로토콜이 모두 사용되지 않으며, **`TLS가 이를 대체하여 보안 통신의 표준이 되었다**.`
- SSL과 TLS 모두 클라이언트와 서버 간의 안전한 통신을 보장하며, 암호화와 인증을 통해 데이터 유출과 공격으로부터 보호하는 역할을 한다는 것이다.


애플리케이션 서버를 띄울 때 DB 커넥션을 맺는다.
즉, 미리 DB 커넥션들을 만들어 놓는 것이다. (미리 연결 되어 있는 것이라고 생각하기)
db를 들렸다가, 쿼리 응답을 받은 백엔드 서버는 커넥션을 처리해줘야 하는데,
여기서, 커넥션을 커넥션 풀로 반납한다고 생각하면 된다.

---


0 : READ UNCOMMITTED (커밋되지 않은 읽기)
각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있습니다.
정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장합니다.
DIRTY READ 발생
DIRTY READ
트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
💡 예시
트랜잭션 A 가 실행되고 update 됐을 때 그 사이에 트랜잭션 B가 실행된다.
그러면 트랜잭션 A에서 커밋이 되지 않았음에도 불구하고, 트랜잭션 B에서 트랜잭션 A가 update한 내용을 확인할 수 있게 된다.

1 : READ COMMITTED (커밋된 읽기)
COMMIT 이 된 데이터만 읽습니다.

RDB에서 대부분 기본적으로 사용되고 있는 격리 수준

Dirty Read와 같은 현상은 발생하지 않지만 NON-REPEATABLE READ 발생

NON-REPEATABLE READ
하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것
💡 예시
트랜잭션 A에서 update 된 내용이 타 트랜잭션에서 바로 보여지지는 않는다. 근데 트랜잭션 A에서 커밋이 완료되었는데 트랜잭션 B에는 아직 완료되지 않은 경우, 트랜잭션 B에서 다시 한번 조회를 하게 된다면 update 된 상태가 조회가 된다
같은 조회(셀렉트)문인데도 결과가 다르기 때문에 정합성에 어긋난다.

실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.

UNDO 영역: 
간단하게 데이터를 저장하는 버퍼 기능을 한다고 보면 되고, 트랜잭션에서 연산(커밋 롤백)이 이루어지지 않아도 질의문에 의해 수정이 생기면 수정되기 이전 값이 저장되는 영역

2 : REPEATABLE READ (반복 가능한 읽기)
자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT 이 된 데이터만 읽습니다.
MySQL과 MariaDB 가 기본으로 사용하는 격리 수준
MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
PHANTOM READ
다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
💡 예시
같은 테이블에 접근하는 여러개의 트랜잭션을 처리하고 있습니다. 그중 한 트랜잭션이 SELETE ~~ FOR UPDATE 을 사용하여 쓰기 잠금을 걸고 싶다고 가정합니다. 쿼리문에 따라, SELECT하려는 레코드에 쓰기 잠금을 걸어야 하는데, Undo 레코드에는 잠금을 걸 수 없습니다. 따라서 위와 같은 쿼리는 Undo 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 됩니다! 따라서 레코드가 보였다 안보였다 한다고 해서 🎭 PHANTOM 이라고 합니다.

REPEATABLE READ 추가 설명
모든 트랜젝션은 번호를 갖고, undo영역에서는 트랜잭션 번호를 함께 보관합니다.
아까와 같이 트랜잭션 A와 트랜잭션 B가 있습니다. 트랜잭션 A의 번호는 13번이고 트랜잭션 B의 번호는 10번입니다.
트랜잭션 B가 시작했습니다.
➡ 트랜잭션 A에서는 일부 값을 업데이트 하고 커밋하였습니다.
➡ 트랜잭션 B 안에서 실행되는 모든 SELECT 쿼리는 자신의 트랜잭션인 10번 보다 작은 트랜잭션 번호에서 변경한 것만 보게 됩니다. 즉, 번호가 13인 트랜잭션 A에서 변경한 내용은 10번인 트랜잭션 B에 영향을 주지 않습니다. 이는 Undo 영역에 트랜잭션 번호가 저장되어있기 때문에 가능한 것입니다.

3 : SERIALIZABLE (직렬화 가능)
가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회
SERIALIZABLE에서는 PHANTOM READ가 발생하지 않는다.
성능 문제로 데이터베이스에서 거의 사용되지 않는다.

