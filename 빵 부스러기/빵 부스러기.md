# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---

<br/><br/>


### 소켓(Socket)의 개념과 역할
1. 소켓의 정의와 배경
소켓은 1986년 BSD UNIX 4.3에서 개정된 통신 접속점으로, 처음에는 BSD UNIX 4.1에서 소개되었습니다.
네트워크 응용 프로그램이 데이터를 송수신하는 창구 역할을 하며, 추상적인 개념으로 소프트웨어로 구현됩니다.
2. 소켓의 기능과 역할
통신 창구:
소켓은 응용 프로그램이 TCP/IP 프로토콜을 통해 네트워크에 접근할 수 있는 인터페이스를 제공합니다.
프로세스 간 연결:
두 소켓이 연결되면 서로 다른 프로세스 간 데이터 전달이 가능해집니다.
캡슐화:
소켓을 통해 네트워크 계층과 전송 계층의 기능을 응용 프로그램에서 캡슐화하여 사용할 수 있습니다.
3. 소켓의 역사적 배경
캘리포니아 버클리 대학 분교에서 UNIX용으로 개발되었습니다.
UNIX의 파일 입출력 표준인 open(), read(), write(), close() 메커니즘을 따릅니다.
4. TCP/IP 소켓 통신
포트 사용:
클라이언트와 서버 프로그램은 각각 고유한 포트를 통해 통신합니다.
포트는 연결 설정과 데이터 교환 모두에 사용됩니다.
소켓의 종류:
서버 소켓: 서버에서 사용하며 클라이언트 요청을 기다립니다.
클라이언트 소켓: 서버와 연결을 설정하고 데이터를 교환합니다.
자바에서의 활용:
소켓을 통해 자바 프로그램에서 네트워크 통신을 구현할 수 있습니다.

 

- 클라이언트 프로그램과 서버 프로그램은 각각 자신이 포트를 통해 통신해야 한다.
- 연결을 할때도 포트를 사용하고 데이터를 교환할때도 포트를 사용한다.
- 자바 프로그램 안에서 포트를 사용하기 위해서는 소켓을 이용해야 한다.
- 자바안에서 소켓의 종류에는 서버소켓과 클라이언트 소켓이 있다.

---

<br/>

### 소켓과 저수준 I/O 개념 정리
1. Socket Library
소켓 라이브러리는 소켓을 구현하기 위한 다양한 함수를 제공하여 개발자가 별도의 구현 없이 소켓을 사용할 수 있도록 돕습니다.
운영 체제의 프로토콜 스택에 데이터 송신을 요청하면, 소켓 라이브러리는 내부 도구들을 정해진 순서대로 호출하여 작업을 처리합니다.
이후 논리적인 파이프라인이 완성되면, 상대방에게 데이터를 전송하게 됩니다.

2. Low-Level I/O (저수준 I/O)
정의:
저수준 I/O는 ANSI 표준 함수가 아닌, 리눅스 운영 체제에서 제공하는 파일 입출력 함수들을 의미합니다.
표준이 아니므로 다른 운영 체제와의 호환성은 보장되지 않습니다.

특징:
리눅스에서는 소켓을 파일로 취급하므로, 저수준 I/O 함수를 이용해 소켓 데이터를 송수신할 수 있습니다.
예: open(), close(), write(), read() 등.

3. File Descriptor (파일 디스크립터)
정의:
파일 디스크립터는 Linux/Unix 계열 시스템에서 파일을 식별하기 위해 사용되는 정수 값입니다.
프로세스는 파일에 접근하기 위해 파일 디스크립터를 사용하며, 이를 메모리에 저장해 관리합니다.

특징:

fd 0: 표준 입력 (Standard Input)
fd 1: 표준 출력 (Standard Output)
fd 2: 표준 에러 (Standard Error)
저수준 I/O 함수는 파일 디스크립터를 입력으로 받아 처리하며, 소켓과의 데이터 송수신도 동일한 방식으로 수행됩니다.
4. 소켓 통신의 전형적인 흐름
소켓은 생성부터 소멸까지 반드시 정해진 절차를 따라야 정상적으로 동작합니다.
특히 클라이언트와 서버의 소켓 동작에는 차이가 있습니다.

서버:
소켓을 생성하고 클라이언트의 연결 요청을 기다립니다.
클라이언트:
서버에 연결 요청을 보낸 후, 서버와 통신을 시작합니다.
소켓 통신 흐름을 한 번에 이해하기 어렵다면, 이후 관련 개념을 학습한 후 다시 흐름을 살펴보는 것이 효과적입니다.


---

3-2. 연결 요청 ( connect() )
connect() API는 IP주소와 포트 번호로 식별되는 대상으롤 연결 요청을 보낸다. connect() API는 블록(Block) 방식으로 동작하기 때문에 연결 요청에 대한 결과가 결정되기 전에는 connect()의 실행이 끝나지 않는다. connect() API 호출이 성공하면 send() / recv() API를 통해 데이터를 주고 받을 수 있다.


3-3. 데이터 송수신 ( send() / recv() )
연결된 소켓을 통해 데이터를 보낼 때는 send(), 데이터를 받을 때는 recv() API를 사용한다. send()와 recv() API 역시 블록(Block) 방식으로 동작하기 때문에 두 API 모두 실행 결과가 결정되기 전까지는 API가 리턴되지 않는다.

---

클라이언트 연결 요청 대기 ( listen() )
서버 소켓에 포트 번호를 결합(bind)하고 나면, 서버 소켓을 통해 클라이언트의 연결 요청 수신을 기다리게 되는데 이 역할을 listen() API가 수행한다.

listen() API는 서버 소켓에 바인딩된 포트 번호로 클라이언트의 연결 요청이 있는지 확인하며 대기 상태에 머무른다. 클라이언트에서 호출된 connect() API에 의해 연결 요청이 수신되면 대기 상태를 종료하고 리턴한다.

listen() API가 대기 상태에서 빠져나오는 경우는 두 가지이다. 클라이언트 요청이 수신되는 경우와 에러가 발생(소켓 close() 포함)하는 경우다. 그런데 listen() API가 성공하더라도 리턴 값에는 요청이 수신되었는지, 실패해서 에러가 발생했는지에 대한 정보만 있고, 요청에 대한 정보는 들어있지 않다.

대신 클라이언트 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐(Queue)에 쌓이게 되는데, 이 시점에서 클라이언트와의 연결은 아직 완전히 연결되지 않은 대기 상태이다. 대기 중인 연결 요청을 큐(Queue)로부터 꺼내와서 연결을 완료하기 위해서는 accept() API를 호출해야 한다.

---

### TCP란 무엇인가?

TCP 소켓 통신을 구현해보기에 앞서, TCP가 무엇인지부터 이해하고 넘어가는 것이 좋다고 생각한다. 우선 TCP란 Transmission Control Protocol의 줄임말으로, 주된 특징으로는 다음과 같다.

서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.
데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜이다.
데이터가 전달되는 과정에서 손실되거나 순서가 뒤바뀔 수 있으나, TCP는 손실을 검색하여 이를 교정할 수 있다.
특징에 대한 간략한 소개는 여기서 마치고, 참조할 만한 사이트 링크를 첨부하겠다.
[참조] https://kotlinworld.com/94

클라이언트 접속 부분
```
private void connect_btn_Click(object sender, EventArgs e)
{
	... 	// IP, Port가 정상적으로 입력되었는지 확인하는 부분
    
    Thread connectThread = new Thread(new ThreadStart(Connect));
    connectThread.IsBackground = true;
    connectThread.Start();
}
```
Connect 버튼을 클릭하게 되면 위의 코드가 실행된다. 메인 쓰레드에서 connectThread를 분리하여 Connect() 메소드를 실행시킨다. (분리시키는 이유는 메인 쓰레드에서 바로 Connect 시, 클라이언트가 접속하지 않은 시간동안은 메인 쓰레드가 아무것도 할 수 없기 때문이다..)
```
private void Connect() 
{
	try
    {
    	TcpListener listener = new TcpListener(IPAddress.Parse(ip), int.Parse(port));
        listener.Start();
        WriteLog("Ready to connect ...");

        client = listener.AcceptTcpClient();
        WriteLog("Client connected!");
    }
    catch (Exception ex)
    {
    	Debug.WriteLine(ex.ToString());
    }
}
```
메인 쓰레드에서 분리된 connectThread에서 실행된 Connect() 메소드이다. TcpLister라는 클래스는 TCP 네트워크 클라이언트에서 연결을 수신한다. 파라미터로 전달되는 IPAddress.Parse(ip), int.Parse(port)는 사용자로부터 입력받은 IP와 Port다. listener.Start();를 통해 들어오는 연결 요청 수신 대기를 시작한다.

client = listener.AcceptTcpClient(); 이 부분의 client는 전역에서 선언된 private static TcpClient client = new TcpClient();다. TcpClient 클래스는 TCP 네트워크 서비스에 대한 클라이언트 연결을 제공한다. listener.AcceptTcpClient() 이 부분에서 클라이언트의 접속을 기다리고, 접속이 된 경우에 client 객체로 클라이언트의 정보를 넘겨준다.


---


### 서버 전체 코드

```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SocketProgramming
{
    public partial class Tcp_Server : Form
    {
        private static string ip = string.Empty;
        private static string port = string.Empty;

        private static TcpClient client = new TcpClient();

        public Tcp_Server()
        {
            InitializeComponent();
        }

        private void Tcp_Server_Load(object sender, EventArgs e)
        {
            Thread receiveThread = new Thread(new ThreadStart(Receive));
            receiveThread.IsBackground = true;
            receiveThread.Start();
        }

        private void Receive()
        {
            while (true)
            {
                if (client.Connected)
                {
                    try
                    {
                        NetworkStream stream = client.GetStream();
                        byte[] buffer = new byte[1024];
                        int bytes = stream.Read(buffer, 0, buffer.Length);
                        if (bytes <= 0)
                        {
                            continue;
                        }

                        string message = Encoding.UTF8.GetString(buffer, 0, bytes);
                        WriteLog("[Other] " + message);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex.ToString());
                    }
                }
            }
        }

        private void connect_btn_Click(object sender, EventArgs e)
        {
            ip = tb_ip.Text;
            port = tb_port.Text;
            if (ip.Split('.').Length != 4 || port == "")
            {
                tb_ip.Text = string.Empty;
                tb_port.Text = string.Empty;
                return;
            }

            Thread connectThread = new Thread(new ThreadStart(Connect));
            connectThread.IsBackground = true;
            connectThread.Start();
        }

        private void Connect()
        {
            try
            {
                TcpListener listener = new TcpListener(IPAddress.Parse(ip), int.Parse(port));
                listener.Start();
                WriteLog("Ready to connect ...");

                client = listener.AcceptTcpClient();
                WriteLog("Client connected!");
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void send_btn_Click(object sender, EventArgs e)
        {
            string message = tb_message.Text;
            if (message.Length <= 0) { return; }

            try
            {
                NetworkStream stream = client.GetStream();
                byte[] buffer = Encoding.UTF8.GetBytes(message);
                stream.Write(buffer, 0, buffer.Length);

                WriteLog("[Me] " + message);
                tb_message.Text = string.Empty;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void WriteLog(string text)
        {
            string date = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            Invoke(new MethodInvoker(delegate ()
            {
                tb_log.AppendText("[" + date + "] " + text + "\r\n");
            }));
        }
    }
}
```


### Snapshot/M(Milstone)/RC(Release candidate)

Snapshot
daily build 버전.
실험 중인 버전.
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
M(Milstone)
Snapshot 보다 정리가 잘 되어 있는 버전. 
실험 중인 버전. 
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
RC(Release candidate)
Milstone 본다 더 정리가 잘 되어저 배포된 버전. 
왠만하면 개발된 기능들은 그대로 배포된다.

---

### 왜 인덱스가 필요할까?
테이블에 데이터가 많아지면 전체 테이블을 탐색(Full Table Scan) 하면 시간이 오래 걸립니다.
인덱스는 책의 목차처럼 작동하여, 원하는 데이터를 빠르게 찾을 수 있도록 돕습니다.

인덱스는 내부적으로 B-Tree(Balanced Tree) 구조로 저장됩니다.
MySQL이 인덱스를 사용하면 검색 시 이진 탐색과 같은 방식으로 데이터를 빠르게 찾을 수 있습니다.

상황	인덱스가 필요한 이유
WHERE 조건문에 자주 사용	특정 조건에 맞는 데이터를 빠르게 찾기 위해
JOIN 연산이 많은 경우	두 테이블을 연결할 때 검색 속도를 높이기 위해
ORDER BY 사용 시	데이터를 정렬할 때 성능을 최적화하기 위해
UNIQUE 제약 조건	중복되지 않는 값을 보장하기 위해

### 인덱스 생성

```sql
-- 단일 인덱스 생성
CREATE INDEX idx_name ON users(name);

-- 복합 인덱스 생성
CREATE INDEX idx_name_email ON users(name, email);
```

### Primary Key와 Unique Index

```sql
-- 테이블 생성 시 기본 키 인덱스
CREATE TABLE users (
    id INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(50),
    email VARCHAR(50),
    PRIMARY KEY (id)
);

-- Unique 인덱스
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

### Fulltext Index

```sql
-- 게시글 내용에 Fulltext 인덱스 생성
CREATE TABLE articles (
    id INT NOT NULL AUTO_INCREMENT,
    title VARCHAR(255),
    content TEXT,
    PRIMARY KEY (id),
    FULLTEXT (content)
);
```

### Composite Index 사용 예시

```sql
-- 복합 인덱스 생성
CREATE INDEX idx_user_info ON users(name, email);

-- 복합 인덱스를 활용한 쿼리
SELECT * FROM users
WHERE name = 'MinSeok' AND email = 'minseok@example.com';
```

### 인덱스가 효과적인 경우와 비효과적인 경우

효과적인 경우	비효과적인 경우
WHERE 조건에 자주 사용되는 컬럼	작은 테이블에서는 인덱스가 큰 이점이 없음
JOIN 연산이 자주 발생하는 경우	자주 변경되는 컬럼에 인덱스를 걸면 오히려 비효율
ORDER BY, GROUP BY에 사용되는 경우	WHERE 조건 없이 단순 조회하는 경우
