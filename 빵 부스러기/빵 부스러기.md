# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차

1. isAssignableFrom

2. 실무에서는 `new HashMap<>()` 안되는 이유.

3. 검증 애노테이션

4. final 로 되어 있으면 무조건 생성자를 통해서 할당 되어야 한다.
```java 
private final MemberRepository memberRepository;
```

5. 수동 빈 등록은 언제 사용하면 좋을까?

6. < input > 태그 안에 있는 name="name" 이 'key' 이다.

7. 스트림 필터 사용 예제.

8. member.name 되어 있다면??

9. sessionStore.get(sessionCookie.getValue());

10. 서블릿을 사용한 쿠키, 세션


---

<br/><br/>

## 1. isAssignableFrom

### "쉽게 설명하면 파라미터로 넘어오는 클래스가 지원이 되냐? 묻는 것이다"



매개변수랑 Item 클래스랑 같냐? 물어보는 것이다.

중요한 것은 자식 클래스도 통과 한다는 것이다.

```java 
@Override
public boolean supports(Class<?> clazz) {
	return Item.class.isAssignableFrom(clazz);
}
```

<br/>

특정 클래스가 다른 인터페이스를 구현했거나 상속받았는지를 체크하기 위해서는 어떻게 하면 될까?

상위클래스들을 모조리(java.lang.Object 가 될때까지) 찾아다니면서 구현한 

Interface들을 확인하면 될것도 같은데 왠지 세련되지 않은 것 같다.

다시 말해서 clazz 클래스는 java.util.Collection 인터페이스를 구현한 클래스다 라는 의미가 된다.

### 차이점

```java
a instanceof B
```

 또는

```java
B.class.isAssignableFrom(a.getClass())
```

유일한 차이점은 'a'가 null이면 첫 번째는 false를 반환하고 두 번째는 예외를 던진다는 것입니다. 

또 다른것은 `instanceof` 사용할 때 컴파일 타임 `B`클래스를 알아야 합니다. 

`isAssignableFrom()`을 사용할 때 동적 일 수 있으며 런타임 중에 변경 될 수 있습니다.

<br/><br/>

## 2번. 실무에서는 `new HashMap<>()` 안되는 이유.

실무에서는 `new HashMap<>()` 하면 안되고, `new ConcurrentHashMap<>()` 을 사용해야 한다. 
<br/>이유는 쓰레드 문제 이므로, 여러 사람들이 접속 했을때, `new HashMap<>()` 인 경우 전부 받을 수 없기 때문이다.
<br/>그리고 `long` 도 같은 이유다. `AtomicLong` 을 사용해야 된다.




<br/><br/>


## 3. 검증 애노테이션

@NotBlank : 빈값 + 공백만 있는 경우를 허용하지 않는다.

@NotNull : null 을 허용하지 않는다.

@Range(min = 1000, max = 1000000) : 범위 안의 값이어야 한다.

@Max(9999) : 최대 9999까지만 허용한다.



<br/><br/>


## 5. 수동 빈 등록은 언제 사용하면 좋을까?

애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.

<br/>

### 업무 로직 빈: 
웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 
로직을 처리하는 리포지토리등이 모두 업무 로직이다. <br/>보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.

<br/>

업무 로직은 숫자도 매우 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 어느정도 유
사한 패턴이 있다. 이런 경우 자동 기능을 적극 사용하는 것이 좋다. 
보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.

<br/>

### 기술 지원 빈: 
기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 <br/>위한 하부 기술이나 공통 기술들이다.

<br/>

기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 애플리케이션 전반에 걸쳐서 광범
위하게 영향을 미친다. 그리고 업무 로직은 문제가 발생했을 때 어디가 문제인지 명확하게 잘 들어나
지만, 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.

<br/>

### 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! <br/>설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.


<br/><br/>


## 7. 스트림 필터 사용 예제.

스트림 사용 전

```java
List<Member> all = findAll();
for(Member m : all) {
    if(m.getLoginId().equals(loginId)) {
	return Optional.of(m);
    }
}
return Optional.empty();
```

<br/>

스트림 사용

```java
return findAll().stream()
		.filter(m -> m.getLoginId().equals(loginId)).findFirst();
```


stream().filter() 를 사용하면 괄호안에 만족하는 애만 쓰이는 것이고, <br/>아닌것은 버려지는 것이다.
즉, 조건에 맞는 애만 다음 단계로 넘어가게 되는 것이다.

findFirst() 란? 먼저 나온애를 바로 반환 하는 것이다.
그리고 뒤에 나온 애들은 무시하는 것이다.

<br/>

### 예제 2)

```java
/*     
 	스트림 없이 자바코드로 작성
    Optional<Member> findMemberOptional = memberRepository.findByLoginId(loginId);
    Member member = findMemberOptional.get();
  
    if (member.getPassword().equals(password)) {
        return member;
    } else {
        return null;
    }
*/
     // 스트림 사용
     return memberRepository.findByLoginId(loginId)
      	          .filter(m -> m.getPassword().equals(password)).orElse(null);

```

<br/><br/>


## 8. member.name 되어 있다면??

member.name 되어 있으면, member라는 하나의 객체 안의 name을 찾는 것이다. 타입도 맞는 말이긴 한데, <br/>member 안에 수 많은 String을 말하는 것이 아니기에, 객체라고 말하는 것이 편할듯 하다.

<br/>

### 다음부터 member.name 되어 있다면
"member 는 타입이다 하고 무시하지 말고",  <br/>member는 객체라는 생각과 **해당 객체의 주소안에 name** 이라는걸 생각해보도록 하자.  

<br/>

(하나의 객체라는 뜻은 예를 들어, 많은 회원들이 있는데 그걸 한곳에 관리 할 수 없고, 한객체, 한객체 따로따로 만들어야 하기 때문이다)

```java

public class Member {

    private Long id;
    private String name;
    private String password;
    private String address;
}

```

<br/>

예제 1)

```java

Optional<Member> findMemberOptional = memberRepository.findByLoginId(loginId);
Member member = findMemberOptional.get();
  
if (member.getPassword().equals(password)) {
      return member; // 이렇게 하면 해당 getPassword 들어있는 member 객체를 가져오는 것이다.
} else {
      return null;
}

```

<br/><br/>

## 9. sessionStore.get(sessionCookie.getValue());

### 다른 코드 풀이 1)

```java
return Arrays.stream(request.getCookies())
        .filter(cookie -> cookie.getName().equals(cookieName))
        .findAny()
        .orElse(null);

```            

여기서 getName() 은 이름을 비교하는 거지만, 반환 값은 getName()이 아니고 Cookies() 객체이다. 

이유는? stream(request.getCookies() 부분을 보면 괄호 안에 getCookies() 가 되어 있기 때문이다.

<br/>


### 코드 풀이 2)

```java

1줄 private Map<String, Object> sessionStore = new ConcurrentHashMap<>();

2줄 String sessionId = UUID.randomUUID().toString();
3줄 sessionStore.put(sessionId, value); 


//쿠키 생성
4줄 Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId);

//해당 객체 찾아오는 코드
5줄 Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME);

// 풀이
6줄 return sessionStore.get(sessionCookie.getValue());

```

부분부분 설명을 위해 코드를 가져 온것이다. 연결 되는 정상 코드가 아니다.

알아야 될건 return 되는 부분이다.

<br/>

### 순서를 알자

1. 6줄 sessionCookie.getValue() 에서 sessionCookie() 부분은 5줄 sessionCookie() 메서드에서 **해당 쿠키** 객체를 가져온다.

	예를 들어 해당 쿠키의 객체는 이렇다("mySessionId", 1234(=uuid)) 그러면 sessionCookie 변수안에 들어있는 것이다.

2. 그러면 sessionCookie.getValue() 니깐 .getValue() 니깐 쿠키의 UUID를 꺼낸다.
3. 그 다음 sessionStore에서 get을 이용하여 uuid인 키를 가지고 세션스토어에서 벨류를 객체를 찾아 오는 것이다.

4. 여기까지 정리하면 (sessionCookie.getValue()) 부분은 **해당 쿠키** 안에 저장되어 있는 uuid를 가져 오는 것이다. <br/> 밑에 코드가 Cookie 클래스의 내부 생성자이다.

```java
public Cookie(String name, String value) {
        validation.validate(name);
        this.name = name;
        this.value = value;
    }
```


<br/><br/>


## 10. 서블릿을 사용한 쿠키, 세션

### 정리하면

1. 세션 uuid 생성 (1234 라고가정)

2. 세션store(Map)에 저장(1234, 유저A)
3. 쿠키생성("mySessionId", 1234)
4. 쿠키를 response에 저장 후 응답
5. 웹 브라우저에서 서버로 다시 요청을 하면
6. 서버는 클라이언트가 넘겨준 여러 개의 쿠키 중("mySessionId", 1234) 쿠키를 찾고
7. 서버는 이 쿠키(쿠키의 벨류인 UUID)를 가지고 세션store에서 ‘유저A’ 정보를 찾아낸다.

<br/>

### 코드로 정리.

1. 쿠키(쿠키_name , uuid) 키 벨류로 저장된다. 밑에 코드가 해당 부분 그 다음 → 

```java
Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId);
```
<br/>

2. 세션 저정소(uuid , 세션) 으로 간다. 

여기서 벨류인 ‘세션’은 밑에 코드인 첫번째 줄을 의미한다. 그 다음 →

```java
HttpSession session = request.getSession();
session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember);
```

<br/>

3. ‘해당 세션’(세션_name , 객체) 로 들어가게 되는 것이다. 

밑에 코드가 ‘해당 세션’ 부분이다.

```java
Member loginMember = (Member)session.getAttribute(SessionConst.LOGIN_MEMBER);
```

sessionid(=uuid)를 key로 갖고 session(저장공간)을 value로 갖는 세션저장소(Map) 가 있는 것이다.

sessionid(=uuid)는 tomcat에서 생성합니다.

![이미지](/programming/img/규.PNG)
