# 🍞 빵 부스러기
>개발 관련 학습 중 하나의 글로 작성하기엔 짧고, <br/>
>버리기엔 아까운 부스러기 정보들을 모아두는 곳. <br/> <br/>
>임시로 작성한게 완성 되면 빵이 되어 나가는 것이다. <br/> 
>1개, 2개, 3개, ... 부스러기 들을 모아 두고 점점 정리해 가는 것이다. <br/>
>정리가 된것은 🍞이 되어 해결.
> ***



<br/>

## 목차


---

<br/><br/>

### 서버 전체 코드

```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SocketProgramming
{
    public partial class Tcp_Server : Form
    {
        private static string ip = string.Empty;
        private static string port = string.Empty;

        private static TcpClient client = new TcpClient();

        public Tcp_Server()
        {
            InitializeComponent();
        }

        private void Tcp_Server_Load(object sender, EventArgs e)
        {
            Thread receiveThread = new Thread(new ThreadStart(Receive));
            receiveThread.IsBackground = true;
            receiveThread.Start();
        }

        private void Receive()
        {
            while (true)
            {
                if (client.Connected)
                {
                    try
                    {
                        NetworkStream stream = client.GetStream();
                        byte[] buffer = new byte[1024];
                        int bytes = stream.Read(buffer, 0, buffer.Length);
                        if (bytes <= 0)
                        {
                            continue;
                        }

                        string message = Encoding.UTF8.GetString(buffer, 0, bytes);
                        WriteLog("[Other] " + message);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex.ToString());
                    }
                }
            }
        }

        private void connect_btn_Click(object sender, EventArgs e)
        {
            ip = tb_ip.Text;
            port = tb_port.Text;
            if (ip.Split('.').Length != 4 || port == "")
            {
                tb_ip.Text = string.Empty;
                tb_port.Text = string.Empty;
                return;
            }

            Thread connectThread = new Thread(new ThreadStart(Connect));
            connectThread.IsBackground = true;
            connectThread.Start();
        }

        private void Connect()
        {
            try
            {
                TcpListener listener = new TcpListener(IPAddress.Parse(ip), int.Parse(port));
                listener.Start();
                WriteLog("Ready to connect ...");

                client = listener.AcceptTcpClient();
                WriteLog("Client connected!");
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void send_btn_Click(object sender, EventArgs e)
        {
            string message = tb_message.Text;
            if (message.Length <= 0) { return; }

            try
            {
                NetworkStream stream = client.GetStream();
                byte[] buffer = Encoding.UTF8.GetBytes(message);
                stream.Write(buffer, 0, buffer.Length);

                WriteLog("[Me] " + message);
                tb_message.Text = string.Empty;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        private void WriteLog(string text)
        {
            string date = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            Invoke(new MethodInvoker(delegate ()
            {
                tb_log.AppendText("[" + date + "] " + text + "\r\n");
            }));
        }
    }
}
```


### Snapshot/M(Milstone)/RC(Release candidate)

Snapshot
daily build 버전.
실험 중인 버전.
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
M(Milstone)
Snapshot 보다 정리가 잘 되어 있는 버전. 
실험 중인 버전. 
새로 개발 중인 기능이 있을 수 있다(인터페이스가 변경 될 수 있음)
RC(Release candidate)
Milstone 본다 더 정리가 잘 되어저 배포된 버전. 
왠만하면 개발된 기능들은 그대로 배포된다.

---

### 왜 인덱스가 필요할까?
테이블에 데이터가 많아지면 전체 테이블을 탐색(Full Table Scan) 하면 시간이 오래 걸립니다.
인덱스는 책의 목차처럼 작동하여, 원하는 데이터를 빠르게 찾을 수 있도록 돕습니다.

인덱스는 내부적으로 B-Tree(Balanced Tree) 구조로 저장됩니다.
MySQL이 인덱스를 사용하면 검색 시 이진 탐색과 같은 방식으로 데이터를 빠르게 찾을 수 있습니다.

상황	인덱스가 필요한 이유
WHERE 조건문에 자주 사용	특정 조건에 맞는 데이터를 빠르게 찾기 위해
JOIN 연산이 많은 경우	두 테이블을 연결할 때 검색 속도를 높이기 위해
ORDER BY 사용 시	데이터를 정렬할 때 성능을 최적화하기 위해
UNIQUE 제약 조건	중복되지 않는 값을 보장하기 위해

### 인덱스 생성

```sql
-- 단일 인덱스 생성
CREATE INDEX idx_name ON users(name);

-- 복합 인덱스 생성
CREATE INDEX idx_name_email ON users(name, email);
```

### Primary Key와 Unique Index

```sql
-- 테이블 생성 시 기본 키 인덱스
CREATE TABLE users (
    id INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(50),
    email VARCHAR(50),
    PRIMARY KEY (id)
);

-- Unique 인덱스
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

### Fulltext Index

```sql
-- 게시글 내용에 Fulltext 인덱스 생성
CREATE TABLE articles (
    id INT NOT NULL AUTO_INCREMENT,
    title VARCHAR(255),
    content TEXT,
    PRIMARY KEY (id),
    FULLTEXT (content)
);
```

### Composite Index 사용 예시

```sql
-- 복합 인덱스 생성
CREATE INDEX idx_user_info ON users(name, email);

-- 복합 인덱스를 활용한 쿼리
SELECT * FROM users
WHERE name = 'MinSeok' AND email = 'minseok@example.com';
```

### 인덱스가 효과적인 경우와 비효과적인 경우

효과적인 경우	비효과적인 경우
WHERE 조건에 자주 사용되는 컬럼	작은 테이블에서는 인덱스가 큰 이점이 없음
JOIN 연산이 자주 발생하는 경우	자주 변경되는 컬럼에 인덱스를 걸면 오히려 비효율
ORDER BY, GROUP BY에 사용되는 경우	WHERE 조건 없이 단순 조회하는 경우

---



### MVCC의 핵심 개념
Undo Log

이전 데이터를 보존하여 트랜잭션의 스냅샷을 제공
Rollback 시 데이터를 복구하거나 과거 버전을 읽을 때 사용
Transaction ID (트랜잭션 ID)

각 트랜잭션마다 고유한 ID를 부여하여 데이터 버전 관리에 사용
Hidden Columns

InnoDB 테이블에는 숨겨진 컬럼이 있으며, 데이터의 버전 정보를 관리
DB_TRX_ID : 마지막으로 변경된 트랜잭션 ID
DB_ROLL_PTR : Undo Log를 가리키는 포인터
Read View

트랜잭션이 시작될 때 Read View가 생성되어, 해당 시점의 데이터 스냅샷을 기반으로 조회

### MySQL MVCC 동작 예시
아래 예시를 통해 트랜잭션 간의 충돌이 MVCC로 어떻게 해결되는지 확인해보겠습니다.

### 실전 예제: MVCC 트랜잭션 처리 과정

### 테이블 생성
sql
코드 복사
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO users (name, balance) VALUES ('MinSeok', 1000);


### 트랜잭션 시나리오: 두 트랜잭션이 동시에 데이터를 처리
트랜잭션 1: 사용자 A가 조회 후 업데이트
sql
코드 복사
-- 트랜잭션 1 시작
START TRANSACTION;

-- 현재 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

-- balance를 1000 증가
UPDATE users SET balance = balance + 1000 WHERE name = 'MinSeok';
트랜잭션 2: 사용자 B가 동일한 데이터를 조회
sql
코드 복사
-- 트랜잭션 2 시작
START TRANSACTION;

-- 현재 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

### 트랜잭션이 동시에 실행될 때의 MVCC 동작 과정

트랜잭션 1이 데이터를 읽을 때, 해당 데이터의 스냅샷이 생성됩니다.
트랜잭션 2가 동일한 데이터를 조회할 때, 트랜잭션 1의 변경 사항은 보이지 않습니다.
이는 MVCC가 트랜잭션이 시작된 시점의 스냅샷을 제공하기 때문입니다.

### 결과 확인: 트랜잭션이 완료된 후

트랜잭션 1 커밋 후 상태:
sql
코드 복사
-- 트랜잭션 1 커밋
COMMIT;
트랜잭션 2 커밋 후 상태:
sql
코드 복사
-- 트랜잭션 2 커밋
COMMIT;

### 트랜잭션 2가 조회한 데이터는 트랜잭션 1의 변경 사항이 반영되지 않았던 시점의 스냅샷을 기준으로 조회합니다.

### Read View의 역할 확인
sql
코드 복사
-- 트랜잭션 시작
START TRANSACTION;

-- 데이터 조회
SELECT * FROM users WHERE name = 'MinSeok';

-- 결과
+----+---------+---------+
| id | name    | balance |
+----+---------+---------+
|  1 | MinSeok | 1000    |
+----+---------+---------+
트랜잭션이 시작된 이후에는 다른 트랜잭션이 데이터를 변경해도 현재 트랜잭션의 조회 결과는 동일합니다.

🛠 MVCC의 주요 이점
1️⃣ 잠금 없이 동시 읽기 처리

데이터를 읽을 때 다른 트랜잭션이 변경 중이더라도 락 없이 읽기 가능
2️⃣ 일관된 읽기(Consistent Read)

트랜잭션이 시작된 시점의 스냅샷을 기준으로 일관된 데이터를 제공합니다.
3️⃣ Rollback 가능

변경 사항이 커밋되지 않으면 Undo Log를 통해 이전 상태로 복원 가능합니다.

### 핵심 포인트 요약
MySQL의 InnoDB 엔진은 MVCC를 지원하여 일관된 읽기와 동시성 제어를 제공합니다.
MVCC는 Undo Log를 통해 이전 버전의 데이터를 관리하며, 트랜잭션이 시작된 시점의 스냅샷을 제공합니다.
트랜잭션 격리 수준 중 REPEATABLE READ가 MySQL의 기본 격리 수준이며, MVCC의 주요 이점을 활용합니다.

---

### 대칭키 / 공개키 / 암호화 방식

대칭키
암호화, 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘

동일한 키를 주고 받기 때문에, 매우 빠르다는 장점.
그러나 대칭키 전달과정에서 해킹 위험에 노출

공개키 / 비대칭키
암호화와 복호화에 사용하는 암호키를 분리한 알고리즘

자신이 가지고 있는 고유한 암호키(비밀키)로만 복호화 할 수 있는 암호키(공개키)를 공개.

과정
1. A가 웹 상에 공개된 B의 공개키를 이용해 데이터를 암호화 하여 B에게 송신
2. B는 자기가 가진 비밀키로 복호화한 데이터를 확인후, A의 공개키로 응답을 암호화 하여 A에게 송신
3. A는 자신의 비밀키로 응답문을 복호화.
4. 

---

디지털 인증서에는 모두가 신뢰할 수 있는 제삼자인 CA와 비대칭키 암호화가 필요.

B는 CA에게 자신이 B임을 증명하고 자신의 공개 키가 B의 공개 키가 맞음을 인증하는 인증서 발급.

A에게 B의 공개키가 포함된 이 인증서를 주면,

이를 받은 A는 자신이 신뢰할 수 있는 CA에게 CA가 진짜 발급한 인증서인지 확인하고,

맞으면 그 인증서에 포함된 B의 공개 키로 데이터를 암호화해서 B에게 전달

만약 최종적으로 B가 올바르게 자신의 개인키로 복호화한다면, CA가 인증하는 B의 공개키에 대응하는 개인키를 가지고 있다는 것이므로, 이 과정을 통해 현재 통신하고 있는 상대방이 B가 맞음을 인증할 수 있음.
