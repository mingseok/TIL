## :scroll: 첫째도 기본기, 둘째도 기본기
>'손흥민이 변함없이 강조한 것은 첫째도 기본기, 둘째도 기본기, 세째도 기본기였다'<br/>
>### '객체지향이가 무엇인지를 확실히 알자' 는 <br/>
>"객체지향이란 ~~ 이다" 가 아닌, 객체지향적으로 코딩할 수 있도록 하자.
---

<br/>

## 목차

1. Map
2. HashMap
3. static 페이지
4. 인터페이스
5. 싱글톤 패턴
6. Arrays.asList
7. enum이란?
8. public Order(int a, int b, int c,)
9. final
10. Collection은 인터페이스, Collections는 클래스 
11. static, static() 메서드
12. equals와 == 의 차이점
13. ... 이란?
14. List의 특징
15. paralleXXX()
16. getClass()
17. hasNext(), next()
18. length 와 length() 그리고 size()
19. 아규먼트
20. null ≠ “”;
21. 개발할때 순서
22. 프로퍼티
23. instanceof
24. keySet()
25. 메서드 레퍼런스
26. JDBC
27. 프로퍼티 접근방식
28. API
29. 스프링 컨테이너와 빈



<br/>

---



## 상세 설명.


1번.

![이미지](/programming/img/기.PNG)

**맵이라는 것은 키(Key)와 값(Value) 두 쌍으로 데이터를 보관하는 자료구조 이**다.

**값은 중복된 값이어도 상관이 없다.**

## Map은 <열쇠, 물건> 이라고 생각하자

상점에 열쇠랑 물건을 둘다 맡기는 것이다.
위 예시로 member1 저장 될때 마다 어떤 모양인가?
  -- store 장부--
 key            value
  1             0x100 -> "휴대폰 클래스"
  2             0x200 -> "컴퓨터 클래스"
  3             0x300 -> "냉장고 클래스"

```java
private static Map<Long, Member> store = new HashMap<>();
```

위에 이 코드에서 Map<Long, Member> 는 결국 <키, 벨류> 이므로

store.get(3L).getName(); 이렇게 하여 값을 가져 올수 있다.

### 위 코드를 반대로 한다면??

Map<Member, Long> 한다면 0x100을 '키' 값으로 넣고 '1'을 벨류값으로 받을 것이다.

---

<br/><br/>

2번.

# HashMap

여기서 키와 값은 모두 객체입니다.

### 키는 중복이 되지 않지만 값은 중복이 될 수 있다

만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대치 된다. 

HashMap은 이름 그대로 해싱을 사용하기 때문에 많은 양의 데이터를 검색하는 데 있어서 뛰어난 성능을 보인다.

---

<br/><br/>

3번.

# static 페이지

변하지 않는 페이지 즉, 내가 적은걸 그대로 페이지에 응답을 주는것. 

(파일을 그냥 던져 준것 프로그래밍이 아닌것.)

이렇게 만들었다면

![이미지](/programming/img/스.PNG)

실행창에 뒤에 .html 까지 하면 출력이 된다.

![이미지](/programming/img/스2.PNG)

---

<br/><br/>

4번.

# 인터페이스

인터페이스 끼리들은 상속 받는다고 표현한다.

### 인터페이스가 인터페이스를 받을때는 `implements` 가 아니고,

### `extends` 를 사용하는 것이다.

부모클래스를 상속받은 자식클래스에서는 부모클래스의 모든 메서드를 그대로 사용할 수 있다

인터페이스는 미구현된설계서(니가 구현해라) 및 강제성(임플리먼트시 무조껀 작성해라) 및 나중에 팀들이랑 표준으로도 메소드만들기좋아서 쓰는데 

결국

서비스를 인터페이스로 만들엇으니 impl에서 내가 이제 임플리먼트해서 강제로 구현하는거에요


---

<br/><br/>

5번.

# 싱글톤 패턴

싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 

이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 

조회 할땐 이렇게 사용하면 되는 것이다.

```java
package hello.core.singleton;

import org.junit.jupiter.api.Test;

public class SingletonService {

    //자기 자신을 내부에 private으로 하나 가지고 있는데 static 이므로,
    //클래스 레벨에 딱 하나만 존재하게 된다.
    //static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    public static SingletonService getInstance() {
        return instance;
    }

    private SingletonService() {

    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }

}
```

결국 하나의 bean이라는 놈한테 다른 애들이 먼짓을 하게 되는 것이다.

A도 어떤 bean한테 먼 짓하고, B도 bean한테 먼 짓하고 

결국 이용하는 애는 A, B에서 각각 new 객체 해서 생성된 애가 아니라

스프링이 그냥 첨에 만든 객체 하나에 A, B가 이용하게 대는 것이다. 

이걸 싱글톤패턴이라고 한다. 

하나의 객체를 생성해서 그 한 객체로 모든 애들이 돌려 쓰는 것.


---

<br/><br/>

6번.

# **Arrays.asList**

Array(배열)을 List로 변경할때 사용한다.

asList()를 사용해서 객체를 만들때 새로운 배열 객체를 만드는 것이 아니라,

**원본배열의 주소값**을 참조한다.

asList()를 사용해서 내용을 수정하면 원본 배열도 함께 바뀌게 됨

Arrays.asList()로 만든 List에 새로운 원소를 추가하거나 삭제는 할 수 없다.

### **2. 원소를 추가/삭제 할 수 있나?**

결론부터 말하면 `new ArrayList<>()`는 할 수 있고, 

`Arrays.asList()` 할 수 없다.

---

<br/><br/>

7번.


# **enum이란?**

enum은 **열거형(enumerated type)**이라고 부른다. 

열거형은 **서로 연관된 상수들의 집합**이라고 할 수 있다.

열거형은 연관된 값들을 저장하며, 저장된 값들이 변경되지 않도록 보장한다. 

또한 enum의 경우 열거형 그 자체이면서 클래스이기 때문에 

**enum내부에 생성자나 필드, 메서드를 가질 수 있어** 다양한 역할을 할 수 있다.

상수 목록이 필요해 상수목록만 적어놓은 class를 활용한 적이 있는데, 

이런 사용은 자제하고 enum을 활용할 수 있다.


---

<br/><br/>

8번.

# *`public* Order(int a, int b, *int c*,)`

### 생성자 여러개 사용하는 이유

나이와 키를 갖는 사람 객체를 생각해보겠습니다.

```java
class Person {

	int age;
	int height;
}
```

Person p = new Person();

현재 Person p는 나이가 0이고 키도 0입니다. 

이런 사람은 존재할 수 없겠죠? 

그래서 이런 객체는 유효하지 않다고 합니다. 

이 문제를 해결하기 위해 생성자를 이용합니다.

```java
class Person {
	int age;
	int height;

	public Person(int age, int height) {

    this.age = age;
    this.height = height;

	}
}
```

Person p = new Person(10, 130);

Person p 는 생성과 동시에 나이 10, 키는 130을 갖습니다. 

이것은 유효하다고 할 수 있습니다.



---

<br/><br/>

9번.


추가 설명 : final 로 되어 있으면 무조건 생성자를 통해서 할당 되어야 한다.



---

<br/><br/>

10번.



Collection은 인터페이스이고, Collections는 클래스 이다.
Collections 유틸 클래스란? math 클래스 처럼 컬렉션을 다루는 데 있어
필요한 메서드들을 제공하는 클래스 이다. 안에 sort 정렬 등등 메서드들이 있다


---

<br/><br/>

11번.


# static, static() 메서드

### 클래스 안에다가

static class 를 썻다는 것은

밖에 있는 클래스의 안에서만 사용 하겠단 뜻이 된다.

### static() 메서드

static 메서드는 static 변수로 지정 되어 있는 것을 가져와서 사용할때 static 메서드를 사용한다.

즉, 핵심은 static 메서드에 인스턴스 변수는 들어 올수 있지만, 

인스턴스 메서드에 static 변수는 들어 올수 없다.

### 정리해보면,

생성될때 자바가 뜰때 생성해 놓을것을 그냥 가져다 사용하는 것이다.

```java
package hello.core.singleton;

import org.junit.jupiter.api.Test;

public class SingletonService {

    //자기 자신을 내부에 private으로 하나 가지고 있는데 static 이므로,
    //클래스 레벨에 딱 하나만 존재하게 된다.
    //1. static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    //2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
    public static SingletonService getInstance() {
        return instance;
    }

    private SingletonService() {

    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }

}
```

이렇게 작성하고 에러가 뜨는 이유는.

생성자의 private 때문에 안되는 것이다.



---

<br/><br/>

12번.



# **equals와 == 의 차이점**

equals() 는 **메소드** 입니다. 

객체끼리 내용을 비교할 수 있도록 합니다.

== 은 비교를 위한 **연산자** 입니다.

equals 메소드는 비교하고자 하는 **대상의 내용 자체를 비교**하지만,

== 연산자는 비교하고자 하는 대상의 **주소값을 비교**합니다.




---

<br/><br/>

13번.

# ...

### (Object...a) 는 배열이다.  == 가변 매개변수

가변: 갯수가 정해져 있지 않다.

매개변수 여러 개 넣어도 된다는 말이다.


---

<br/><br/>

14번.


# List의 특징

읽기 전용이다.

그리하여 추가 하려면 `UnsupportedOperationException` 예외 발생한다. (지원하지 않는 기능)

그릭하여 추가 하고 싶으면

```java
// 생성자에다가 넣어서 다시 만들어야 하는것이다.
List list = new ArrayList(Arrays.asList(1,2,3,4,5)); 
```


---

<br/><br/>

15번.



# paralleXXX()

XXX 는 뒤에 이름이 여러개가 온다는 것이다.


---

<br/><br/>

16번.


클래스 타입이 뭔지 알 수 있다.



---

<br/><br/>

17번.


# hasNext()

읽어올 요소가 있는지 확인.


# next()

요소 하나 꺼내오기.

---

<br/><br/>

18번.


# **length 와 length() 그리고 size()**

https://mine-it-record.tistory.com/126 참고



---

<br/><br/>

19번.

![이미지](/programming/img/스4.PNG)

인자라고도 부른다.


---

<br/><br/>

20번.



# null ≠ “”;

서로 두개 다르다.


---

<br/><br/>

21번.


# 개발할때 순서

### 실제로 개발하면

1. 요청 파라미터를 받는다.
2. 객체를 만든다. 
3. 객체에 값을 넣어준다.

```java
// 요청 파라미터를 받는다.
@RequestParam String username;
@RequestParam int age;

// 객체를 만든다. 
HelloData data = new HelloData();

// 객체에 값을 넣어준다.
data.setUsername(username);
data.setAge(age);
```

---

<br/><br/>

22번.


# 프로퍼티

### 프로퍼티

getXxx 첫 글자가 대문자 에서 → get을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

setXxx 첫 글자가 대문자 에서 → set을 빼고 첫 글자를 소문자로 바꾸고 xxx 가 된다.

객체에 getUsername() , setUsername() 메서드가 있으면, 이 객체는 username 이라는 프로퍼티를 가지고 있다.

username 프로퍼티의 값을 변경하면 setUsername() 이 호출되고, 조회하면 getUsername() 이 호출된다.

```java
class HelloData {
	getUsername();
	setUsername();
}
```



---

<br/><br/>

23번.


# **instanceof**

예제 1

```java
class Simple1{  
	 public static void main(String args[]) {  

			 Simple1 s=new Simple1();  
			 System.out.println(s instanceof Simple1); // true  
	 }  
}

출력값.
true
```

예제 2.

```java
class Animal{ }  

 
class Dog1 extends Animal{  
	 public static void main(String args[]) {  

			 Dog1 d=new Dog1();  
			 System.out.println(d instanceof Animal)
	 }  
}

출력값.
true  
```

예제 3.



---

<br/><br/>

24번.


• keySet() 메서드는 key의 값만 출력



---

<br/><br/>

25번.


# 메서드 레퍼런스

메소드 레퍼런스란??

첫번째 추천 사이트.

*Hanumoka, IT Blog - https://www.hanumoka.net/2019/01/30/java-20190130-java8-system-out-println/*

두번째 추천 사이트.

*https://myhappyman.tistory.com/65*

![이미지](/programming/img/스5.PNG)

getBan() 메서드를 보면 작성 되어 있다.
```java
int getBan() {
		return ban;
}
```


---

<br/><br/>

26번.


JDBC



---

<br/><br/>

27번.



겟터 셋터, 자비빈 표준 방식 셋다 부를수 있다. (제목까지 포함)

 private 이니깐 외부에서 바로 못꺼내 오니, 메서드를 통해서 꺼내 오는 방식을 말한다.


---

<br/><br/>

28번.


# API

API 방식은?

객체를 반환 하는 것이다.

예를 들어, @ResponseBody 를 풀어 적으면 이렇다.

```java
@Controller
public class HelloController {
	
		@GetMapping("hello-api")
    @ResponseBody
    public String helloApi(@RequestParam("name") String name) {
				Hello hello = new Hello();
				hello.setName = new Hello();	        
				return "hello";
    }

		static class Hello {
			private String name;

			public String getName() {
					return name;
			}

			public void setName(String name) {
					this.name = name;
			}
		}
}
```


---

<br/><br/>

29번.


# **스프링 컨테이너와 빈**

### 스프링 컨테이너

스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 

생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다. 

### 여기서 말하는 자바 객체를 스프링에서는 빈(Bean)이라고 부른다.

개발자는 new 연산자, 인터페이스 호출 방식으로 객체를 생성하고 소멸 시킬 수 있는데, 

스프링 컨테이너가 이 역할을 대신 한다. 

즉, 제어 흐름을 외부에서 관리하는 것이다.

스프링 컨테이너 안에 스프링 빈 저장소가 있고, 그 안에 빈이 들어있다고 생각하시면 됩니다.

![이미지](/programming/img/스6.PNG)


---

<br/><br/>

30번.






---

<br/>

31번.






---

<br/>

32번.






---

<br/>

33번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.






---

<br/>

9번.






---

<br/>

10번.










